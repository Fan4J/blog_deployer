{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/me.jpg","path":"image/me.jpg","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1527594878757},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1527594878757},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1527594878757},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1527594878757},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1527594878757},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1527594878757},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1527594878761},{"_id":"themes/yilia/_config.yml","hash":"9c6376381683baa2610b1d109789a12b61fd93b7","modified":1527596783293},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1527594878769},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1527594878793},{"_id":"source/_posts/Charles进行Https抓包 .md","hash":"a3c80e0fc5ce39d101d9924ca5bdfc2f47122e42","modified":1527593840702},{"_id":"source/_posts/Enum类用法详解.md","hash":"e3c3b58781c22d89266e0dba8986d7906336889c","modified":1527593840702},{"_id":"source/_posts/JAVA应用内存泄漏排查记录.md","hash":"518ebe0a12a6d790f3ea2198d55292defaca6be4","modified":1527593840702},{"_id":"source/_posts/SpringBoot实现REST.md","hash":"56a622a81588636803f1437a6fba1ba44e5fb883","modified":1527593840702},{"_id":"source/_posts/how-to-build-this-blog.md","hash":"42e1a53f9d82b1d6263870d5a4ec62d585f791bb","modified":1527593840702},{"_id":"source/_posts/python-json.md","hash":"9d76dbe7e713aba2e4ce3cff123cb01f87ee26f7","modified":1527593840702},{"_id":"source/_posts/python-知乎登录.md","hash":"0cf50bec8f89ed498e93399e0acb75c320f1c969","modified":1527593840702},{"_id":"source/_posts/ubuntu之初体验.md","hash":"db5c1e556be808703346a57b63ed241aefadc7bc","modified":1527596763049},{"_id":"source/_posts/第一篇博客.md","hash":"d0c8fe132d595d00c220283f3d7774d4129324e0","modified":1527593840702},{"_id":"source/image/me.jpg","hash":"1d37dd8a479f1140c4a59218bb31e1a099297fea","modified":1527595515608},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1527594878753},{"_id":"themes/yilia/.git/config","hash":"bf16b9798becbaefbc4c816b4e8f9a4fa0507563","modified":1527594878757},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1527594733788},{"_id":"themes/yilia/.git/index","hash":"c6a943f95b12f9e83118ca42d9cbd5b3fd09a7d3","modified":1527594878793},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1527594878753},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1527594878761},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1527594878761},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1527594878761},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1527594878761},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1527594878761},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1527594878761},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1527594878761},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1527594878769},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1527594878769},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1527594878769},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1527594878769},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1527594878769},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1527594878769},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1527594878769},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1527594878789},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1527594878793},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1527594878769},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1527594878785},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527594878769},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1527594878789},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1527594878793},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1527594733788},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1527594733788},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1527594733788},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1527594733788},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1527594733788},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1527594733784},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1527594733788},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1527594733788},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1527594733788},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1527594733788},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1527594733788},{"_id":"themes/yilia/.git/logs/HEAD","hash":"4146f0649088dad74f63a30f348182deaedbbf3c","modified":1527594878753},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1527594878761},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1527594878769},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1527594878769},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1527594878785},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1527594878785},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1527594878785},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1527594878785},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1527594878789},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1527594878789},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1527594878789},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1527594878789},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1527594878789},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1527594878769},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1527594878769},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1527594878769},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1527594878769},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1527594878769},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1527594878769},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1527594878769},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1527594878773},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1527594878773},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1527594878773},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1527594878777},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1527594878777},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1527594878777},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1527594878777},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1527594878777},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1527594878777},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1527594878777},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1527594878781},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1527594878781},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1527594878781},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1527594878781},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1527594878781},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1527594878781},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1527594878781},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1527594878781},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1527594878781},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1527594878781},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1527594878785},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1527594878781},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1527594878785},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1527594878785},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1527594878785},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1527594878785},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1527594878785},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1527594878785},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1527594878785},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1527594878785},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1527594878785},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1527594878785},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1527594878769},{"_id":"themes/yilia/.git/objects/pack/pack-b8490dda68e624775e79022edc4d67e2489c374a.idx","hash":"566151aae7e4b3388cf8a52d1249870114e9b0d3","modified":1527594878229},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1527594878753},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1527594878765},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1527594878765},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1527594878773},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1527594878777},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1527594878777},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1527594878777},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1527594878773},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1527594878773},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1527594878773},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1527594878773},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1527594878773},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1527594878777},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1527594878777},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1527594878777},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"4146f0649088dad74f63a30f348182deaedbbf3c","modified":1527594878753},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1527594878753},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"4146f0649088dad74f63a30f348182deaedbbf3c","modified":1527594878753},{"_id":"themes/yilia/.git/objects/pack/pack-b8490dda68e624775e79022edc4d67e2489c374a.pack","hash":"5797696d4c18d63b1238eb31dfba9c4545aeaa83","modified":1527594878229}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Charles进行Htpps抓包","date":"2017-10-10T01:04:14.000Z","_content":">今天在公司打开电脑发现没法登陆Https的网站，知乎百度等，github也上不了，后来查看了自己电脑的代理设置发现代理还开着，原来是蓝灯开机启动直接挂着代理，发现本地还在用Charles代理，研究了下，Charles代理相当于从本地的localhost:8888地址发送请求，如果遇到Http协议的网站，可以直接解析获取数据，遇到Https的网站，无法获取数据包，特此研究一下。\n\n## 1.Charles抓包原理和设置\n\n![Paste_Image.png](http://upload-images.jianshu.io/upload_images/5834071-b1a503f7f689ad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这段话已经清晰的解释了Charles抓包SSL协议的原理，这里首先要回顾下SSL协议请求的原理\n\n![Charles SSL Proxy](http://upload-images.jianshu.io/upload_images/5834071-75935e4d3196cc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上面这张图来源是简书里的另外一篇文章，简单的说客户端向服务端发送请求后，服务端会把自己的证书给客户端看，客户端信任了证书（公钥）之后，通过握手将协商密钥通过公钥加密发送，服务端用私钥解密并校验消息长度并返回给客户端，客户端校验消息长度一致完成后建立连接，双方开始用协商秘钥通过对称加密（比非对称加密速度快）。\nCharles抓Https包的原理就是Charles做中间人，Charles信任远程网站的证书（比如百度https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图\n![初始情况.png](http://upload-images.jianshu.io/upload_images/5834071-203446fcfff97edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n此时Charles没法获取https的数据包，这时设置一下Charles的SSL代理配置，加入www.baidu.com,https的端口号默认为443，加入后再次访问，\n\n![修改CharlesProxy后.png](http://upload-images.jianshu.io/upload_images/5834071-214ebc94f86c2600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![访问百度.png](http://upload-images.jianshu.io/upload_images/5834071-9cacf508ab47e7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时发现可以访问，不过进入网址时会提示是否信任证书，点击继续访问，才会出现如下数据包，里面是进入百度的一些请求，浏览器上可以看到访问风险的图标，点开可以看到是Charles信任baidu的一个证书。\n![证书.png](http://upload-images.jianshu.io/upload_images/5834071-a2faa8183b561283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n浏览器中可以导入证书，信任Charles的根证书之后，正常情况下访问https相应的网站就不会有问题，同时还可以愉快的进行抓包。\n\n## 2. 如何用手机配合Charles抓api\n手机app可以很方便进行抓包，charles/help/SSLProxying下面有个install CA on remote device，点开如下\n![charles](http://upload-images.jianshu.io/upload_images/5834071-6f355164f58db1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这里的Ip实际就是本机在局域网的ip和端口号，这些可以在cmd/ipconfig里面查看，打开手机，设置手机和电脑连接同一个网络，在网络下设置手动代理，proxy地址即为该提示的地址，保存网络\n![网络设置.png](http://upload-images.jianshu.io/upload_images/5834071-9273352b0d1160d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时在手机上点开weibo，电脑上的charles即可看到请求，但是无法抓包，全是unknow，在SSL中添加api.weibo.cn:443，发现同样无法抓包。因为手机上要安装Charles根证书。本人用的是红米，在charles点击保存整数，保存为.pem格式（.cer格式证书无法读取），然后在手机上，wifi/高级设置/安装证书 通过文件查找到这个.pem的证书，起名CharlesProxy，即可。\n再次点开微博，到电脑端查看，如下：\n![微博抓包.png](http://upload-images.jianshu.io/upload_images/5834071-b5c214af6d3f9f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这样就可以看到我们想要的api了，少量的爬取些数据都是ok的。\n\n## 3.关于.cer/.pem有什么区别\n在charles保存CA证书的时候，会发现两种格式，其实这两个文件都是证书，我的手机只能识别.pem的，当然也有些是可以识别.cer的，只是编码的方式不同。证书的作用也是在握手环节用于进行加密，建立连接。\n![save.png](http://upload-images.jianshu.io/upload_images/5834071-8f53d4398cd7bfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[参考文章](http://www.jianshu.com/p/870451cb4eb0)\n[个人博客](https://fan4j.github.io/) 欢迎访问~","source":"_posts/Charles进行Https抓包 .md","raw":"---\ntitle: Charles进行Htpps抓包\ndate: 2017-10-10 09:04:14\ntags: \n\t- 技术\n\t- 博客\n\n---\n>今天在公司打开电脑发现没法登陆Https的网站，知乎百度等，github也上不了，后来查看了自己电脑的代理设置发现代理还开着，原来是蓝灯开机启动直接挂着代理，发现本地还在用Charles代理，研究了下，Charles代理相当于从本地的localhost:8888地址发送请求，如果遇到Http协议的网站，可以直接解析获取数据，遇到Https的网站，无法获取数据包，特此研究一下。\n\n## 1.Charles抓包原理和设置\n\n![Paste_Image.png](http://upload-images.jianshu.io/upload_images/5834071-b1a503f7f689ad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这段话已经清晰的解释了Charles抓包SSL协议的原理，这里首先要回顾下SSL协议请求的原理\n\n![Charles SSL Proxy](http://upload-images.jianshu.io/upload_images/5834071-75935e4d3196cc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上面这张图来源是简书里的另外一篇文章，简单的说客户端向服务端发送请求后，服务端会把自己的证书给客户端看，客户端信任了证书（公钥）之后，通过握手将协商密钥通过公钥加密发送，服务端用私钥解密并校验消息长度并返回给客户端，客户端校验消息长度一致完成后建立连接，双方开始用协商秘钥通过对称加密（比非对称加密速度快）。\nCharles抓Https包的原理就是Charles做中间人，Charles信任远程网站的证书（比如百度https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图\n![初始情况.png](http://upload-images.jianshu.io/upload_images/5834071-203446fcfff97edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n此时Charles没法获取https的数据包，这时设置一下Charles的SSL代理配置，加入www.baidu.com,https的端口号默认为443，加入后再次访问，\n\n![修改CharlesProxy后.png](http://upload-images.jianshu.io/upload_images/5834071-214ebc94f86c2600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![访问百度.png](http://upload-images.jianshu.io/upload_images/5834071-9cacf508ab47e7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时发现可以访问，不过进入网址时会提示是否信任证书，点击继续访问，才会出现如下数据包，里面是进入百度的一些请求，浏览器上可以看到访问风险的图标，点开可以看到是Charles信任baidu的一个证书。\n![证书.png](http://upload-images.jianshu.io/upload_images/5834071-a2faa8183b561283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n浏览器中可以导入证书，信任Charles的根证书之后，正常情况下访问https相应的网站就不会有问题，同时还可以愉快的进行抓包。\n\n## 2. 如何用手机配合Charles抓api\n手机app可以很方便进行抓包，charles/help/SSLProxying下面有个install CA on remote device，点开如下\n![charles](http://upload-images.jianshu.io/upload_images/5834071-6f355164f58db1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这里的Ip实际就是本机在局域网的ip和端口号，这些可以在cmd/ipconfig里面查看，打开手机，设置手机和电脑连接同一个网络，在网络下设置手动代理，proxy地址即为该提示的地址，保存网络\n![网络设置.png](http://upload-images.jianshu.io/upload_images/5834071-9273352b0d1160d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时在手机上点开weibo，电脑上的charles即可看到请求，但是无法抓包，全是unknow，在SSL中添加api.weibo.cn:443，发现同样无法抓包。因为手机上要安装Charles根证书。本人用的是红米，在charles点击保存整数，保存为.pem格式（.cer格式证书无法读取），然后在手机上，wifi/高级设置/安装证书 通过文件查找到这个.pem的证书，起名CharlesProxy，即可。\n再次点开微博，到电脑端查看，如下：\n![微博抓包.png](http://upload-images.jianshu.io/upload_images/5834071-b5c214af6d3f9f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这样就可以看到我们想要的api了，少量的爬取些数据都是ok的。\n\n## 3.关于.cer/.pem有什么区别\n在charles保存CA证书的时候，会发现两种格式，其实这两个文件都是证书，我的手机只能识别.pem的，当然也有些是可以识别.cer的，只是编码的方式不同。证书的作用也是在握手环节用于进行加密，建立连接。\n![save.png](http://upload-images.jianshu.io/upload_images/5834071-8f53d4398cd7bfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[参考文章](http://www.jianshu.com/p/870451cb4eb0)\n[个人博客](https://fan4j.github.io/) 欢迎访问~","slug":"Charles进行Https抓包 ","published":1,"updated":"2018-05-29T11:37:20.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhrnqsrs0000jd6iwuvxm3p1","content":"<blockquote>\n<p>今天在公司打开电脑发现没法登陆Https的网站，知乎百度等，github也上不了，后来查看了自己电脑的代理设置发现代理还开着，原来是蓝灯开机启动直接挂着代理，发现本地还在用Charles代理，研究了下，Charles代理相当于从本地的localhost:8888地址发送请求，如果遇到Http协议的网站，可以直接解析获取数据，遇到Https的网站，无法获取数据包，特此研究一下。</p>\n</blockquote>\n<h2 id=\"1-Charles抓包原理和设置\"><a href=\"#1-Charles抓包原理和设置\" class=\"headerlink\" title=\"1.Charles抓包原理和设置\"></a>1.Charles抓包原理和设置</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-b1a503f7f689ad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></p>\n<p>这段话已经清晰的解释了Charles抓包SSL协议的原理，这里首先要回顾下SSL协议请求的原理</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-75935e4d3196cc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Charles SSL Proxy\"><br>上面这张图来源是简书里的另外一篇文章，简单的说客户端向服务端发送请求后，服务端会把自己的证书给客户端看，客户端信任了证书（公钥）之后，通过握手将协商密钥通过公钥加密发送，服务端用私钥解密并校验消息长度并返回给客户端，客户端校验消息长度一致完成后建立连接，双方开始用协商秘钥通过对称加密（比非对称加密速度快）。<br>Charles抓Https包的原理就是Charles做中间人，Charles信任远程网站的证书（比如百度<a href=\"https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图</a><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-203446fcfff97edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"初始情况.png\"><br>此时Charles没法获取https的数据包，这时设置一下Charles的SSL代理配置，加入<a href=\"http://www.baidu.com,https的端口号默认为443，加入后再次访问，\" target=\"_blank\" rel=\"noopener\">www.baidu.com,https的端口号默认为443，加入后再次访问，</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-214ebc94f86c2600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改CharlesProxy后.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9cacf508ab47e7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"访问百度.png\"><br>这时发现可以访问，不过进入网址时会提示是否信任证书，点击继续访问，才会出现如下数据包，里面是进入百度的一些请求，浏览器上可以看到访问风险的图标，点开可以看到是Charles信任baidu的一个证书。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-a2faa8183b561283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"证书.png\"><br>浏览器中可以导入证书，信任Charles的根证书之后，正常情况下访问https相应的网站就不会有问题，同时还可以愉快的进行抓包。</p>\n<h2 id=\"2-如何用手机配合Charles抓api\"><a href=\"#2-如何用手机配合Charles抓api\" class=\"headerlink\" title=\"2. 如何用手机配合Charles抓api\"></a>2. 如何用手机配合Charles抓api</h2><p>手机app可以很方便进行抓包，charles/help/SSLProxying下面有个install CA on remote device，点开如下<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-6f355164f58db1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"charles\"><br>这里的Ip实际就是本机在局域网的ip和端口号，这些可以在cmd/ipconfig里面查看，打开手机，设置手机和电脑连接同一个网络，在网络下设置手动代理，proxy地址即为该提示的地址，保存网络<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9273352b0d1160d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网络设置.png\"><br>这时在手机上点开weibo，电脑上的charles即可看到请求，但是无法抓包，全是unknow，在SSL中添加api.weibo.cn:443，发现同样无法抓包。因为手机上要安装Charles根证书。本人用的是红米，在charles点击保存整数，保存为.pem格式（.cer格式证书无法读取），然后在手机上，wifi/高级设置/安装证书 通过文件查找到这个.pem的证书，起名CharlesProxy，即可。<br>再次点开微博，到电脑端查看，如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-b5c214af6d3f9f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博抓包.png\"><br>这样就可以看到我们想要的api了，少量的爬取些数据都是ok的。</p>\n<h2 id=\"3-关于-cer-pem有什么区别\"><a href=\"#3-关于-cer-pem有什么区别\" class=\"headerlink\" title=\"3.关于.cer/.pem有什么区别\"></a>3.关于.cer/.pem有什么区别</h2><p>在charles保存CA证书的时候，会发现两种格式，其实这两个文件都是证书，我的手机只能识别.pem的，当然也有些是可以识别.cer的，只是编码的方式不同。证书的作用也是在握手环节用于进行加密，建立连接。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-8f53d4398cd7bfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"save.png\"></p>\n<p><a href=\"http://www.jianshu.com/p/870451cb4eb0\" target=\"_blank\" rel=\"noopener\">参考文章</a><br><a href=\"https://fan4j.github.io/\">个人博客</a> 欢迎访问~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>今天在公司打开电脑发现没法登陆Https的网站，知乎百度等，github也上不了，后来查看了自己电脑的代理设置发现代理还开着，原来是蓝灯开机启动直接挂着代理，发现本地还在用Charles代理，研究了下，Charles代理相当于从本地的localhost:8888地址发送请求，如果遇到Http协议的网站，可以直接解析获取数据，遇到Https的网站，无法获取数据包，特此研究一下。</p>\n</blockquote>\n<h2 id=\"1-Charles抓包原理和设置\"><a href=\"#1-Charles抓包原理和设置\" class=\"headerlink\" title=\"1.Charles抓包原理和设置\"></a>1.Charles抓包原理和设置</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-b1a503f7f689ad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></p>\n<p>这段话已经清晰的解释了Charles抓包SSL协议的原理，这里首先要回顾下SSL协议请求的原理</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-75935e4d3196cc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Charles SSL Proxy\"><br>上面这张图来源是简书里的另外一篇文章，简单的说客户端向服务端发送请求后，服务端会把自己的证书给客户端看，客户端信任了证书（公钥）之后，通过握手将协商密钥通过公钥加密发送，服务端用私钥解密并校验消息长度并返回给客户端，客户端校验消息长度一致完成后建立连接，双方开始用协商秘钥通过对称加密（比非对称加密速度快）。<br>Charles抓Https包的原理就是Charles做中间人，Charles信任远程网站的证书（比如百度<a href=\"https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图</a><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-203446fcfff97edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"初始情况.png\"><br>此时Charles没法获取https的数据包，这时设置一下Charles的SSL代理配置，加入<a href=\"http://www.baidu.com,https的端口号默认为443，加入后再次访问，\" target=\"_blank\" rel=\"noopener\">www.baidu.com,https的端口号默认为443，加入后再次访问，</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-214ebc94f86c2600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改CharlesProxy后.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9cacf508ab47e7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"访问百度.png\"><br>这时发现可以访问，不过进入网址时会提示是否信任证书，点击继续访问，才会出现如下数据包，里面是进入百度的一些请求，浏览器上可以看到访问风险的图标，点开可以看到是Charles信任baidu的一个证书。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-a2faa8183b561283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"证书.png\"><br>浏览器中可以导入证书，信任Charles的根证书之后，正常情况下访问https相应的网站就不会有问题，同时还可以愉快的进行抓包。</p>\n<h2 id=\"2-如何用手机配合Charles抓api\"><a href=\"#2-如何用手机配合Charles抓api\" class=\"headerlink\" title=\"2. 如何用手机配合Charles抓api\"></a>2. 如何用手机配合Charles抓api</h2><p>手机app可以很方便进行抓包，charles/help/SSLProxying下面有个install CA on remote device，点开如下<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-6f355164f58db1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"charles\"><br>这里的Ip实际就是本机在局域网的ip和端口号，这些可以在cmd/ipconfig里面查看，打开手机，设置手机和电脑连接同一个网络，在网络下设置手动代理，proxy地址即为该提示的地址，保存网络<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9273352b0d1160d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网络设置.png\"><br>这时在手机上点开weibo，电脑上的charles即可看到请求，但是无法抓包，全是unknow，在SSL中添加api.weibo.cn:443，发现同样无法抓包。因为手机上要安装Charles根证书。本人用的是红米，在charles点击保存整数，保存为.pem格式（.cer格式证书无法读取），然后在手机上，wifi/高级设置/安装证书 通过文件查找到这个.pem的证书，起名CharlesProxy，即可。<br>再次点开微博，到电脑端查看，如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-b5c214af6d3f9f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博抓包.png\"><br>这样就可以看到我们想要的api了，少量的爬取些数据都是ok的。</p>\n<h2 id=\"3-关于-cer-pem有什么区别\"><a href=\"#3-关于-cer-pem有什么区别\" class=\"headerlink\" title=\"3.关于.cer/.pem有什么区别\"></a>3.关于.cer/.pem有什么区别</h2><p>在charles保存CA证书的时候，会发现两种格式，其实这两个文件都是证书，我的手机只能识别.pem的，当然也有些是可以识别.cer的，只是编码的方式不同。证书的作用也是在握手环节用于进行加密，建立连接。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-8f53d4398cd7bfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"save.png\"></p>\n<p><a href=\"http://www.jianshu.com/p/870451cb4eb0\" target=\"_blank\" rel=\"noopener\">参考文章</a><br><a href=\"https://fan4j.github.io/\">个人博客</a> 欢迎访问~</p>\n"},{"title":"Enum类使用详解","date":"2017-10-24T09:26:09.000Z","comments":1,"_content":"\n>今天自己研究RestApi，其中对请求的响应结果封装成Result类，Result类里面又是三个参数,int类型的code,String类型的message,和object类型的data,其中code是枚举类封装的，特此学习一下，枚举类还是很有用的。\n\n## 1.项目代码中对响应code的封装\n先上代码\n```\npublic enum ResultCode {\n    SUCCESS(200),//成功\n    FAIL(400),//失败\n    UNAUTHORIZED(401),//未认证（签名错误）\n    NOT_FOUND(404),//接口不存在\n    INTERNAL_SERVER_ERROR(500);//服务器内部错误\n\n    int code;\n\n    ResultCode(int code) {\n        this.code = code;\n    }\n}\n```\n枚举类的应用场景：通常用来列举一个类型的有限实例集合，例如颜色，日期，代码等等。\njava.object包下的Enum可以用idea查看下源码，下面有很多子类，如下\n\n![Enum子类.png](http://upload-images.jianshu.io/upload_images/5834071-08cf731d9b97b188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n随便打开一个，都是enum枚举类，代表着各种适合枚举的实例\n\n![MemoryType.png](http://upload-images.jianshu.io/upload_images/5834071-cba8a47b0d36207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n对我们项目中的ResultCode类进行编译，然后反编译，如下：\n```\njavac ResultCode.java #编译得到.class文件\njavap ResultCode.class #反编译\n```\n结果如下\n```\nCompiled from \"ResultCode.java\"\npublic final class ResultCode extends java.lang.Enum<ResultCode> {\n  public static final ResultCode SUCCESS;\n  public static final ResultCode FAIL;\n  public static final ResultCode UNAUTHORIZED;\n  public static final ResultCode NOT_FOUND;\n  public static final ResultCode INTERNAL_SERVER_ERROR;\n  int code;\n  public static ResultCode[] values();\n  public static ResultCode valueOf(java.lang.String);\n  static {};\n}\n```\n可以看到编译后的enum类其实是一个final的class，而且默认集成了java.lang.Enum，因此任何enum类是不能被继承，也不能再继承其他类的。通过这个可以看出，枚举类中包含N个该枚举类的静态的final实例。\n\n## 2 简单的enum类\n```\npublic enum Week {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\n\n```\n在一个TestClass里\n\n![Enum方法.png](http://upload-images.jianshu.io/upload_images/5834071-ec4dcbf913e2ff2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\npublic static void main(String[] args) {\n        Week week = Week.FRI;\n        System.out.println(week.ordinal());\n        System.out.println(week.compareTo(Week.THU));\n        System.out.println(week.name());\n        System.out.println(Week.valueOf(\"FRI\"));\n        System.out.println(Week.values());\n    }\n```\n输出如下\n```\n5\n1\nFRI\nFRI\n[Lcom.j4fan.JiCheng.Week;@2b193f2d\n```\n其中.ordinal()方法是输出枚举类该对象的下标，compareTo()方法也很简单，直接使用下标进行比较\n源码如下，都比较简单。name()和toString()方法都是返回name，因此结果也是一样的，都是该对象的name，还有个静态方法values()，返回该enum下所有的静态实例，是个隐式的方法。\n![compareTo方法.png](http://upload-images.jianshu.io/upload_images/5834071-5bce54d91e0929ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![values()](http://upload-images.jianshu.io/upload_images/5834071-a929957c51713e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3.带有变量的enum类\n先上代码\n```\npublic enum Weekdays {\n    SUN(0), MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6);\n    int value;\n\n    Weekdays(int value) {\n        this.value = value;\n    }\n\n    public static Weekdays getNextDay(Weekdays day) {\n        if (day.value == 6) {\n            return Weekdays.SUN;\n        } else {\n            return getWeekDaysByValue(day.value + 1);\n        }\n    }\n\n    public static Weekdays getWeekDaysByValue(int value) {\n        for (Weekdays c : Weekdays.values()) {\n            if (c.value == value) {\n                return c;\n            }\n        }\n        return null;\n    }\n}\n```\n用法还是很简单的，其次变量可以更加丰富，比如code+message，只需进行封装即可；\n```\npublic enum WeekNote {\n    MON(0,\"work\"),\n    TUE(1,\"play\"),\n    WED(2,\"talk\"),\n    THU(3,\"learn\"),\n    FRI(4,\"read\"),\n    SAT(5,\"laugh\"),\n    SUN(6,\"greet\");\n\n    int code;\n    String message;\n\n    WeekNote(int code,String message){\n        this.code = code;\n        this.message = message;\n    }\n}\n```\n\n## 4.向enum类中添加方法\n其实enum可以对属性加上get/set方法，这里我产生了疑问，既然每个enum实例是final类型的，为什么还可以set呢，这里我做了个实验\n```\npublic class TestClass {\n    private static final User user = new User(\"fan\",\"male\");\n\n    public static void setName(String s) {\n        user.setName(s);\n    }\n\n    public User getUser(){\n        return user;\n    }\n\n    public static void main(String[] args) {\n        TestClass t = new TestClass();\n        t.setName(\"jiang\");\n        System.out.println(t.getUser().getName());\n    }\n}\n```\n这里在方法内部new一个final对象，运行结果证明确实属性被修改了，查找资料，发现我对final的理解有误，对于变量来说，是指不可修改，对于对象来说，是对象的引用不可修改，以后一定要注意。\n\n## 5.enum的其他用法\nenum类虽然是继承了Enum方法，但是还是可以实现其他接口的，因此可以在enum类中加入其他的接口，添加对应的实现。偷懒贴段别人的代码\n```\npublic interface Behaviour {  \n    void print();  \n    String getInfo();  \n}  \npublic enum Color implements Behaviour{  \n    RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n    // 成员变量  \n    private String name;  \n    private int index;  \n    // 构造方法  \n    private Color(String name, int index) {  \n        this.name = name;  \n        this.index = index;  \n    }  \n//接口方法  \n    @Override  \n    public String getInfo() {  \n        return this.name;  \n    }  \n    //接口方法  \n    @Override  \n    public void print() {  \n        System.out.println(this.index+\":\"+this.name);  \n    }  \n}  \n```\n## 总结\nenum枚举类在项目中应用还是挺多的，其实它可以用一个常量类代替，常量类里面都是private static final类型的静态变量，但是容易出现有的朋友调用没有的变量，或者传入一个非主流的code，导致特殊的异常，enum还是有用武之地的。弄完这些，继续去研究restapi了，撤~\n[个人博客](https://fan4j.github.io/)欢迎访问","source":"_posts/Enum类用法详解.md","raw":"---\ntitle: Enum类使用详解\ndate: 2017-10-24 17:26:09\ntags: \n\t- Java\ncomments: true\n---\n\n>今天自己研究RestApi，其中对请求的响应结果封装成Result类，Result类里面又是三个参数,int类型的code,String类型的message,和object类型的data,其中code是枚举类封装的，特此学习一下，枚举类还是很有用的。\n\n## 1.项目代码中对响应code的封装\n先上代码\n```\npublic enum ResultCode {\n    SUCCESS(200),//成功\n    FAIL(400),//失败\n    UNAUTHORIZED(401),//未认证（签名错误）\n    NOT_FOUND(404),//接口不存在\n    INTERNAL_SERVER_ERROR(500);//服务器内部错误\n\n    int code;\n\n    ResultCode(int code) {\n        this.code = code;\n    }\n}\n```\n枚举类的应用场景：通常用来列举一个类型的有限实例集合，例如颜色，日期，代码等等。\njava.object包下的Enum可以用idea查看下源码，下面有很多子类，如下\n\n![Enum子类.png](http://upload-images.jianshu.io/upload_images/5834071-08cf731d9b97b188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n随便打开一个，都是enum枚举类，代表着各种适合枚举的实例\n\n![MemoryType.png](http://upload-images.jianshu.io/upload_images/5834071-cba8a47b0d36207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n对我们项目中的ResultCode类进行编译，然后反编译，如下：\n```\njavac ResultCode.java #编译得到.class文件\njavap ResultCode.class #反编译\n```\n结果如下\n```\nCompiled from \"ResultCode.java\"\npublic final class ResultCode extends java.lang.Enum<ResultCode> {\n  public static final ResultCode SUCCESS;\n  public static final ResultCode FAIL;\n  public static final ResultCode UNAUTHORIZED;\n  public static final ResultCode NOT_FOUND;\n  public static final ResultCode INTERNAL_SERVER_ERROR;\n  int code;\n  public static ResultCode[] values();\n  public static ResultCode valueOf(java.lang.String);\n  static {};\n}\n```\n可以看到编译后的enum类其实是一个final的class，而且默认集成了java.lang.Enum，因此任何enum类是不能被继承，也不能再继承其他类的。通过这个可以看出，枚举类中包含N个该枚举类的静态的final实例。\n\n## 2 简单的enum类\n```\npublic enum Week {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\n\n```\n在一个TestClass里\n\n![Enum方法.png](http://upload-images.jianshu.io/upload_images/5834071-ec4dcbf913e2ff2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\npublic static void main(String[] args) {\n        Week week = Week.FRI;\n        System.out.println(week.ordinal());\n        System.out.println(week.compareTo(Week.THU));\n        System.out.println(week.name());\n        System.out.println(Week.valueOf(\"FRI\"));\n        System.out.println(Week.values());\n    }\n```\n输出如下\n```\n5\n1\nFRI\nFRI\n[Lcom.j4fan.JiCheng.Week;@2b193f2d\n```\n其中.ordinal()方法是输出枚举类该对象的下标，compareTo()方法也很简单，直接使用下标进行比较\n源码如下，都比较简单。name()和toString()方法都是返回name，因此结果也是一样的，都是该对象的name，还有个静态方法values()，返回该enum下所有的静态实例，是个隐式的方法。\n![compareTo方法.png](http://upload-images.jianshu.io/upload_images/5834071-5bce54d91e0929ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![values()](http://upload-images.jianshu.io/upload_images/5834071-a929957c51713e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3.带有变量的enum类\n先上代码\n```\npublic enum Weekdays {\n    SUN(0), MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6);\n    int value;\n\n    Weekdays(int value) {\n        this.value = value;\n    }\n\n    public static Weekdays getNextDay(Weekdays day) {\n        if (day.value == 6) {\n            return Weekdays.SUN;\n        } else {\n            return getWeekDaysByValue(day.value + 1);\n        }\n    }\n\n    public static Weekdays getWeekDaysByValue(int value) {\n        for (Weekdays c : Weekdays.values()) {\n            if (c.value == value) {\n                return c;\n            }\n        }\n        return null;\n    }\n}\n```\n用法还是很简单的，其次变量可以更加丰富，比如code+message，只需进行封装即可；\n```\npublic enum WeekNote {\n    MON(0,\"work\"),\n    TUE(1,\"play\"),\n    WED(2,\"talk\"),\n    THU(3,\"learn\"),\n    FRI(4,\"read\"),\n    SAT(5,\"laugh\"),\n    SUN(6,\"greet\");\n\n    int code;\n    String message;\n\n    WeekNote(int code,String message){\n        this.code = code;\n        this.message = message;\n    }\n}\n```\n\n## 4.向enum类中添加方法\n其实enum可以对属性加上get/set方法，这里我产生了疑问，既然每个enum实例是final类型的，为什么还可以set呢，这里我做了个实验\n```\npublic class TestClass {\n    private static final User user = new User(\"fan\",\"male\");\n\n    public static void setName(String s) {\n        user.setName(s);\n    }\n\n    public User getUser(){\n        return user;\n    }\n\n    public static void main(String[] args) {\n        TestClass t = new TestClass();\n        t.setName(\"jiang\");\n        System.out.println(t.getUser().getName());\n    }\n}\n```\n这里在方法内部new一个final对象，运行结果证明确实属性被修改了，查找资料，发现我对final的理解有误，对于变量来说，是指不可修改，对于对象来说，是对象的引用不可修改，以后一定要注意。\n\n## 5.enum的其他用法\nenum类虽然是继承了Enum方法，但是还是可以实现其他接口的，因此可以在enum类中加入其他的接口，添加对应的实现。偷懒贴段别人的代码\n```\npublic interface Behaviour {  \n    void print();  \n    String getInfo();  \n}  \npublic enum Color implements Behaviour{  \n    RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n    // 成员变量  \n    private String name;  \n    private int index;  \n    // 构造方法  \n    private Color(String name, int index) {  \n        this.name = name;  \n        this.index = index;  \n    }  \n//接口方法  \n    @Override  \n    public String getInfo() {  \n        return this.name;  \n    }  \n    //接口方法  \n    @Override  \n    public void print() {  \n        System.out.println(this.index+\":\"+this.name);  \n    }  \n}  \n```\n## 总结\nenum枚举类在项目中应用还是挺多的，其实它可以用一个常量类代替，常量类里面都是private static final类型的静态变量，但是容易出现有的朋友调用没有的变量，或者传入一个非主流的code，导致特殊的异常，enum还是有用武之地的。弄完这些，继续去研究restapi了，撤~\n[个人博客](https://fan4j.github.io/)欢迎访问","slug":"Enum类用法详解","published":1,"updated":"2018-05-29T11:37:20.702Z","layout":"post","photos":[],"link":"","_id":"cjhrnqsrz0001jd6i0z7ynp9m","content":"<blockquote>\n<p>今天自己研究RestApi，其中对请求的响应结果封装成Result类，Result类里面又是三个参数,int类型的code,String类型的message,和object类型的data,其中code是枚举类封装的，特此学习一下，枚举类还是很有用的。</p>\n</blockquote>\n<h2 id=\"1-项目代码中对响应code的封装\"><a href=\"#1-项目代码中对响应code的封装\" class=\"headerlink\" title=\"1.项目代码中对响应code的封装\"></a>1.项目代码中对响应code的封装</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum ResultCode &#123;</span><br><span class=\"line\">    SUCCESS(200),//成功</span><br><span class=\"line\">    FAIL(400),//失败</span><br><span class=\"line\">    UNAUTHORIZED(401),//未认证（签名错误）</span><br><span class=\"line\">    NOT_FOUND(404),//接口不存在</span><br><span class=\"line\">    INTERNAL_SERVER_ERROR(500);//服务器内部错误</span><br><span class=\"line\"></span><br><span class=\"line\">    int code;</span><br><span class=\"line\"></span><br><span class=\"line\">    ResultCode(int code) &#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>枚举类的应用场景：通常用来列举一个类型的有限实例集合，例如颜色，日期，代码等等。<br>java.object包下的Enum可以用idea查看下源码，下面有很多子类，如下</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-08cf731d9b97b188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Enum子类.png\"><br>随便打开一个，都是enum枚举类，代表着各种适合枚举的实例</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-cba8a47b0d36207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MemoryType.png\"><br>对我们项目中的ResultCode类进行编译，然后反编译，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac ResultCode.java #编译得到.class文件</span><br><span class=\"line\">javap ResultCode.class #反编译</span><br></pre></td></tr></table></figure></p>\n<p>结果如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from &quot;ResultCode.java&quot;</span><br><span class=\"line\">public final class ResultCode extends java.lang.Enum&lt;ResultCode&gt; &#123;</span><br><span class=\"line\">  public static final ResultCode SUCCESS;</span><br><span class=\"line\">  public static final ResultCode FAIL;</span><br><span class=\"line\">  public static final ResultCode UNAUTHORIZED;</span><br><span class=\"line\">  public static final ResultCode NOT_FOUND;</span><br><span class=\"line\">  public static final ResultCode INTERNAL_SERVER_ERROR;</span><br><span class=\"line\">  int code;</span><br><span class=\"line\">  public static ResultCode[] values();</span><br><span class=\"line\">  public static ResultCode valueOf(java.lang.String);</span><br><span class=\"line\">  static &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到编译后的enum类其实是一个final的class，而且默认集成了java.lang.Enum，因此任何enum类是不能被继承，也不能再继承其他类的。通过这个可以看出，枚举类中包含N个该枚举类的静态的final实例。</p>\n<h2 id=\"2-简单的enum类\"><a href=\"#2-简单的enum类\" class=\"headerlink\" title=\"2 简单的enum类\"></a>2 简单的enum类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Week &#123;</span><br><span class=\"line\">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在一个TestClass里</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-ec4dcbf913e2ff2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Enum方法.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        Week week = Week.FRI;</span><br><span class=\"line\">        System.out.println(week.ordinal());</span><br><span class=\"line\">        System.out.println(week.compareTo(Week.THU));</span><br><span class=\"line\">        System.out.println(week.name());</span><br><span class=\"line\">        System.out.println(Week.valueOf(&quot;FRI&quot;));</span><br><span class=\"line\">        System.out.println(Week.values());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1</span><br><span class=\"line\">FRI</span><br><span class=\"line\">FRI</span><br><span class=\"line\">[Lcom.j4fan.JiCheng.Week;@2b193f2d</span><br></pre></td></tr></table></figure></p>\n<p>其中.ordinal()方法是输出枚举类该对象的下标，compareTo()方法也很简单，直接使用下标进行比较<br>源码如下，都比较简单。name()和toString()方法都是返回name，因此结果也是一样的，都是该对象的name，还有个静态方法values()，返回该enum下所有的静态实例，是个隐式的方法。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-5bce54d91e0929ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"compareTo方法.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-a929957c51713e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"values()\"></p>\n<h2 id=\"3-带有变量的enum类\"><a href=\"#3-带有变量的enum类\" class=\"headerlink\" title=\"3.带有变量的enum类\"></a>3.带有变量的enum类</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Weekdays &#123;</span><br><span class=\"line\">    SUN(0), MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6);</span><br><span class=\"line\">    int value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Weekdays(int value) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Weekdays getNextDay(Weekdays day) &#123;</span><br><span class=\"line\">        if (day.value == 6) &#123;</span><br><span class=\"line\">            return Weekdays.SUN;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return getWeekDaysByValue(day.value + 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Weekdays getWeekDaysByValue(int value) &#123;</span><br><span class=\"line\">        for (Weekdays c : Weekdays.values()) &#123;</span><br><span class=\"line\">            if (c.value == value) &#123;</span><br><span class=\"line\">                return c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用法还是很简单的，其次变量可以更加丰富，比如code+message，只需进行封装即可；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum WeekNote &#123;</span><br><span class=\"line\">    MON(0,&quot;work&quot;),</span><br><span class=\"line\">    TUE(1,&quot;play&quot;),</span><br><span class=\"line\">    WED(2,&quot;talk&quot;),</span><br><span class=\"line\">    THU(3,&quot;learn&quot;),</span><br><span class=\"line\">    FRI(4,&quot;read&quot;),</span><br><span class=\"line\">    SAT(5,&quot;laugh&quot;),</span><br><span class=\"line\">    SUN(6,&quot;greet&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    int code;</span><br><span class=\"line\">    String message;</span><br><span class=\"line\"></span><br><span class=\"line\">    WeekNote(int code,String message)&#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">        this.message = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-向enum类中添加方法\"><a href=\"#4-向enum类中添加方法\" class=\"headerlink\" title=\"4.向enum类中添加方法\"></a>4.向enum类中添加方法</h2><p>其实enum可以对属性加上get/set方法，这里我产生了疑问，既然每个enum实例是final类型的，为什么还可以set呢，这里我做了个实验<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestClass &#123;</span><br><span class=\"line\">    private static final User user = new User(&quot;fan&quot;,&quot;male&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void setName(String s) &#123;</span><br><span class=\"line\">        user.setName(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User getUser()&#123;</span><br><span class=\"line\">        return user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        TestClass t = new TestClass();</span><br><span class=\"line\">        t.setName(&quot;jiang&quot;);</span><br><span class=\"line\">        System.out.println(t.getUser().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里在方法内部new一个final对象，运行结果证明确实属性被修改了，查找资料，发现我对final的理解有误，对于变量来说，是指不可修改，对于对象来说，是对象的引用不可修改，以后一定要注意。</p>\n<h2 id=\"5-enum的其他用法\"><a href=\"#5-enum的其他用法\" class=\"headerlink\" title=\"5.enum的其他用法\"></a>5.enum的其他用法</h2><p>enum类虽然是继承了Enum方法，但是还是可以实现其他接口的，因此可以在enum类中加入其他的接口，添加对应的实现。偷懒贴段别人的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Behaviour &#123;  </span><br><span class=\"line\">    void print();  </span><br><span class=\"line\">    String getInfo();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public enum Color implements Behaviour&#123;  </span><br><span class=\"line\">    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class=\"line\">    // 成员变量  </span><br><span class=\"line\">    private String name;  </span><br><span class=\"line\">    private int index;  </span><br><span class=\"line\">    // 构造方法  </span><br><span class=\"line\">    private Color(String name, int index) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.index = index;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">//接口方法  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String getInfo() &#123;  </span><br><span class=\"line\">        return this.name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    //接口方法  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void print() &#123;  </span><br><span class=\"line\">        System.out.println(this.index+&quot;:&quot;+this.name);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>enum枚举类在项目中应用还是挺多的，其实它可以用一个常量类代替，常量类里面都是private static final类型的静态变量，但是容易出现有的朋友调用没有的变量，或者传入一个非主流的code，导致特殊的异常，enum还是有用武之地的。弄完这些，继续去研究restapi了，撤~<br><a href=\"https://fan4j.github.io/\">个人博客</a>欢迎访问</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>今天自己研究RestApi，其中对请求的响应结果封装成Result类，Result类里面又是三个参数,int类型的code,String类型的message,和object类型的data,其中code是枚举类封装的，特此学习一下，枚举类还是很有用的。</p>\n</blockquote>\n<h2 id=\"1-项目代码中对响应code的封装\"><a href=\"#1-项目代码中对响应code的封装\" class=\"headerlink\" title=\"1.项目代码中对响应code的封装\"></a>1.项目代码中对响应code的封装</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum ResultCode &#123;</span><br><span class=\"line\">    SUCCESS(200),//成功</span><br><span class=\"line\">    FAIL(400),//失败</span><br><span class=\"line\">    UNAUTHORIZED(401),//未认证（签名错误）</span><br><span class=\"line\">    NOT_FOUND(404),//接口不存在</span><br><span class=\"line\">    INTERNAL_SERVER_ERROR(500);//服务器内部错误</span><br><span class=\"line\"></span><br><span class=\"line\">    int code;</span><br><span class=\"line\"></span><br><span class=\"line\">    ResultCode(int code) &#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>枚举类的应用场景：通常用来列举一个类型的有限实例集合，例如颜色，日期，代码等等。<br>java.object包下的Enum可以用idea查看下源码，下面有很多子类，如下</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-08cf731d9b97b188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Enum子类.png\"><br>随便打开一个，都是enum枚举类，代表着各种适合枚举的实例</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-cba8a47b0d36207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MemoryType.png\"><br>对我们项目中的ResultCode类进行编译，然后反编译，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac ResultCode.java #编译得到.class文件</span><br><span class=\"line\">javap ResultCode.class #反编译</span><br></pre></td></tr></table></figure></p>\n<p>结果如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from &quot;ResultCode.java&quot;</span><br><span class=\"line\">public final class ResultCode extends java.lang.Enum&lt;ResultCode&gt; &#123;</span><br><span class=\"line\">  public static final ResultCode SUCCESS;</span><br><span class=\"line\">  public static final ResultCode FAIL;</span><br><span class=\"line\">  public static final ResultCode UNAUTHORIZED;</span><br><span class=\"line\">  public static final ResultCode NOT_FOUND;</span><br><span class=\"line\">  public static final ResultCode INTERNAL_SERVER_ERROR;</span><br><span class=\"line\">  int code;</span><br><span class=\"line\">  public static ResultCode[] values();</span><br><span class=\"line\">  public static ResultCode valueOf(java.lang.String);</span><br><span class=\"line\">  static &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到编译后的enum类其实是一个final的class，而且默认集成了java.lang.Enum，因此任何enum类是不能被继承，也不能再继承其他类的。通过这个可以看出，枚举类中包含N个该枚举类的静态的final实例。</p>\n<h2 id=\"2-简单的enum类\"><a href=\"#2-简单的enum类\" class=\"headerlink\" title=\"2 简单的enum类\"></a>2 简单的enum类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Week &#123;</span><br><span class=\"line\">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在一个TestClass里</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-ec4dcbf913e2ff2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Enum方法.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        Week week = Week.FRI;</span><br><span class=\"line\">        System.out.println(week.ordinal());</span><br><span class=\"line\">        System.out.println(week.compareTo(Week.THU));</span><br><span class=\"line\">        System.out.println(week.name());</span><br><span class=\"line\">        System.out.println(Week.valueOf(&quot;FRI&quot;));</span><br><span class=\"line\">        System.out.println(Week.values());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1</span><br><span class=\"line\">FRI</span><br><span class=\"line\">FRI</span><br><span class=\"line\">[Lcom.j4fan.JiCheng.Week;@2b193f2d</span><br></pre></td></tr></table></figure></p>\n<p>其中.ordinal()方法是输出枚举类该对象的下标，compareTo()方法也很简单，直接使用下标进行比较<br>源码如下，都比较简单。name()和toString()方法都是返回name，因此结果也是一样的，都是该对象的name，还有个静态方法values()，返回该enum下所有的静态实例，是个隐式的方法。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-5bce54d91e0929ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"compareTo方法.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-a929957c51713e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"values()\"></p>\n<h2 id=\"3-带有变量的enum类\"><a href=\"#3-带有变量的enum类\" class=\"headerlink\" title=\"3.带有变量的enum类\"></a>3.带有变量的enum类</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Weekdays &#123;</span><br><span class=\"line\">    SUN(0), MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6);</span><br><span class=\"line\">    int value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Weekdays(int value) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Weekdays getNextDay(Weekdays day) &#123;</span><br><span class=\"line\">        if (day.value == 6) &#123;</span><br><span class=\"line\">            return Weekdays.SUN;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return getWeekDaysByValue(day.value + 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Weekdays getWeekDaysByValue(int value) &#123;</span><br><span class=\"line\">        for (Weekdays c : Weekdays.values()) &#123;</span><br><span class=\"line\">            if (c.value == value) &#123;</span><br><span class=\"line\">                return c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用法还是很简单的，其次变量可以更加丰富，比如code+message，只需进行封装即可；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum WeekNote &#123;</span><br><span class=\"line\">    MON(0,&quot;work&quot;),</span><br><span class=\"line\">    TUE(1,&quot;play&quot;),</span><br><span class=\"line\">    WED(2,&quot;talk&quot;),</span><br><span class=\"line\">    THU(3,&quot;learn&quot;),</span><br><span class=\"line\">    FRI(4,&quot;read&quot;),</span><br><span class=\"line\">    SAT(5,&quot;laugh&quot;),</span><br><span class=\"line\">    SUN(6,&quot;greet&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    int code;</span><br><span class=\"line\">    String message;</span><br><span class=\"line\"></span><br><span class=\"line\">    WeekNote(int code,String message)&#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">        this.message = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-向enum类中添加方法\"><a href=\"#4-向enum类中添加方法\" class=\"headerlink\" title=\"4.向enum类中添加方法\"></a>4.向enum类中添加方法</h2><p>其实enum可以对属性加上get/set方法，这里我产生了疑问，既然每个enum实例是final类型的，为什么还可以set呢，这里我做了个实验<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestClass &#123;</span><br><span class=\"line\">    private static final User user = new User(&quot;fan&quot;,&quot;male&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void setName(String s) &#123;</span><br><span class=\"line\">        user.setName(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User getUser()&#123;</span><br><span class=\"line\">        return user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        TestClass t = new TestClass();</span><br><span class=\"line\">        t.setName(&quot;jiang&quot;);</span><br><span class=\"line\">        System.out.println(t.getUser().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里在方法内部new一个final对象，运行结果证明确实属性被修改了，查找资料，发现我对final的理解有误，对于变量来说，是指不可修改，对于对象来说，是对象的引用不可修改，以后一定要注意。</p>\n<h2 id=\"5-enum的其他用法\"><a href=\"#5-enum的其他用法\" class=\"headerlink\" title=\"5.enum的其他用法\"></a>5.enum的其他用法</h2><p>enum类虽然是继承了Enum方法，但是还是可以实现其他接口的，因此可以在enum类中加入其他的接口，添加对应的实现。偷懒贴段别人的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Behaviour &#123;  </span><br><span class=\"line\">    void print();  </span><br><span class=\"line\">    String getInfo();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public enum Color implements Behaviour&#123;  </span><br><span class=\"line\">    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class=\"line\">    // 成员变量  </span><br><span class=\"line\">    private String name;  </span><br><span class=\"line\">    private int index;  </span><br><span class=\"line\">    // 构造方法  </span><br><span class=\"line\">    private Color(String name, int index) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.index = index;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">//接口方法  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String getInfo() &#123;  </span><br><span class=\"line\">        return this.name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    //接口方法  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void print() &#123;  </span><br><span class=\"line\">        System.out.println(this.index+&quot;:&quot;+this.name);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>enum枚举类在项目中应用还是挺多的，其实它可以用一个常量类代替，常量类里面都是private static final类型的静态变量，但是容易出现有的朋友调用没有的变量，或者传入一个非主流的code，导致特殊的异常，enum还是有用武之地的。弄完这些，继续去研究restapi了，撤~<br><a href=\"https://fan4j.github.io/\">个人博客</a>欢迎访问</p>\n"},{"title":"JAVA应用内存泄漏排查记录","date":"2017-10-20T02:21:00.000Z","comments":1,"_content":">最近公司的一台服务器频繁报警，老大让我研究下代码出了什么问题，咋一看才知道代码是用大名鼎鼎的异步框架Vert.x写的，本文记录本菜鸟排查问题的辛酸过程，仅作为以后的一点经验参考。本服务器阿里云双核ECS实例，2G内存，CentOS7系统。\n\n## 1.查看服务器硬盘内存状况\n```\ntop #查看服务器内存和硬盘容量\n\n```\n![top](http://upload-images.jianshu.io/upload_images/5834071-261a02461a048ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n看了下参数，以为这些挺重要的，其实发现CPU和Mem都很正常，内存看似要用完了，其实free+buffers+cached大概容量也有900M，完全够用。\n\n## 2.查看服务器进程的堆栈\n```\njcmd #查看进程，发现有两个java项目，一个是公司的web项目，另一个是报警的Vertx项目\njinfo [pid] 查看堆内存，发现一个项目的内存参数-Xms1450M，本项目采用的默认配置，暂时看不出分配多少内存\nor ps aux | grep tomcat | grep -v grep  查看初始内存使用\njstack [pid] 看栈信息，发现很多歌vert.thread在等待，因为服务器相应缓慢，看了下Log，看到了NPE\n```\n初步分析，NullPointerException导致了服务器相应缓慢。\n首先调查，为什么会NullPointerException,根据Log很容易找到原因，最后配合前端同事知道新版本的前端请求格式不对造成报错。\n那么问题来了，报错为什么会导致应用相应缓慢。可能是连接没有释放，或者是持久层插入错误数据报错没有释放连接。\n\n## 3 查看进程具体内存\n```\njinfo [pid] 查看到初始化的配置 \n```\n看到Vertx最大堆内存300M,old区只有50M，这个我很纳闷，照理说默认配置新生区和old区比例是1:2起码也有200M,这样不会oom吗。\n```\njmap -heap [pid] 查看堆内存各个分区大小,old区使用率90%以上，如果加大Old，如果还不行，肯定是内存泄漏了，就是对象没有释放。\njstat -gcutil [pid] 1s 发现最近发生了6次FGC old区依然降不下去\n```\n果然过了一天，log就出现了heap Out Of Memory.\n\n## 4 尝试增加虚拟机内存分配\njavaweb项目部署在tomcat下,系统为它分配了1450M的内存，打开tomcat/bin/catalina.sh，修改\n```\nJAVA_OPTS= -Xms1000M -Xmx1000M，这里保证初始分配内存和最大堆内存相同，放置系统调整内存空间产生的消耗。\n```\n同时给报警的Vertx项目增加内存，\n```\njava -Xms700M -Xmx700M -jar >>t.log 2>&1 & 将标准输出重定向\n参数说明如下\n-Xms 初始化对内存\n-Xmx 最大堆内存\n-Xss每个线程内存\n-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64\n-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4\n```\n重启项目后，过一段时间继续查看\n```\njmap -heap [pid] 发现堆内存Old区飙升，还是达到了90%\n```\n## 5 查看代码，检查内存泄漏位置\n```\njstat -gcutil [pid] 60000  查看从程序启动到现在进行了多少FGC,查看下old区百分比\njmap -histo:live [pid] >f 打印堆内存存活对象信息\nvi f\n```\n通过查看对象信息，从上往下发现有个对象EventItem被实例化了10w+次，这个类里面包含的数组，对象数组响应实例化次数也和其他不在同一数量级。确定是这个问题，回到代码中，我找到了初始化该对象的位置，应该是报错之后，request没有释放，request里面的private对象UploadRequest没有释放，导致错误的EventItem也无法释放。\n于是我在出错的try.catch语句中直接将整个请求return,因为这些数据其实都是些无效的数据，直接return也可以节约不少开销。\n\n## 后续观察\n修改代码后，重新发布，已近观察3天，出错项目的heap的old区使用率终于降下来了，dump了对象信息也没有大量的EventItem，服务器运行终于正常，说明问题解决了。这个过程中经历了一些坑，比如错误的以为是另外一个项目影响造成，浪费了不少时间排查，不过学到不少东西。\njinfo/jmap/jstat这些命令是调优时候常用的，dump出文件查看对象信息，jconsole监控本地jvm运行状况，通过修改jvm参数调整服务响应时间等等。\n代码没有贴出来，具体信息也没细说，因为涉及公司项目还是保密为好，文章就留着以后回顾下吧。","source":"_posts/JAVA应用内存泄漏排查记录.md","raw":"---\ntitle: JAVA应用内存泄漏排查记录\ndate: 2017-10-20 10:21:00\ntags: \n\t- Java\n\t- Linux\n\t- JVM\ncomments: true\n---\n>最近公司的一台服务器频繁报警，老大让我研究下代码出了什么问题，咋一看才知道代码是用大名鼎鼎的异步框架Vert.x写的，本文记录本菜鸟排查问题的辛酸过程，仅作为以后的一点经验参考。本服务器阿里云双核ECS实例，2G内存，CentOS7系统。\n\n## 1.查看服务器硬盘内存状况\n```\ntop #查看服务器内存和硬盘容量\n\n```\n![top](http://upload-images.jianshu.io/upload_images/5834071-261a02461a048ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n看了下参数，以为这些挺重要的，其实发现CPU和Mem都很正常，内存看似要用完了，其实free+buffers+cached大概容量也有900M，完全够用。\n\n## 2.查看服务器进程的堆栈\n```\njcmd #查看进程，发现有两个java项目，一个是公司的web项目，另一个是报警的Vertx项目\njinfo [pid] 查看堆内存，发现一个项目的内存参数-Xms1450M，本项目采用的默认配置，暂时看不出分配多少内存\nor ps aux | grep tomcat | grep -v grep  查看初始内存使用\njstack [pid] 看栈信息，发现很多歌vert.thread在等待，因为服务器相应缓慢，看了下Log，看到了NPE\n```\n初步分析，NullPointerException导致了服务器相应缓慢。\n首先调查，为什么会NullPointerException,根据Log很容易找到原因，最后配合前端同事知道新版本的前端请求格式不对造成报错。\n那么问题来了，报错为什么会导致应用相应缓慢。可能是连接没有释放，或者是持久层插入错误数据报错没有释放连接。\n\n## 3 查看进程具体内存\n```\njinfo [pid] 查看到初始化的配置 \n```\n看到Vertx最大堆内存300M,old区只有50M，这个我很纳闷，照理说默认配置新生区和old区比例是1:2起码也有200M,这样不会oom吗。\n```\njmap -heap [pid] 查看堆内存各个分区大小,old区使用率90%以上，如果加大Old，如果还不行，肯定是内存泄漏了，就是对象没有释放。\njstat -gcutil [pid] 1s 发现最近发生了6次FGC old区依然降不下去\n```\n果然过了一天，log就出现了heap Out Of Memory.\n\n## 4 尝试增加虚拟机内存分配\njavaweb项目部署在tomcat下,系统为它分配了1450M的内存，打开tomcat/bin/catalina.sh，修改\n```\nJAVA_OPTS= -Xms1000M -Xmx1000M，这里保证初始分配内存和最大堆内存相同，放置系统调整内存空间产生的消耗。\n```\n同时给报警的Vertx项目增加内存，\n```\njava -Xms700M -Xmx700M -jar >>t.log 2>&1 & 将标准输出重定向\n参数说明如下\n-Xms 初始化对内存\n-Xmx 最大堆内存\n-Xss每个线程内存\n-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64\n-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4\n```\n重启项目后，过一段时间继续查看\n```\njmap -heap [pid] 发现堆内存Old区飙升，还是达到了90%\n```\n## 5 查看代码，检查内存泄漏位置\n```\njstat -gcutil [pid] 60000  查看从程序启动到现在进行了多少FGC,查看下old区百分比\njmap -histo:live [pid] >f 打印堆内存存活对象信息\nvi f\n```\n通过查看对象信息，从上往下发现有个对象EventItem被实例化了10w+次，这个类里面包含的数组，对象数组响应实例化次数也和其他不在同一数量级。确定是这个问题，回到代码中，我找到了初始化该对象的位置，应该是报错之后，request没有释放，request里面的private对象UploadRequest没有释放，导致错误的EventItem也无法释放。\n于是我在出错的try.catch语句中直接将整个请求return,因为这些数据其实都是些无效的数据，直接return也可以节约不少开销。\n\n## 后续观察\n修改代码后，重新发布，已近观察3天，出错项目的heap的old区使用率终于降下来了，dump了对象信息也没有大量的EventItem，服务器运行终于正常，说明问题解决了。这个过程中经历了一些坑，比如错误的以为是另外一个项目影响造成，浪费了不少时间排查，不过学到不少东西。\njinfo/jmap/jstat这些命令是调优时候常用的，dump出文件查看对象信息，jconsole监控本地jvm运行状况，通过修改jvm参数调整服务响应时间等等。\n代码没有贴出来，具体信息也没细说，因为涉及公司项目还是保密为好，文章就留着以后回顾下吧。","slug":"JAVA应用内存泄漏排查记录","published":1,"updated":"2018-05-29T11:37:20.702Z","layout":"post","photos":[],"link":"","_id":"cjhrnqss90003jd6ip3s4nap5","content":"<blockquote>\n<p>最近公司的一台服务器频繁报警，老大让我研究下代码出了什么问题，咋一看才知道代码是用大名鼎鼎的异步框架Vert.x写的，本文记录本菜鸟排查问题的辛酸过程，仅作为以后的一点经验参考。本服务器阿里云双核ECS实例，2G内存，CentOS7系统。</p>\n</blockquote>\n<h2 id=\"1-查看服务器硬盘内存状况\"><a href=\"#1-查看服务器硬盘内存状况\" class=\"headerlink\" title=\"1.查看服务器硬盘内存状况\"></a>1.查看服务器硬盘内存状况</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top #查看服务器内存和硬盘容量</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-261a02461a048ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"top\"><br>看了下参数，以为这些挺重要的，其实发现CPU和Mem都很正常，内存看似要用完了，其实free+buffers+cached大概容量也有900M，完全够用。</p>\n<h2 id=\"2-查看服务器进程的堆栈\"><a href=\"#2-查看服务器进程的堆栈\" class=\"headerlink\" title=\"2.查看服务器进程的堆栈\"></a>2.查看服务器进程的堆栈</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jcmd #查看进程，发现有两个java项目，一个是公司的web项目，另一个是报警的Vertx项目</span><br><span class=\"line\">jinfo [pid] 查看堆内存，发现一个项目的内存参数-Xms1450M，本项目采用的默认配置，暂时看不出分配多少内存</span><br><span class=\"line\">or ps aux | grep tomcat | grep -v grep  查看初始内存使用</span><br><span class=\"line\">jstack [pid] 看栈信息，发现很多歌vert.thread在等待，因为服务器相应缓慢，看了下Log，看到了NPE</span><br></pre></td></tr></table></figure>\n<p>初步分析，NullPointerException导致了服务器相应缓慢。<br>首先调查，为什么会NullPointerException,根据Log很容易找到原因，最后配合前端同事知道新版本的前端请求格式不对造成报错。<br>那么问题来了，报错为什么会导致应用相应缓慢。可能是连接没有释放，或者是持久层插入错误数据报错没有释放连接。</p>\n<h2 id=\"3-查看进程具体内存\"><a href=\"#3-查看进程具体内存\" class=\"headerlink\" title=\"3 查看进程具体内存\"></a>3 查看进程具体内存</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [pid] 查看到初始化的配置</span><br></pre></td></tr></table></figure>\n<p>看到Vertx最大堆内存300M,old区只有50M，这个我很纳闷，照理说默认配置新生区和old区比例是1:2起码也有200M,这样不会oom吗。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap [pid] 查看堆内存各个分区大小,old区使用率90%以上，如果加大Old，如果还不行，肯定是内存泄漏了，就是对象没有释放。</span><br><span class=\"line\">jstat -gcutil [pid] 1s 发现最近发生了6次FGC old区依然降不下去</span><br></pre></td></tr></table></figure></p>\n<p>果然过了一天，log就出现了heap Out Of Memory.</p>\n<h2 id=\"4-尝试增加虚拟机内存分配\"><a href=\"#4-尝试增加虚拟机内存分配\" class=\"headerlink\" title=\"4 尝试增加虚拟机内存分配\"></a>4 尝试增加虚拟机内存分配</h2><p>javaweb项目部署在tomcat下,系统为它分配了1450M的内存，打开tomcat/bin/catalina.sh，修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_OPTS= -Xms1000M -Xmx1000M，这里保证初始分配内存和最大堆内存相同，放置系统调整内存空间产生的消耗。</span><br></pre></td></tr></table></figure></p>\n<p>同时给报警的Vertx项目增加内存，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xms700M -Xmx700M -jar &gt;&gt;t.log 2&gt;&amp;1 &amp; 将标准输出重定向</span><br><span class=\"line\">参数说明如下</span><br><span class=\"line\">-Xms 初始化对内存</span><br><span class=\"line\">-Xmx 最大堆内存</span><br><span class=\"line\">-Xss每个线程内存</span><br><span class=\"line\">-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64</span><br><span class=\"line\">-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4</span><br></pre></td></tr></table></figure></p>\n<p>重启项目后，过一段时间继续查看<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap [pid] 发现堆内存Old区飙升，还是达到了90%</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-查看代码，检查内存泄漏位置\"><a href=\"#5-查看代码，检查内存泄漏位置\" class=\"headerlink\" title=\"5 查看代码，检查内存泄漏位置\"></a>5 查看代码，检查内存泄漏位置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -gcutil [pid] 60000  查看从程序启动到现在进行了多少FGC,查看下old区百分比</span><br><span class=\"line\">jmap -histo:live [pid] &gt;f 打印堆内存存活对象信息</span><br><span class=\"line\">vi f</span><br></pre></td></tr></table></figure>\n<p>通过查看对象信息，从上往下发现有个对象EventItem被实例化了10w+次，这个类里面包含的数组，对象数组响应实例化次数也和其他不在同一数量级。确定是这个问题，回到代码中，我找到了初始化该对象的位置，应该是报错之后，request没有释放，request里面的private对象UploadRequest没有释放，导致错误的EventItem也无法释放。<br>于是我在出错的try.catch语句中直接将整个请求return,因为这些数据其实都是些无效的数据，直接return也可以节约不少开销。</p>\n<h2 id=\"后续观察\"><a href=\"#后续观察\" class=\"headerlink\" title=\"后续观察\"></a>后续观察</h2><p>修改代码后，重新发布，已近观察3天，出错项目的heap的old区使用率终于降下来了，dump了对象信息也没有大量的EventItem，服务器运行终于正常，说明问题解决了。这个过程中经历了一些坑，比如错误的以为是另外一个项目影响造成，浪费了不少时间排查，不过学到不少东西。<br>jinfo/jmap/jstat这些命令是调优时候常用的，dump出文件查看对象信息，jconsole监控本地jvm运行状况，通过修改jvm参数调整服务响应时间等等。<br>代码没有贴出来，具体信息也没细说，因为涉及公司项目还是保密为好，文章就留着以后回顾下吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近公司的一台服务器频繁报警，老大让我研究下代码出了什么问题，咋一看才知道代码是用大名鼎鼎的异步框架Vert.x写的，本文记录本菜鸟排查问题的辛酸过程，仅作为以后的一点经验参考。本服务器阿里云双核ECS实例，2G内存，CentOS7系统。</p>\n</blockquote>\n<h2 id=\"1-查看服务器硬盘内存状况\"><a href=\"#1-查看服务器硬盘内存状况\" class=\"headerlink\" title=\"1.查看服务器硬盘内存状况\"></a>1.查看服务器硬盘内存状况</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top #查看服务器内存和硬盘容量</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-261a02461a048ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"top\"><br>看了下参数，以为这些挺重要的，其实发现CPU和Mem都很正常，内存看似要用完了，其实free+buffers+cached大概容量也有900M，完全够用。</p>\n<h2 id=\"2-查看服务器进程的堆栈\"><a href=\"#2-查看服务器进程的堆栈\" class=\"headerlink\" title=\"2.查看服务器进程的堆栈\"></a>2.查看服务器进程的堆栈</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jcmd #查看进程，发现有两个java项目，一个是公司的web项目，另一个是报警的Vertx项目</span><br><span class=\"line\">jinfo [pid] 查看堆内存，发现一个项目的内存参数-Xms1450M，本项目采用的默认配置，暂时看不出分配多少内存</span><br><span class=\"line\">or ps aux | grep tomcat | grep -v grep  查看初始内存使用</span><br><span class=\"line\">jstack [pid] 看栈信息，发现很多歌vert.thread在等待，因为服务器相应缓慢，看了下Log，看到了NPE</span><br></pre></td></tr></table></figure>\n<p>初步分析，NullPointerException导致了服务器相应缓慢。<br>首先调查，为什么会NullPointerException,根据Log很容易找到原因，最后配合前端同事知道新版本的前端请求格式不对造成报错。<br>那么问题来了，报错为什么会导致应用相应缓慢。可能是连接没有释放，或者是持久层插入错误数据报错没有释放连接。</p>\n<h2 id=\"3-查看进程具体内存\"><a href=\"#3-查看进程具体内存\" class=\"headerlink\" title=\"3 查看进程具体内存\"></a>3 查看进程具体内存</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [pid] 查看到初始化的配置</span><br></pre></td></tr></table></figure>\n<p>看到Vertx最大堆内存300M,old区只有50M，这个我很纳闷，照理说默认配置新生区和old区比例是1:2起码也有200M,这样不会oom吗。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap [pid] 查看堆内存各个分区大小,old区使用率90%以上，如果加大Old，如果还不行，肯定是内存泄漏了，就是对象没有释放。</span><br><span class=\"line\">jstat -gcutil [pid] 1s 发现最近发生了6次FGC old区依然降不下去</span><br></pre></td></tr></table></figure></p>\n<p>果然过了一天，log就出现了heap Out Of Memory.</p>\n<h2 id=\"4-尝试增加虚拟机内存分配\"><a href=\"#4-尝试增加虚拟机内存分配\" class=\"headerlink\" title=\"4 尝试增加虚拟机内存分配\"></a>4 尝试增加虚拟机内存分配</h2><p>javaweb项目部署在tomcat下,系统为它分配了1450M的内存，打开tomcat/bin/catalina.sh，修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_OPTS= -Xms1000M -Xmx1000M，这里保证初始分配内存和最大堆内存相同，放置系统调整内存空间产生的消耗。</span><br></pre></td></tr></table></figure></p>\n<p>同时给报警的Vertx项目增加内存，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xms700M -Xmx700M -jar &gt;&gt;t.log 2&gt;&amp;1 &amp; 将标准输出重定向</span><br><span class=\"line\">参数说明如下</span><br><span class=\"line\">-Xms 初始化对内存</span><br><span class=\"line\">-Xmx 最大堆内存</span><br><span class=\"line\">-Xss每个线程内存</span><br><span class=\"line\">-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64</span><br><span class=\"line\">-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4</span><br></pre></td></tr></table></figure></p>\n<p>重启项目后，过一段时间继续查看<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap [pid] 发现堆内存Old区飙升，还是达到了90%</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-查看代码，检查内存泄漏位置\"><a href=\"#5-查看代码，检查内存泄漏位置\" class=\"headerlink\" title=\"5 查看代码，检查内存泄漏位置\"></a>5 查看代码，检查内存泄漏位置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -gcutil [pid] 60000  查看从程序启动到现在进行了多少FGC,查看下old区百分比</span><br><span class=\"line\">jmap -histo:live [pid] &gt;f 打印堆内存存活对象信息</span><br><span class=\"line\">vi f</span><br></pre></td></tr></table></figure>\n<p>通过查看对象信息，从上往下发现有个对象EventItem被实例化了10w+次，这个类里面包含的数组，对象数组响应实例化次数也和其他不在同一数量级。确定是这个问题，回到代码中，我找到了初始化该对象的位置，应该是报错之后，request没有释放，request里面的private对象UploadRequest没有释放，导致错误的EventItem也无法释放。<br>于是我在出错的try.catch语句中直接将整个请求return,因为这些数据其实都是些无效的数据，直接return也可以节约不少开销。</p>\n<h2 id=\"后续观察\"><a href=\"#后续观察\" class=\"headerlink\" title=\"后续观察\"></a>后续观察</h2><p>修改代码后，重新发布，已近观察3天，出错项目的heap的old区使用率终于降下来了，dump了对象信息也没有大量的EventItem，服务器运行终于正常，说明问题解决了。这个过程中经历了一些坑，比如错误的以为是另外一个项目影响造成，浪费了不少时间排查，不过学到不少东西。<br>jinfo/jmap/jstat这些命令是调优时候常用的，dump出文件查看对象信息，jconsole监控本地jvm运行状况，通过修改jvm参数调整服务响应时间等等。<br>代码没有贴出来，具体信息也没细说，因为涉及公司项目还是保密为好，文章就留着以后回顾下吧。</p>\n"},{"title":"SpringBoot实现RESTAPI","date":"2017-10-25T09:28:09.000Z","comments":1,"_content":">如题，本文讲述如何使用Springboot实现restapi,这里感谢开源社区的作者@简单的土豆，和他的源码[https://github.com/Fan4J/spring-boot-api-project-seed.git](https://github.com/Fan4J/spring-boot-api-project-seed.git)\n\n## 1基本配置\n![项目结构.png](http://upload-images.jianshu.io/upload_images/5834071-d8ba22876750345e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n基本配置包括分环境的profile配置， log4j2配置，mybatis的配置，maven依赖的添加，统一结果封装，结果生成器等等。\n这里作者使用了mybatis通用mapper\n```\npublic interface Mapper<T>\n        extends\n        BaseMapper<T>,\n        ConditionMapper<T>,\n        IdsMapper<T>,\n        InsertListMapper<T> {\n}\n```\n通用service接口\n```\npublic interface Service<T> {\n    void save(T model);//持久化\n    void save(List<T> models);//批量持久化\n    void deleteById(Long id);//通过主鍵刪除\n    void deleteByIds(String ids);//批量刪除 eg：ids -> “1,2,3,4”\n    void update(T model);//更新\n    T findById(Long id);//通过ID查找\n    T findBy(String fieldName, Object value) throws TooManyResultsException; //通过Model中某个成员变量名称（非数据表中column的名称）查找,value需符合unique约束\n    List<T> findByIds(String ids);//通过多个ID查找//eg：ids -> “1,2,3,4”\n    List<T> findByCondition(Condition condition);//根据条件查找\n    List<T> findAll();//获取所有\n}\n```\n然后实现abstractService，用通用mapper实现了service,后面的service，只需继承abstractService即可\n```\npublic abstract class AbstractService<T> implements Service<T> {\n\n    @Autowired\n    protected Mapper<T> mapper;\n\n    private Class<T> modelClass;    // 当前泛型真实类型的Class\n\n    public AbstractService() {\n        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();\n        modelClass = (Class<T>) pt.getActualTypeArguments()[0];\n    }\n\n    public void save(T model) {\n        mapper.insertSelective(model);\n    }\n\n    public void save(List<T> models) {\n        mapper.insertList(models);\n    }\n\n    public void deleteById(Long id) {\n        mapper.deleteByPrimaryKey(id);\n    }\n\n    public void deleteByIds(String ids) {\n        mapper.deleteByIds(ids);\n    }\n\n    public void update(T model) {\n        mapper.updateByPrimaryKeySelective(model);\n    }\n\n    public T findById(Long id) {\n        return mapper.selectByPrimaryKey(id);\n    }\n\n    @Override\n    public T findBy(String fieldName, Object value) throws TooManyResultsException {\n        try {\n            T model = modelClass.newInstance();\n            Field field = modelClass.getDeclaredField(fieldName);\n            field.setAccessible(true);\n            field.set(model, value);\n            return mapper.selectOne(model);\n        } catch (ReflectiveOperationException e) {\n            throw new ServiceException(e.getMessage(), e);\n        }\n    }\n\n    public List<T> findByIds(String ids) {\n        return mapper.selectByIds(ids);\n    }\n\n    public List<T> findByCondition(Condition condition) {\n        return mapper.selectByCondition(condition);\n    }\n\n    public List<T> findAll() {\n        return mapper.selectAll();\n    }\n}\n\n```\n## 2.下面看看Controller\n先上代码\n```\n@RestController\npublic class FetchConfigController {\n\n    @Autowired\n    UserInfoService userInfoService;\n\n    @PostMapping(value = \"/add\", consumes = \"application/json\", produces = \"application/json\")\n    public Result add(@RequestBody UserInfo userInfo) {\n        userInfoService.save(userInfo);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/delete\")\n    public Result delete(@RequestParam Long id) {\n        userInfoService.deleteById(id);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/update\")\n    public Result update(@RequestBody UserInfo userInfo) {\n        userInfoService.update(userInfo);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/detail\")\n    public Result detail(@RequestParam Long id) {\n        UserInfo userInfo = userInfoService.findById(id);\n        return ResultCodeGenerator.genSuccessResult(userInfo);\n    }\n\n    @PostMapping(\"/list\")\n    public Result list(@RequestParam(defaultValue = \"0\") Integer page, @RequestParam(defaultValue = \"0\") Integer size) {\n        PageHelper.startPage(page, size);\n        List<UserInfo> list = userInfoService.findAll();\n        PageInfo pageInfo = new PageInfo(list);\n        return ResultCodeGenerator.genSuccessResult(pageInfo);\n    }\n\n}\n```\n1@RestController，可以看到它是@Controller/@ResponseBody的结合体，@ResponseBody这个注解在RESTAPI 中很有意义，它不是将返回资源定位到resouces下面的html/css/js生成视图，而是直接以写入输出流返回给客户端。\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default \"\";\n}\n```\n这里不得不提到HttpMessageConverter，这个转换器顾名思义，是将httprequest输入流读成对象，或者字符串，再返回的时候将对象转换成HttpResponse输出流\n```\npublic interface HttpMessageConverter<T> {\n    boolean canRead(Class<?> var1, MediaType var2);\n\n    boolean canWrite(Class<?> var1, MediaType var2);\n\n    List<MediaType> getSupportedMediaTypes();\n\n    T read(Class<? extends T> var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;\n\n    void write(T var1, MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;\n}\n```\n可以看到它是个泛型的接口，主要的两个方法是read/write canread/write,Spring已经实现了abstractHttpMessageConverter，自己可以继承这个abstract的class，拿来使用。converter用canread/write检查http流的类型，然后返回是true,就用read/write方法去读写。一般都是用别人写好的converter,例如阿里的fastjson的converter，可以用于处理application/json,例如MappingJackson2XmlHttpMessageConverter用于处理application/xml。这些内容可以配在configure文件中\n```\n@Configuration\npublic class WebMvcConfigurer extends WebMvcConfigurerAdapter {\n\n    private static Logger logger = LogManager.getLogger();\n\n    //当前激活的配置文件\n    @Value(\"${spring.profiles.active}\")\n    private String env;\n\n    //使用阿里 FastJson 作为JSON MessageConverter\n    //使用MappingJackson2XmlHttpMessageConverter进行xml的转换\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        FastJsonHttpMessageConverter4 converter = new FastJsonHttpMessageConverter4();\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue,//保留空的字段\n                SerializerFeature.WriteNullStringAsEmpty,//String null -> \"\"\n                SerializerFeature.WriteNullNumberAsZero);//Number null -> 0\n        converter.setFastJsonConfig(config);\n        converter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        MappingJackson2XmlHttpMessageConverter converter1 = new MappingJackson2XmlHttpMessageConverter();\n        converters.add(converter1);\n        converters.add(converter);\n    }\n```\n\n我这里添加了两个converter,分别用来处理json和xml.\n2.@PostMapping其实是@RequestMapping(method = {RequestMethod.POST})的缩写\n3.@RequestParam其实还可以加入default和require的设置\n4.@RequestBody直接把inputstream中的json通过converter读成对象进行处理，和@responsebody对应将对象写成json放入outputstream\n\n## 3.研究下Spring自带的RestTemplate\n通常我们进行http请求是用apache的httpclient，而且功能比较强大，这里spring也集成了自己的rest请求方法\n```\nprivate static ClientHttpRequestFactory getSimpleClientHttpRequestFactory() {\n        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();\n        factory.setReadTimeout(60000);//ms\n        factory.setConnectTimeout(30000);//ms\n        return factory;\n }\n```\nRestTemplate直接new就可以使用了，构造方法里可以注入一个factory用于统一设置一些参数\n```\nprivate static RestTemplate getRestTemplate(ClientHttpRequestFactory factory) {\n        RestTemplate restTemplate = new RestTemplate(factory);\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        StringHttpMessageConverter stringHttpMessageConverter\n                = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        stringHttpMessageConverter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        messageConverters.add(stringHttpMessageConverter);\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new FastJsonHttpMessageConverter4());\n        restTemplate.setMessageConverters(messageConverters);\n        return restTemplate;\n    }\n```\ntemplate里面统一可以注入converter,这里我加入了3个converter，这里注意StringmessageConverter里面默认的字符是ISO-8859-1，所以new一个新的converter并且设置编码防止出错，剩下的就是简单粗暴的直接使用咯\n```\n        RestTemplate restTemplate = getRestTemplate(getSimpleClientHttpRequestFactory());\n        String url = \"http://localhost:7777/dcs/list\";\n//        HttpHeaders headers = new HttpHeaders();\n//        headers.setContentType(MediaType.ALL.APPLICATION_JSON);\n//        UserInfo userInfo = new UserInfo().setUserId((long) 1231).\n//                setUserName(\"test\").setAge(13).setEmail(\"fafa@jancy.com\");\n//        HttpEntity request = new HttpEntity(userInfo, headers);\n//        Result result = restTemplate.postForObject(url, request, Result.class);\n//        System.out.println(JSON.toJSONString(result));\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        MultiValueMap<String, Integer> map = new LinkedMultiValueMap<>();\n        map.add(\"page\", 1);\n        map.add(\"size\", 5);\n        HttpEntity<MultiValueMap<String, Integer>> request = new HttpEntity<>(map, headers);\n        Result result = restTemplate.postForObject(url, request, Result.class);\n        System.out.println(JSON.toJSONString(result));\n```\n根据api的不同，既可以直接传入只要把HttpEntity包装好即可。\n除了写在main函数中，也可以用Spring的注解加载factory/restemplate\n```\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate restTemplate(ClientHttpRequestFactory factory){\n        RestTemplate restTemplate = new RestTemplate(factory);\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        StringHttpMessageConverter stringHttpMessageConverter\n            = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        stringHttpMessageConverter.setDefaultCharset(Charsets.UTF_8);\n        messageConverters.add(stringHttpMessageConverter);\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new FastJsonHttpMessageConverter());\n        restTemplate.setMessageConverters(messageConverters);\n        return restTemplate;\n    }\n\n    @Bean\n    public ClientHttpRequestFactory simpleClientHttpRequestFactory(){\n        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();\n        factory.setReadTimeout(60000);//ms\n        factory.setConnectTimeout(30000);//ms\n        return factory;\n    }\n}\n```\n在其他代码里只用@autowired即可使用\n\n## 4.总结\n以上就是如何用Springboot构建restApi，其实还可以和数据库做很多交互，还有签名认证，session管理等东西，都到后面完善吧。源码地址在最开始就贴了，是个开源的项目，HttpMessageConverter，如何得到json、xml的返回，都需要操作操作。继续努力吧\n[个人博客](https://fan4j.github.io/) 欢迎访问~","source":"_posts/SpringBoot实现REST.md","raw":"---\ntitle: SpringBoot实现RESTAPI\ndate: 2017-10-25 17:28:09\ntags: \n\t- Java\t\n\t- Spring\n\t- Rest\ncomments: true\n---\n>如题，本文讲述如何使用Springboot实现restapi,这里感谢开源社区的作者@简单的土豆，和他的源码[https://github.com/Fan4J/spring-boot-api-project-seed.git](https://github.com/Fan4J/spring-boot-api-project-seed.git)\n\n## 1基本配置\n![项目结构.png](http://upload-images.jianshu.io/upload_images/5834071-d8ba22876750345e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n基本配置包括分环境的profile配置， log4j2配置，mybatis的配置，maven依赖的添加，统一结果封装，结果生成器等等。\n这里作者使用了mybatis通用mapper\n```\npublic interface Mapper<T>\n        extends\n        BaseMapper<T>,\n        ConditionMapper<T>,\n        IdsMapper<T>,\n        InsertListMapper<T> {\n}\n```\n通用service接口\n```\npublic interface Service<T> {\n    void save(T model);//持久化\n    void save(List<T> models);//批量持久化\n    void deleteById(Long id);//通过主鍵刪除\n    void deleteByIds(String ids);//批量刪除 eg：ids -> “1,2,3,4”\n    void update(T model);//更新\n    T findById(Long id);//通过ID查找\n    T findBy(String fieldName, Object value) throws TooManyResultsException; //通过Model中某个成员变量名称（非数据表中column的名称）查找,value需符合unique约束\n    List<T> findByIds(String ids);//通过多个ID查找//eg：ids -> “1,2,3,4”\n    List<T> findByCondition(Condition condition);//根据条件查找\n    List<T> findAll();//获取所有\n}\n```\n然后实现abstractService，用通用mapper实现了service,后面的service，只需继承abstractService即可\n```\npublic abstract class AbstractService<T> implements Service<T> {\n\n    @Autowired\n    protected Mapper<T> mapper;\n\n    private Class<T> modelClass;    // 当前泛型真实类型的Class\n\n    public AbstractService() {\n        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();\n        modelClass = (Class<T>) pt.getActualTypeArguments()[0];\n    }\n\n    public void save(T model) {\n        mapper.insertSelective(model);\n    }\n\n    public void save(List<T> models) {\n        mapper.insertList(models);\n    }\n\n    public void deleteById(Long id) {\n        mapper.deleteByPrimaryKey(id);\n    }\n\n    public void deleteByIds(String ids) {\n        mapper.deleteByIds(ids);\n    }\n\n    public void update(T model) {\n        mapper.updateByPrimaryKeySelective(model);\n    }\n\n    public T findById(Long id) {\n        return mapper.selectByPrimaryKey(id);\n    }\n\n    @Override\n    public T findBy(String fieldName, Object value) throws TooManyResultsException {\n        try {\n            T model = modelClass.newInstance();\n            Field field = modelClass.getDeclaredField(fieldName);\n            field.setAccessible(true);\n            field.set(model, value);\n            return mapper.selectOne(model);\n        } catch (ReflectiveOperationException e) {\n            throw new ServiceException(e.getMessage(), e);\n        }\n    }\n\n    public List<T> findByIds(String ids) {\n        return mapper.selectByIds(ids);\n    }\n\n    public List<T> findByCondition(Condition condition) {\n        return mapper.selectByCondition(condition);\n    }\n\n    public List<T> findAll() {\n        return mapper.selectAll();\n    }\n}\n\n```\n## 2.下面看看Controller\n先上代码\n```\n@RestController\npublic class FetchConfigController {\n\n    @Autowired\n    UserInfoService userInfoService;\n\n    @PostMapping(value = \"/add\", consumes = \"application/json\", produces = \"application/json\")\n    public Result add(@RequestBody UserInfo userInfo) {\n        userInfoService.save(userInfo);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/delete\")\n    public Result delete(@RequestParam Long id) {\n        userInfoService.deleteById(id);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/update\")\n    public Result update(@RequestBody UserInfo userInfo) {\n        userInfoService.update(userInfo);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/detail\")\n    public Result detail(@RequestParam Long id) {\n        UserInfo userInfo = userInfoService.findById(id);\n        return ResultCodeGenerator.genSuccessResult(userInfo);\n    }\n\n    @PostMapping(\"/list\")\n    public Result list(@RequestParam(defaultValue = \"0\") Integer page, @RequestParam(defaultValue = \"0\") Integer size) {\n        PageHelper.startPage(page, size);\n        List<UserInfo> list = userInfoService.findAll();\n        PageInfo pageInfo = new PageInfo(list);\n        return ResultCodeGenerator.genSuccessResult(pageInfo);\n    }\n\n}\n```\n1@RestController，可以看到它是@Controller/@ResponseBody的结合体，@ResponseBody这个注解在RESTAPI 中很有意义，它不是将返回资源定位到resouces下面的html/css/js生成视图，而是直接以写入输出流返回给客户端。\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default \"\";\n}\n```\n这里不得不提到HttpMessageConverter，这个转换器顾名思义，是将httprequest输入流读成对象，或者字符串，再返回的时候将对象转换成HttpResponse输出流\n```\npublic interface HttpMessageConverter<T> {\n    boolean canRead(Class<?> var1, MediaType var2);\n\n    boolean canWrite(Class<?> var1, MediaType var2);\n\n    List<MediaType> getSupportedMediaTypes();\n\n    T read(Class<? extends T> var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;\n\n    void write(T var1, MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;\n}\n```\n可以看到它是个泛型的接口，主要的两个方法是read/write canread/write,Spring已经实现了abstractHttpMessageConverter，自己可以继承这个abstract的class，拿来使用。converter用canread/write检查http流的类型，然后返回是true,就用read/write方法去读写。一般都是用别人写好的converter,例如阿里的fastjson的converter，可以用于处理application/json,例如MappingJackson2XmlHttpMessageConverter用于处理application/xml。这些内容可以配在configure文件中\n```\n@Configuration\npublic class WebMvcConfigurer extends WebMvcConfigurerAdapter {\n\n    private static Logger logger = LogManager.getLogger();\n\n    //当前激活的配置文件\n    @Value(\"${spring.profiles.active}\")\n    private String env;\n\n    //使用阿里 FastJson 作为JSON MessageConverter\n    //使用MappingJackson2XmlHttpMessageConverter进行xml的转换\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        FastJsonHttpMessageConverter4 converter = new FastJsonHttpMessageConverter4();\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue,//保留空的字段\n                SerializerFeature.WriteNullStringAsEmpty,//String null -> \"\"\n                SerializerFeature.WriteNullNumberAsZero);//Number null -> 0\n        converter.setFastJsonConfig(config);\n        converter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        MappingJackson2XmlHttpMessageConverter converter1 = new MappingJackson2XmlHttpMessageConverter();\n        converters.add(converter1);\n        converters.add(converter);\n    }\n```\n\n我这里添加了两个converter,分别用来处理json和xml.\n2.@PostMapping其实是@RequestMapping(method = {RequestMethod.POST})的缩写\n3.@RequestParam其实还可以加入default和require的设置\n4.@RequestBody直接把inputstream中的json通过converter读成对象进行处理，和@responsebody对应将对象写成json放入outputstream\n\n## 3.研究下Spring自带的RestTemplate\n通常我们进行http请求是用apache的httpclient，而且功能比较强大，这里spring也集成了自己的rest请求方法\n```\nprivate static ClientHttpRequestFactory getSimpleClientHttpRequestFactory() {\n        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();\n        factory.setReadTimeout(60000);//ms\n        factory.setConnectTimeout(30000);//ms\n        return factory;\n }\n```\nRestTemplate直接new就可以使用了，构造方法里可以注入一个factory用于统一设置一些参数\n```\nprivate static RestTemplate getRestTemplate(ClientHttpRequestFactory factory) {\n        RestTemplate restTemplate = new RestTemplate(factory);\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        StringHttpMessageConverter stringHttpMessageConverter\n                = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        stringHttpMessageConverter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        messageConverters.add(stringHttpMessageConverter);\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new FastJsonHttpMessageConverter4());\n        restTemplate.setMessageConverters(messageConverters);\n        return restTemplate;\n    }\n```\ntemplate里面统一可以注入converter,这里我加入了3个converter，这里注意StringmessageConverter里面默认的字符是ISO-8859-1，所以new一个新的converter并且设置编码防止出错，剩下的就是简单粗暴的直接使用咯\n```\n        RestTemplate restTemplate = getRestTemplate(getSimpleClientHttpRequestFactory());\n        String url = \"http://localhost:7777/dcs/list\";\n//        HttpHeaders headers = new HttpHeaders();\n//        headers.setContentType(MediaType.ALL.APPLICATION_JSON);\n//        UserInfo userInfo = new UserInfo().setUserId((long) 1231).\n//                setUserName(\"test\").setAge(13).setEmail(\"fafa@jancy.com\");\n//        HttpEntity request = new HttpEntity(userInfo, headers);\n//        Result result = restTemplate.postForObject(url, request, Result.class);\n//        System.out.println(JSON.toJSONString(result));\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        MultiValueMap<String, Integer> map = new LinkedMultiValueMap<>();\n        map.add(\"page\", 1);\n        map.add(\"size\", 5);\n        HttpEntity<MultiValueMap<String, Integer>> request = new HttpEntity<>(map, headers);\n        Result result = restTemplate.postForObject(url, request, Result.class);\n        System.out.println(JSON.toJSONString(result));\n```\n根据api的不同，既可以直接传入只要把HttpEntity包装好即可。\n除了写在main函数中，也可以用Spring的注解加载factory/restemplate\n```\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate restTemplate(ClientHttpRequestFactory factory){\n        RestTemplate restTemplate = new RestTemplate(factory);\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        StringHttpMessageConverter stringHttpMessageConverter\n            = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        stringHttpMessageConverter.setDefaultCharset(Charsets.UTF_8);\n        messageConverters.add(stringHttpMessageConverter);\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new FastJsonHttpMessageConverter());\n        restTemplate.setMessageConverters(messageConverters);\n        return restTemplate;\n    }\n\n    @Bean\n    public ClientHttpRequestFactory simpleClientHttpRequestFactory(){\n        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();\n        factory.setReadTimeout(60000);//ms\n        factory.setConnectTimeout(30000);//ms\n        return factory;\n    }\n}\n```\n在其他代码里只用@autowired即可使用\n\n## 4.总结\n以上就是如何用Springboot构建restApi，其实还可以和数据库做很多交互，还有签名认证，session管理等东西，都到后面完善吧。源码地址在最开始就贴了，是个开源的项目，HttpMessageConverter，如何得到json、xml的返回，都需要操作操作。继续努力吧\n[个人博客](https://fan4j.github.io/) 欢迎访问~","slug":"SpringBoot实现REST","published":1,"updated":"2018-05-29T11:37:20.702Z","layout":"post","photos":[],"link":"","_id":"cjhrnqsse0004jd6i6frzxtv2","content":"<blockquote>\n<p>如题，本文讲述如何使用Springboot实现restapi,这里感谢开源社区的作者@简单的土豆，和他的源码<a href=\"https://github.com/Fan4J/spring-boot-api-project-seed.git\" target=\"_blank\" rel=\"noopener\">https://github.com/Fan4J/spring-boot-api-project-seed.git</a></p>\n</blockquote>\n<h2 id=\"1基本配置\"><a href=\"#1基本配置\" class=\"headerlink\" title=\"1基本配置\"></a>1基本配置</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-d8ba22876750345e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目结构.png\"><br>基本配置包括分环境的profile配置， log4j2配置，mybatis的配置，maven依赖的添加，统一结果封装，结果生成器等等。<br>这里作者使用了mybatis通用mapper<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Mapper&lt;T&gt;</span><br><span class=\"line\">        extends</span><br><span class=\"line\">        BaseMapper&lt;T&gt;,</span><br><span class=\"line\">        ConditionMapper&lt;T&gt;,</span><br><span class=\"line\">        IdsMapper&lt;T&gt;,</span><br><span class=\"line\">        InsertListMapper&lt;T&gt; &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通用service接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Service&lt;T&gt; &#123;</span><br><span class=\"line\">    void save(T model);//持久化</span><br><span class=\"line\">    void save(List&lt;T&gt; models);//批量持久化</span><br><span class=\"line\">    void deleteById(Long id);//通过主鍵刪除</span><br><span class=\"line\">    void deleteByIds(String ids);//批量刪除 eg：ids -&gt; “1,2,3,4”</span><br><span class=\"line\">    void update(T model);//更新</span><br><span class=\"line\">    T findById(Long id);//通过ID查找</span><br><span class=\"line\">    T findBy(String fieldName, Object value) throws TooManyResultsException; //通过Model中某个成员变量名称（非数据表中column的名称）查找,value需符合unique约束</span><br><span class=\"line\">    List&lt;T&gt; findByIds(String ids);//通过多个ID查找//eg：ids -&gt; “1,2,3,4”</span><br><span class=\"line\">    List&lt;T&gt; findByCondition(Condition condition);//根据条件查找</span><br><span class=\"line\">    List&lt;T&gt; findAll();//获取所有</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后实现abstractService，用通用mapper实现了service,后面的service，只需继承abstractService即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractService&lt;T&gt; implements Service&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    protected Mapper&lt;T&gt; mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Class&lt;T&gt; modelClass;    // 当前泛型真实类型的Class</span><br><span class=\"line\"></span><br><span class=\"line\">    public AbstractService() &#123;</span><br><span class=\"line\">        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();</span><br><span class=\"line\">        modelClass = (Class&lt;T&gt;) pt.getActualTypeArguments()[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void save(T model) &#123;</span><br><span class=\"line\">        mapper.insertSelective(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void save(List&lt;T&gt; models) &#123;</span><br><span class=\"line\">        mapper.insertList(models);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void deleteById(Long id) &#123;</span><br><span class=\"line\">        mapper.deleteByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void deleteByIds(String ids) &#123;</span><br><span class=\"line\">        mapper.deleteByIds(ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void update(T model) &#123;</span><br><span class=\"line\">        mapper.updateByPrimaryKeySelective(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T findById(Long id) &#123;</span><br><span class=\"line\">        return mapper.selectByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public T findBy(String fieldName, Object value) throws TooManyResultsException &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            T model = modelClass.newInstance();</span><br><span class=\"line\">            Field field = modelClass.getDeclaredField(fieldName);</span><br><span class=\"line\">            field.setAccessible(true);</span><br><span class=\"line\">            field.set(model, value);</span><br><span class=\"line\">            return mapper.selectOne(model);</span><br><span class=\"line\">        &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class=\"line\">            throw new ServiceException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findByIds(String ids) &#123;</span><br><span class=\"line\">        return mapper.selectByIds(ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findByCondition(Condition condition) &#123;</span><br><span class=\"line\">        return mapper.selectByCondition(condition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findAll() &#123;</span><br><span class=\"line\">        return mapper.selectAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-下面看看Controller\"><a href=\"#2-下面看看Controller\" class=\"headerlink\" title=\"2.下面看看Controller\"></a>2.下面看看Controller</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class FetchConfigController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    UserInfoService userInfoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(value = &quot;/add&quot;, consumes = &quot;application/json&quot;, produces = &quot;application/json&quot;)</span><br><span class=\"line\">    public Result add(@RequestBody UserInfo userInfo) &#123;</span><br><span class=\"line\">        userInfoService.save(userInfo);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/delete&quot;)</span><br><span class=\"line\">    public Result delete(@RequestParam Long id) &#123;</span><br><span class=\"line\">        userInfoService.deleteById(id);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/update&quot;)</span><br><span class=\"line\">    public Result update(@RequestBody UserInfo userInfo) &#123;</span><br><span class=\"line\">        userInfoService.update(userInfo);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/detail&quot;)</span><br><span class=\"line\">    public Result detail(@RequestParam Long id) &#123;</span><br><span class=\"line\">        UserInfo userInfo = userInfoService.findById(id);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult(userInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/list&quot;)</span><br><span class=\"line\">    public Result list(@RequestParam(defaultValue = &quot;0&quot;) Integer page, @RequestParam(defaultValue = &quot;0&quot;) Integer size) &#123;</span><br><span class=\"line\">        PageHelper.startPage(page, size);</span><br><span class=\"line\">        List&lt;UserInfo&gt; list = userInfoService.findAll();</span><br><span class=\"line\">        PageInfo pageInfo = new PageInfo(list);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult(pageInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1@RestController，可以看到它是@Controller/@ResponseBody的结合体，@ResponseBody这个注解在RESTAPI 中很有意义，它不是将返回资源定位到resouces下面的html/css/js生成视图，而是直接以写入输出流返回给客户端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Controller</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public @interface RestController &#123;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里不得不提到HttpMessageConverter，这个转换器顾名思义，是将httprequest输入流读成对象，或者字符串，再返回的时候将对象转换成HttpResponse输出流<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface HttpMessageConverter&lt;T&gt; &#123;</span><br><span class=\"line\">    boolean canRead(Class&lt;?&gt; var1, MediaType var2);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean canWrite(Class&lt;?&gt; var1, MediaType var2);</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;MediaType&gt; getSupportedMediaTypes();</span><br><span class=\"line\"></span><br><span class=\"line\">    T read(Class&lt;? extends T&gt; var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;</span><br><span class=\"line\"></span><br><span class=\"line\">    void write(T var1, MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它是个泛型的接口，主要的两个方法是read/write canread/write,Spring已经实现了abstractHttpMessageConverter，自己可以继承这个abstract的class，拿来使用。converter用canread/write检查http流的类型，然后返回是true,就用read/write方法去读写。一般都是用别人写好的converter,例如阿里的fastjson的converter，可以用于处理application/json,例如MappingJackson2XmlHttpMessageConverter用于处理application/xml。这些内容可以配在configure文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class WebMvcConfigurer extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Logger logger = LogManager.getLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    //当前激活的配置文件</span><br><span class=\"line\">    @Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span><br><span class=\"line\">    private String env;</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用阿里 FastJson 作为JSON MessageConverter</span><br><span class=\"line\">    //使用MappingJackson2XmlHttpMessageConverter进行xml的转换</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class=\"line\">        FastJsonHttpMessageConverter4 converter = new FastJsonHttpMessageConverter4();</span><br><span class=\"line\">        FastJsonConfig config = new FastJsonConfig();</span><br><span class=\"line\">        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue,//保留空的字段</span><br><span class=\"line\">                SerializerFeature.WriteNullStringAsEmpty,//String null -&gt; &quot;&quot;</span><br><span class=\"line\">                SerializerFeature.WriteNullNumberAsZero);//Number null -&gt; 0</span><br><span class=\"line\">        converter.setFastJsonConfig(config);</span><br><span class=\"line\">        converter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class=\"line\">        MappingJackson2XmlHttpMessageConverter converter1 = new MappingJackson2XmlHttpMessageConverter();</span><br><span class=\"line\">        converters.add(converter1);</span><br><span class=\"line\">        converters.add(converter);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我这里添加了两个converter,分别用来处理json和xml.<br>2.@PostMapping其实是@RequestMapping(method = {RequestMethod.POST})的缩写<br>3.@RequestParam其实还可以加入default和require的设置<br>4.@RequestBody直接把inputstream中的json通过converter读成对象进行处理，和@responsebody对应将对象写成json放入outputstream</p>\n<h2 id=\"3-研究下Spring自带的RestTemplate\"><a href=\"#3-研究下Spring自带的RestTemplate\" class=\"headerlink\" title=\"3.研究下Spring自带的RestTemplate\"></a>3.研究下Spring自带的RestTemplate</h2><p>通常我们进行http请求是用apache的httpclient，而且功能比较强大，这里spring也集成了自己的rest请求方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static ClientHttpRequestFactory getSimpleClientHttpRequestFactory() &#123;</span><br><span class=\"line\">        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();</span><br><span class=\"line\">        factory.setReadTimeout(60000);//ms</span><br><span class=\"line\">        factory.setConnectTimeout(30000);//ms</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>RestTemplate直接new就可以使用了，构造方法里可以注入一个factory用于统一设置一些参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static RestTemplate getRestTemplate(ClientHttpRequestFactory factory) &#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate(factory);</span><br><span class=\"line\">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        StringHttpMessageConverter stringHttpMessageConverter</span><br><span class=\"line\">                = new StringHttpMessageConverter();</span><br><span class=\"line\">        stringHttpMessageConverter.setWriteAcceptCharset(false);</span><br><span class=\"line\">        stringHttpMessageConverter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class=\"line\">        messageConverters.add(stringHttpMessageConverter);</span><br><span class=\"line\">        messageConverters.add(new FormHttpMessageConverter());</span><br><span class=\"line\">        messageConverters.add(new FastJsonHttpMessageConverter4());</span><br><span class=\"line\">        restTemplate.setMessageConverters(messageConverters);</span><br><span class=\"line\">        return restTemplate;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>template里面统一可以注入converter,这里我加入了3个converter，这里注意StringmessageConverter里面默认的字符是ISO-8859-1，所以new一个新的converter并且设置编码防止出错，剩下的就是简单粗暴的直接使用咯<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        RestTemplate restTemplate = getRestTemplate(getSimpleClientHttpRequestFactory());</span><br><span class=\"line\">        String url = &quot;http://localhost:7777/dcs/list&quot;;</span><br><span class=\"line\">//        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">//        headers.setContentType(MediaType.ALL.APPLICATION_JSON);</span><br><span class=\"line\">//        UserInfo userInfo = new UserInfo().setUserId((long) 1231).</span><br><span class=\"line\">//                setUserName(&quot;test&quot;).setAge(13).setEmail(&quot;fafa@jancy.com&quot;);</span><br><span class=\"line\">//        HttpEntity request = new HttpEntity(userInfo, headers);</span><br><span class=\"line\">//        Result result = restTemplate.postForObject(url, request, Result.class);</span><br><span class=\"line\">//        System.out.println(JSON.toJSONString(result));</span><br><span class=\"line\">        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">        headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class=\"line\">        MultiValueMap&lt;String, Integer&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">        map.add(&quot;page&quot;, 1);</span><br><span class=\"line\">        map.add(&quot;size&quot;, 5);</span><br><span class=\"line\">        HttpEntity&lt;MultiValueMap&lt;String, Integer&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);</span><br><span class=\"line\">        Result result = restTemplate.postForObject(url, request, Result.class);</span><br><span class=\"line\">        System.out.println(JSON.toJSONString(result));</span><br></pre></td></tr></table></figure></p>\n<p>根据api的不同，既可以直接传入只要把HttpEntity包装好即可。<br>除了写在main函数中，也可以用Spring的注解加载factory/restemplate<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RestTemplateConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RestTemplate restTemplate(ClientHttpRequestFactory factory)&#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate(factory);</span><br><span class=\"line\">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        StringHttpMessageConverter stringHttpMessageConverter</span><br><span class=\"line\">            = new StringHttpMessageConverter();</span><br><span class=\"line\">        stringHttpMessageConverter.setWriteAcceptCharset(false);</span><br><span class=\"line\">        stringHttpMessageConverter.setDefaultCharset(Charsets.UTF_8);</span><br><span class=\"line\">        messageConverters.add(stringHttpMessageConverter);</span><br><span class=\"line\">        messageConverters.add(new FormHttpMessageConverter());</span><br><span class=\"line\">        messageConverters.add(new FastJsonHttpMessageConverter());</span><br><span class=\"line\">        restTemplate.setMessageConverters(messageConverters);</span><br><span class=\"line\">        return restTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123;</span><br><span class=\"line\">        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();</span><br><span class=\"line\">        factory.setReadTimeout(60000);//ms</span><br><span class=\"line\">        factory.setConnectTimeout(30000);//ms</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在其他代码里只用@autowired即可使用</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h2><p>以上就是如何用Springboot构建restApi，其实还可以和数据库做很多交互，还有签名认证，session管理等东西，都到后面完善吧。源码地址在最开始就贴了，是个开源的项目，HttpMessageConverter，如何得到json、xml的返回，都需要操作操作。继续努力吧<br><a href=\"https://fan4j.github.io/\">个人博客</a> 欢迎访问~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>如题，本文讲述如何使用Springboot实现restapi,这里感谢开源社区的作者@简单的土豆，和他的源码<a href=\"https://github.com/Fan4J/spring-boot-api-project-seed.git\" target=\"_blank\" rel=\"noopener\">https://github.com/Fan4J/spring-boot-api-project-seed.git</a></p>\n</blockquote>\n<h2 id=\"1基本配置\"><a href=\"#1基本配置\" class=\"headerlink\" title=\"1基本配置\"></a>1基本配置</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-d8ba22876750345e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目结构.png\"><br>基本配置包括分环境的profile配置， log4j2配置，mybatis的配置，maven依赖的添加，统一结果封装，结果生成器等等。<br>这里作者使用了mybatis通用mapper<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Mapper&lt;T&gt;</span><br><span class=\"line\">        extends</span><br><span class=\"line\">        BaseMapper&lt;T&gt;,</span><br><span class=\"line\">        ConditionMapper&lt;T&gt;,</span><br><span class=\"line\">        IdsMapper&lt;T&gt;,</span><br><span class=\"line\">        InsertListMapper&lt;T&gt; &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通用service接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Service&lt;T&gt; &#123;</span><br><span class=\"line\">    void save(T model);//持久化</span><br><span class=\"line\">    void save(List&lt;T&gt; models);//批量持久化</span><br><span class=\"line\">    void deleteById(Long id);//通过主鍵刪除</span><br><span class=\"line\">    void deleteByIds(String ids);//批量刪除 eg：ids -&gt; “1,2,3,4”</span><br><span class=\"line\">    void update(T model);//更新</span><br><span class=\"line\">    T findById(Long id);//通过ID查找</span><br><span class=\"line\">    T findBy(String fieldName, Object value) throws TooManyResultsException; //通过Model中某个成员变量名称（非数据表中column的名称）查找,value需符合unique约束</span><br><span class=\"line\">    List&lt;T&gt; findByIds(String ids);//通过多个ID查找//eg：ids -&gt; “1,2,3,4”</span><br><span class=\"line\">    List&lt;T&gt; findByCondition(Condition condition);//根据条件查找</span><br><span class=\"line\">    List&lt;T&gt; findAll();//获取所有</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后实现abstractService，用通用mapper实现了service,后面的service，只需继承abstractService即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractService&lt;T&gt; implements Service&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    protected Mapper&lt;T&gt; mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Class&lt;T&gt; modelClass;    // 当前泛型真实类型的Class</span><br><span class=\"line\"></span><br><span class=\"line\">    public AbstractService() &#123;</span><br><span class=\"line\">        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();</span><br><span class=\"line\">        modelClass = (Class&lt;T&gt;) pt.getActualTypeArguments()[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void save(T model) &#123;</span><br><span class=\"line\">        mapper.insertSelective(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void save(List&lt;T&gt; models) &#123;</span><br><span class=\"line\">        mapper.insertList(models);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void deleteById(Long id) &#123;</span><br><span class=\"line\">        mapper.deleteByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void deleteByIds(String ids) &#123;</span><br><span class=\"line\">        mapper.deleteByIds(ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void update(T model) &#123;</span><br><span class=\"line\">        mapper.updateByPrimaryKeySelective(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T findById(Long id) &#123;</span><br><span class=\"line\">        return mapper.selectByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public T findBy(String fieldName, Object value) throws TooManyResultsException &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            T model = modelClass.newInstance();</span><br><span class=\"line\">            Field field = modelClass.getDeclaredField(fieldName);</span><br><span class=\"line\">            field.setAccessible(true);</span><br><span class=\"line\">            field.set(model, value);</span><br><span class=\"line\">            return mapper.selectOne(model);</span><br><span class=\"line\">        &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class=\"line\">            throw new ServiceException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findByIds(String ids) &#123;</span><br><span class=\"line\">        return mapper.selectByIds(ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findByCondition(Condition condition) &#123;</span><br><span class=\"line\">        return mapper.selectByCondition(condition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findAll() &#123;</span><br><span class=\"line\">        return mapper.selectAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-下面看看Controller\"><a href=\"#2-下面看看Controller\" class=\"headerlink\" title=\"2.下面看看Controller\"></a>2.下面看看Controller</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class FetchConfigController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    UserInfoService userInfoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(value = &quot;/add&quot;, consumes = &quot;application/json&quot;, produces = &quot;application/json&quot;)</span><br><span class=\"line\">    public Result add(@RequestBody UserInfo userInfo) &#123;</span><br><span class=\"line\">        userInfoService.save(userInfo);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/delete&quot;)</span><br><span class=\"line\">    public Result delete(@RequestParam Long id) &#123;</span><br><span class=\"line\">        userInfoService.deleteById(id);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/update&quot;)</span><br><span class=\"line\">    public Result update(@RequestBody UserInfo userInfo) &#123;</span><br><span class=\"line\">        userInfoService.update(userInfo);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/detail&quot;)</span><br><span class=\"line\">    public Result detail(@RequestParam Long id) &#123;</span><br><span class=\"line\">        UserInfo userInfo = userInfoService.findById(id);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult(userInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/list&quot;)</span><br><span class=\"line\">    public Result list(@RequestParam(defaultValue = &quot;0&quot;) Integer page, @RequestParam(defaultValue = &quot;0&quot;) Integer size) &#123;</span><br><span class=\"line\">        PageHelper.startPage(page, size);</span><br><span class=\"line\">        List&lt;UserInfo&gt; list = userInfoService.findAll();</span><br><span class=\"line\">        PageInfo pageInfo = new PageInfo(list);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult(pageInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1@RestController，可以看到它是@Controller/@ResponseBody的结合体，@ResponseBody这个注解在RESTAPI 中很有意义，它不是将返回资源定位到resouces下面的html/css/js生成视图，而是直接以写入输出流返回给客户端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Controller</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public @interface RestController &#123;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里不得不提到HttpMessageConverter，这个转换器顾名思义，是将httprequest输入流读成对象，或者字符串，再返回的时候将对象转换成HttpResponse输出流<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface HttpMessageConverter&lt;T&gt; &#123;</span><br><span class=\"line\">    boolean canRead(Class&lt;?&gt; var1, MediaType var2);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean canWrite(Class&lt;?&gt; var1, MediaType var2);</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;MediaType&gt; getSupportedMediaTypes();</span><br><span class=\"line\"></span><br><span class=\"line\">    T read(Class&lt;? extends T&gt; var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;</span><br><span class=\"line\"></span><br><span class=\"line\">    void write(T var1, MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它是个泛型的接口，主要的两个方法是read/write canread/write,Spring已经实现了abstractHttpMessageConverter，自己可以继承这个abstract的class，拿来使用。converter用canread/write检查http流的类型，然后返回是true,就用read/write方法去读写。一般都是用别人写好的converter,例如阿里的fastjson的converter，可以用于处理application/json,例如MappingJackson2XmlHttpMessageConverter用于处理application/xml。这些内容可以配在configure文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class WebMvcConfigurer extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Logger logger = LogManager.getLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    //当前激活的配置文件</span><br><span class=\"line\">    @Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span><br><span class=\"line\">    private String env;</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用阿里 FastJson 作为JSON MessageConverter</span><br><span class=\"line\">    //使用MappingJackson2XmlHttpMessageConverter进行xml的转换</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class=\"line\">        FastJsonHttpMessageConverter4 converter = new FastJsonHttpMessageConverter4();</span><br><span class=\"line\">        FastJsonConfig config = new FastJsonConfig();</span><br><span class=\"line\">        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue,//保留空的字段</span><br><span class=\"line\">                SerializerFeature.WriteNullStringAsEmpty,//String null -&gt; &quot;&quot;</span><br><span class=\"line\">                SerializerFeature.WriteNullNumberAsZero);//Number null -&gt; 0</span><br><span class=\"line\">        converter.setFastJsonConfig(config);</span><br><span class=\"line\">        converter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class=\"line\">        MappingJackson2XmlHttpMessageConverter converter1 = new MappingJackson2XmlHttpMessageConverter();</span><br><span class=\"line\">        converters.add(converter1);</span><br><span class=\"line\">        converters.add(converter);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我这里添加了两个converter,分别用来处理json和xml.<br>2.@PostMapping其实是@RequestMapping(method = {RequestMethod.POST})的缩写<br>3.@RequestParam其实还可以加入default和require的设置<br>4.@RequestBody直接把inputstream中的json通过converter读成对象进行处理，和@responsebody对应将对象写成json放入outputstream</p>\n<h2 id=\"3-研究下Spring自带的RestTemplate\"><a href=\"#3-研究下Spring自带的RestTemplate\" class=\"headerlink\" title=\"3.研究下Spring自带的RestTemplate\"></a>3.研究下Spring自带的RestTemplate</h2><p>通常我们进行http请求是用apache的httpclient，而且功能比较强大，这里spring也集成了自己的rest请求方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static ClientHttpRequestFactory getSimpleClientHttpRequestFactory() &#123;</span><br><span class=\"line\">        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();</span><br><span class=\"line\">        factory.setReadTimeout(60000);//ms</span><br><span class=\"line\">        factory.setConnectTimeout(30000);//ms</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>RestTemplate直接new就可以使用了，构造方法里可以注入一个factory用于统一设置一些参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static RestTemplate getRestTemplate(ClientHttpRequestFactory factory) &#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate(factory);</span><br><span class=\"line\">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        StringHttpMessageConverter stringHttpMessageConverter</span><br><span class=\"line\">                = new StringHttpMessageConverter();</span><br><span class=\"line\">        stringHttpMessageConverter.setWriteAcceptCharset(false);</span><br><span class=\"line\">        stringHttpMessageConverter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class=\"line\">        messageConverters.add(stringHttpMessageConverter);</span><br><span class=\"line\">        messageConverters.add(new FormHttpMessageConverter());</span><br><span class=\"line\">        messageConverters.add(new FastJsonHttpMessageConverter4());</span><br><span class=\"line\">        restTemplate.setMessageConverters(messageConverters);</span><br><span class=\"line\">        return restTemplate;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>template里面统一可以注入converter,这里我加入了3个converter，这里注意StringmessageConverter里面默认的字符是ISO-8859-1，所以new一个新的converter并且设置编码防止出错，剩下的就是简单粗暴的直接使用咯<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        RestTemplate restTemplate = getRestTemplate(getSimpleClientHttpRequestFactory());</span><br><span class=\"line\">        String url = &quot;http://localhost:7777/dcs/list&quot;;</span><br><span class=\"line\">//        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">//        headers.setContentType(MediaType.ALL.APPLICATION_JSON);</span><br><span class=\"line\">//        UserInfo userInfo = new UserInfo().setUserId((long) 1231).</span><br><span class=\"line\">//                setUserName(&quot;test&quot;).setAge(13).setEmail(&quot;fafa@jancy.com&quot;);</span><br><span class=\"line\">//        HttpEntity request = new HttpEntity(userInfo, headers);</span><br><span class=\"line\">//        Result result = restTemplate.postForObject(url, request, Result.class);</span><br><span class=\"line\">//        System.out.println(JSON.toJSONString(result));</span><br><span class=\"line\">        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">        headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class=\"line\">        MultiValueMap&lt;String, Integer&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">        map.add(&quot;page&quot;, 1);</span><br><span class=\"line\">        map.add(&quot;size&quot;, 5);</span><br><span class=\"line\">        HttpEntity&lt;MultiValueMap&lt;String, Integer&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);</span><br><span class=\"line\">        Result result = restTemplate.postForObject(url, request, Result.class);</span><br><span class=\"line\">        System.out.println(JSON.toJSONString(result));</span><br></pre></td></tr></table></figure></p>\n<p>根据api的不同，既可以直接传入只要把HttpEntity包装好即可。<br>除了写在main函数中，也可以用Spring的注解加载factory/restemplate<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RestTemplateConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RestTemplate restTemplate(ClientHttpRequestFactory factory)&#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate(factory);</span><br><span class=\"line\">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        StringHttpMessageConverter stringHttpMessageConverter</span><br><span class=\"line\">            = new StringHttpMessageConverter();</span><br><span class=\"line\">        stringHttpMessageConverter.setWriteAcceptCharset(false);</span><br><span class=\"line\">        stringHttpMessageConverter.setDefaultCharset(Charsets.UTF_8);</span><br><span class=\"line\">        messageConverters.add(stringHttpMessageConverter);</span><br><span class=\"line\">        messageConverters.add(new FormHttpMessageConverter());</span><br><span class=\"line\">        messageConverters.add(new FastJsonHttpMessageConverter());</span><br><span class=\"line\">        restTemplate.setMessageConverters(messageConverters);</span><br><span class=\"line\">        return restTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123;</span><br><span class=\"line\">        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();</span><br><span class=\"line\">        factory.setReadTimeout(60000);//ms</span><br><span class=\"line\">        factory.setConnectTimeout(30000);//ms</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在其他代码里只用@autowired即可使用</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h2><p>以上就是如何用Springboot构建restApi，其实还可以和数据库做很多交互，还有签名认证，session管理等东西，都到后面完善吧。源码地址在最开始就贴了，是个开源的项目，HttpMessageConverter，如何得到json、xml的返回，都需要操作操作。继续努力吧<br><a href=\"https://fan4j.github.io/\">个人博客</a> 欢迎访问~</p>\n"},{"title":"用GithubPages+Hexo搭建漂亮的博客","date":"2017-07-25T01:04:14.000Z","_content":">一直以来都想自己搭建博客，作为个人生活和技术的记录，终于在前几天开始动手，一天多时间搭建了自己的个人博客，搭建方式：github+hexo（注：没有绑定个人域名，直接通过github提供的个性链接访问），这种方式可能会在速度上由于github本身的一些原因受到影响，存储空间上其实github没有什么限制，大可放心使用。\n本文主要记录搭建的过程以及遇到的一些坑，仅供大家参考。[浏览博客](https://fan4j.github.io/)\n\n## 1.准备Github,git,nodejs\n第一步，注册github账号，安装git,nodejs\ngithub地址:https://github.com/\ngit下载地址:https://git-scm.com/downloads\nnodejs下载地址:http://nodejs.cn/ \nnodejs的学习可以参考官方文档:http://nodejs.cn/api/\ngit如果不会建议先看廖雪峰的git教程:[点击链接](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n一切就绪后可以在存放代码的目录下打开git bash,确认是否安装成功\n```\ngit\nnode -v\nnpm -v  //最新版的nodejs已经集成了npm包\n```\n## 2.初始化hexo\n依次进行安装hexo,查看是否安装成功，初始化博客，部署，如下\n```\nhexo init hexo  //初始化目录\ncd hexo  //进入目录\nhexo generate  //生成html    \nhexo server  //运行本地服务\n```\n在本地部署完成之后，可以在\nhttp://localhost:4000/\n查看部署效果，目录结构如下：\n```\n├── .deploy       //需要部署的文件\n├── node_modules  //Hexo插件\n├── public        //生成的静态网页文件\n├── scaffolds     //模板\n├── source        //博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里\n|   ├── _drafts   //草稿\n|   └── _posts    //文章\n├── themes        //主题\n├── _config.yml   //全局配置文件\n└── package.json\n```\n## 3.修改_config.yml进行格式修改\n主要配置如下，可以用于参考，需要注意的是yml格式非常严格，冒号后面需要加空格，后面jsContent是为了yilia标签库特效准备的\n```\n# Site\ntitle: 重塑自我\nsubtitle: 当你低头的瞬间，才发现脚下的路\ndescription: 当你低头的瞬间，才发现脚下的路\nauthor: Fan4j\nlanguage: zh-Hans\ntimezone: Asia/Shanghai\n\ndeploy:\n  type: git\n  repo: git@github.com:Fan4J/fan4j.github.io.git\n  branch: master\n  \njsonContent:\n    meta: false\n    pages: false\n    posts:\n      title: true\n      date: true\n      path: true\n      text: false\n      raw: false\n      content: false\n      slug: false\n      updated: false\n      comments: false\n      link: false\n      permalink: false\n      excerpt: false\n      categories: false\n      tags: true\n```\n## 4.修改主题\n进入主题目录下，从github上找自己喜欢的好看的hexo主题，并下载。\nhexo主题地址:https://hexo.io/themes/\n点击到相应的github的主页，找到项目的地址，克隆到本地，比如我的博客使用的很受欢迎的yilia主题，如下\n```\ncd hexo\ncd themes //cd到themes目录下\ngit clone https://github.com/litten/hexo-theme-yilia.git yilia //下载到yilia文件夹\n```\n主题的目录结构如下\n```\n├── languages       //主题的语言包\n├── layout  //主题样式\n├── source       // 资源文件目录，例如图片\n├── source-src     //\n├── _config.yml   //配置文件\n└── package.json\n```\n主要修改在于_config.yml配置\n主要配置节选如下\n```\n# Header\n\nmenu:\n  主页: /\n  随笔: /tags/随笔/\n  技术: /tags/技术/\n  \n# SubNav\nsubnav:\n  github: \"https://github.com/Fan4J\"\n  weibo: \"http://weibo.com/2179165162/profile?topnav=1&wvr=6\"\n  #rss: \"#\"\n  zhihu: \"https://www.zhihu.com/people/storm-spirit/activities\"\n  #qq: \"#\"\n  #weixin: \"#\"\n  jianshu: \"http://www.jianshu.com/u/c4f8f0c4a19f\"\n  #douban: \"#\"\n  #segmentfault: \"#\"\n  #bilibili: \"#\"\n  #acfun: \"#\"\n  #mail: \"fspirit@yeah.net\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\n# 打赏\n# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏\nreward_type: 2\n# 打赏wording\nreward_wording: '多谢支持,一起努力~！'\n# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg\nalipay: /img/payali.jpg\n# 微信二维码图片地址\nweixin: /img/paywechat.jpg\n\n\nsmart_menu:\n  innerArchive: '所有文章'\n  friends: '友链'\n  aboutme: '关于我'\n\nfriends:\n  w3school: http://www.w3school.com.cn/\n  hexo: https://hexo.io/\n  hexo-theme-yilia: https://github.com/litten/hexo-theme-yilia/\n  \n\naboutme: 为了美好生活而拼命努力的普通人\n```\n添加头像既可以用本地的资源路径，记得是theme文件夹下的路径，例如我的图片放在theme/img/目录下\n```\navatar: /img/head.jpg\n```\n打赏的图片同理\n同时对于标签的js-content，需要安装一个包才可不出错，记着是在hexo目录下操作\n```\ncd hexo\nnpm i hexo-generator-json-content --save\n```\n## 5.绑定Github并部署\nGithubPages是指特定命名方式的respository: namespace.github.io,比如我的就是fan4j.github.io\n这样命名的仓库会被自动解析为githubpage,只需在hexo的全局配置文件中正确配置，即可简单部署\n```\nnpm install hexo-deployer-git --save\nnpm deploy \n```\n## 6.发布新文章\n以上内容弄好以后，发布新文章就很轻松了\n```\ncd hexo\nhexo new \"posttitle\"  //会在hexo/source/_posts目录下出现新的文章\n```\n打开文章，添加内容，修改配置，通常打开markdown文件可看到文件头，可以添加相应的文章标签，\n```\ntitle: 用GithubPages+Hexo搭建漂亮的博客\ndate: 2017-07-25 09:04:14\ntags: \n\t- 技术\n\t- 博客\n```\ntags可以继续添加，修改完成后即可开始部署到github服务器\n```\nhexo generate \nhexo deploy\n```\n部署完成，以后用这种方法部署即可\nhexo现在也支持简写，构建过程更加简易\n```\nhexo g == hexo generate\nhexo d == hexo deploy\nhexo s == hexo server\nhexo n == hexo new\n```\n## 7.代码保存，其他配置\n这时打开github可以看到仓库中已经是前端页面的代码，说明部署完毕，访问地址即可-> https://fan4j.github.io/\n同时可以将部署内容保存到新的respository中，可以在多个电脑上进行新文章的发布部署。\n## 8.结束语\n部署结束，中间可能遇到些坑，浪费了些时间，但是都还是可以通过网上搜索获取答案，总体还是觉得很值的，最后套用某人的话，希望不是三分钟热度，一定要把这个博客坚持下去~","source":"_posts/how-to-build-this-blog.md","raw":"---\ntitle: 用GithubPages+Hexo搭建漂亮的博客\ndate: 2017-07-25 09:04:14\ntags: \n\t- 技术\n\t- 博客\n\n---\n>一直以来都想自己搭建博客，作为个人生活和技术的记录，终于在前几天开始动手，一天多时间搭建了自己的个人博客，搭建方式：github+hexo（注：没有绑定个人域名，直接通过github提供的个性链接访问），这种方式可能会在速度上由于github本身的一些原因受到影响，存储空间上其实github没有什么限制，大可放心使用。\n本文主要记录搭建的过程以及遇到的一些坑，仅供大家参考。[浏览博客](https://fan4j.github.io/)\n\n## 1.准备Github,git,nodejs\n第一步，注册github账号，安装git,nodejs\ngithub地址:https://github.com/\ngit下载地址:https://git-scm.com/downloads\nnodejs下载地址:http://nodejs.cn/ \nnodejs的学习可以参考官方文档:http://nodejs.cn/api/\ngit如果不会建议先看廖雪峰的git教程:[点击链接](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n一切就绪后可以在存放代码的目录下打开git bash,确认是否安装成功\n```\ngit\nnode -v\nnpm -v  //最新版的nodejs已经集成了npm包\n```\n## 2.初始化hexo\n依次进行安装hexo,查看是否安装成功，初始化博客，部署，如下\n```\nhexo init hexo  //初始化目录\ncd hexo  //进入目录\nhexo generate  //生成html    \nhexo server  //运行本地服务\n```\n在本地部署完成之后，可以在\nhttp://localhost:4000/\n查看部署效果，目录结构如下：\n```\n├── .deploy       //需要部署的文件\n├── node_modules  //Hexo插件\n├── public        //生成的静态网页文件\n├── scaffolds     //模板\n├── source        //博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里\n|   ├── _drafts   //草稿\n|   └── _posts    //文章\n├── themes        //主题\n├── _config.yml   //全局配置文件\n└── package.json\n```\n## 3.修改_config.yml进行格式修改\n主要配置如下，可以用于参考，需要注意的是yml格式非常严格，冒号后面需要加空格，后面jsContent是为了yilia标签库特效准备的\n```\n# Site\ntitle: 重塑自我\nsubtitle: 当你低头的瞬间，才发现脚下的路\ndescription: 当你低头的瞬间，才发现脚下的路\nauthor: Fan4j\nlanguage: zh-Hans\ntimezone: Asia/Shanghai\n\ndeploy:\n  type: git\n  repo: git@github.com:Fan4J/fan4j.github.io.git\n  branch: master\n  \njsonContent:\n    meta: false\n    pages: false\n    posts:\n      title: true\n      date: true\n      path: true\n      text: false\n      raw: false\n      content: false\n      slug: false\n      updated: false\n      comments: false\n      link: false\n      permalink: false\n      excerpt: false\n      categories: false\n      tags: true\n```\n## 4.修改主题\n进入主题目录下，从github上找自己喜欢的好看的hexo主题，并下载。\nhexo主题地址:https://hexo.io/themes/\n点击到相应的github的主页，找到项目的地址，克隆到本地，比如我的博客使用的很受欢迎的yilia主题，如下\n```\ncd hexo\ncd themes //cd到themes目录下\ngit clone https://github.com/litten/hexo-theme-yilia.git yilia //下载到yilia文件夹\n```\n主题的目录结构如下\n```\n├── languages       //主题的语言包\n├── layout  //主题样式\n├── source       // 资源文件目录，例如图片\n├── source-src     //\n├── _config.yml   //配置文件\n└── package.json\n```\n主要修改在于_config.yml配置\n主要配置节选如下\n```\n# Header\n\nmenu:\n  主页: /\n  随笔: /tags/随笔/\n  技术: /tags/技术/\n  \n# SubNav\nsubnav:\n  github: \"https://github.com/Fan4J\"\n  weibo: \"http://weibo.com/2179165162/profile?topnav=1&wvr=6\"\n  #rss: \"#\"\n  zhihu: \"https://www.zhihu.com/people/storm-spirit/activities\"\n  #qq: \"#\"\n  #weixin: \"#\"\n  jianshu: \"http://www.jianshu.com/u/c4f8f0c4a19f\"\n  #douban: \"#\"\n  #segmentfault: \"#\"\n  #bilibili: \"#\"\n  #acfun: \"#\"\n  #mail: \"fspirit@yeah.net\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\n# 打赏\n# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏\nreward_type: 2\n# 打赏wording\nreward_wording: '多谢支持,一起努力~！'\n# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg\nalipay: /img/payali.jpg\n# 微信二维码图片地址\nweixin: /img/paywechat.jpg\n\n\nsmart_menu:\n  innerArchive: '所有文章'\n  friends: '友链'\n  aboutme: '关于我'\n\nfriends:\n  w3school: http://www.w3school.com.cn/\n  hexo: https://hexo.io/\n  hexo-theme-yilia: https://github.com/litten/hexo-theme-yilia/\n  \n\naboutme: 为了美好生活而拼命努力的普通人\n```\n添加头像既可以用本地的资源路径，记得是theme文件夹下的路径，例如我的图片放在theme/img/目录下\n```\navatar: /img/head.jpg\n```\n打赏的图片同理\n同时对于标签的js-content，需要安装一个包才可不出错，记着是在hexo目录下操作\n```\ncd hexo\nnpm i hexo-generator-json-content --save\n```\n## 5.绑定Github并部署\nGithubPages是指特定命名方式的respository: namespace.github.io,比如我的就是fan4j.github.io\n这样命名的仓库会被自动解析为githubpage,只需在hexo的全局配置文件中正确配置，即可简单部署\n```\nnpm install hexo-deployer-git --save\nnpm deploy \n```\n## 6.发布新文章\n以上内容弄好以后，发布新文章就很轻松了\n```\ncd hexo\nhexo new \"posttitle\"  //会在hexo/source/_posts目录下出现新的文章\n```\n打开文章，添加内容，修改配置，通常打开markdown文件可看到文件头，可以添加相应的文章标签，\n```\ntitle: 用GithubPages+Hexo搭建漂亮的博客\ndate: 2017-07-25 09:04:14\ntags: \n\t- 技术\n\t- 博客\n```\ntags可以继续添加，修改完成后即可开始部署到github服务器\n```\nhexo generate \nhexo deploy\n```\n部署完成，以后用这种方法部署即可\nhexo现在也支持简写，构建过程更加简易\n```\nhexo g == hexo generate\nhexo d == hexo deploy\nhexo s == hexo server\nhexo n == hexo new\n```\n## 7.代码保存，其他配置\n这时打开github可以看到仓库中已经是前端页面的代码，说明部署完毕，访问地址即可-> https://fan4j.github.io/\n同时可以将部署内容保存到新的respository中，可以在多个电脑上进行新文章的发布部署。\n## 8.结束语\n部署结束，中间可能遇到些坑，浪费了些时间，但是都还是可以通过网上搜索获取答案，总体还是觉得很值的，最后套用某人的话，希望不是三分钟热度，一定要把这个博客坚持下去~","slug":"how-to-build-this-blog","published":1,"updated":"2018-05-29T11:37:20.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhrnqssk0005jd6i0o82a7hc","content":"<blockquote>\n<p>一直以来都想自己搭建博客，作为个人生活和技术的记录，终于在前几天开始动手，一天多时间搭建了自己的个人博客，搭建方式：github+hexo（注：没有绑定个人域名，直接通过github提供的个性链接访问），这种方式可能会在速度上由于github本身的一些原因受到影响，存储空间上其实github没有什么限制，大可放心使用。<br>本文主要记录搭建的过程以及遇到的一些坑，仅供大家参考。<a href=\"https://fan4j.github.io/\">浏览博客</a></p>\n</blockquote>\n<h2 id=\"1-准备Github-git-nodejs\"><a href=\"#1-准备Github-git-nodejs\" class=\"headerlink\" title=\"1.准备Github,git,nodejs\"></a>1.准备Github,git,nodejs</h2><p>第一步，注册github账号，安装git,nodejs<br>github地址:<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">https://github.com/</a><br>git下载地址:<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/downloads</a><br>nodejs下载地址:<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/</a><br>nodejs的学习可以参考官方文档:<a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/</a><br>git如果不会建议先看廖雪峰的git教程:<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">点击链接</a><br>一切就绪后可以在存放代码的目录下打开git bash,确认是否安装成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git</span><br><span class=\"line\">node -v</span><br><span class=\"line\">npm -v  //最新版的nodejs已经集成了npm包</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-初始化hexo\"><a href=\"#2-初始化hexo\" class=\"headerlink\" title=\"2.初始化hexo\"></a>2.初始化hexo</h2><p>依次进行安装hexo,查看是否安装成功，初始化博客，部署，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init hexo  //初始化目录</span><br><span class=\"line\">cd hexo  //进入目录</span><br><span class=\"line\">hexo generate  //生成html    </span><br><span class=\"line\">hexo server  //运行本地服务</span><br></pre></td></tr></table></figure></p>\n<p>在本地部署完成之后，可以在<br><a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a><br>查看部署效果，目录结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── .deploy       //需要部署的文件</span><br><span class=\"line\">├── node_modules  //Hexo插件</span><br><span class=\"line\">├── public        //生成的静态网页文件</span><br><span class=\"line\">├── scaffolds     //模板</span><br><span class=\"line\">├── source        //博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</span><br><span class=\"line\">|   ├── _drafts   //草稿</span><br><span class=\"line\">|   └── _posts    //文章</span><br><span class=\"line\">├── themes        //主题</span><br><span class=\"line\">├── _config.yml   //全局配置文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-修改-config-yml进行格式修改\"><a href=\"#3-修改-config-yml进行格式修改\" class=\"headerlink\" title=\"3.修改_config.yml进行格式修改\"></a>3.修改_config.yml进行格式修改</h2><p>主要配置如下，可以用于参考，需要注意的是yml格式非常严格，冒号后面需要加空格，后面jsContent是为了yilia标签库特效准备的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: 重塑自我</span><br><span class=\"line\">subtitle: 当你低头的瞬间，才发现脚下的路</span><br><span class=\"line\">description: 当你低头的瞬间，才发现脚下的路</span><br><span class=\"line\">author: Fan4j</span><br><span class=\"line\">language: zh-Hans</span><br><span class=\"line\">timezone: Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:Fan4J/fan4j.github.io.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">  </span><br><span class=\"line\">jsonContent:</span><br><span class=\"line\">    meta: false</span><br><span class=\"line\">    pages: false</span><br><span class=\"line\">    posts:</span><br><span class=\"line\">      title: true</span><br><span class=\"line\">      date: true</span><br><span class=\"line\">      path: true</span><br><span class=\"line\">      text: false</span><br><span class=\"line\">      raw: false</span><br><span class=\"line\">      content: false</span><br><span class=\"line\">      slug: false</span><br><span class=\"line\">      updated: false</span><br><span class=\"line\">      comments: false</span><br><span class=\"line\">      link: false</span><br><span class=\"line\">      permalink: false</span><br><span class=\"line\">      excerpt: false</span><br><span class=\"line\">      categories: false</span><br><span class=\"line\">      tags: true</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-修改主题\"><a href=\"#4-修改主题\" class=\"headerlink\" title=\"4.修改主题\"></a>4.修改主题</h2><p>进入主题目录下，从github上找自己喜欢的好看的hexo主题，并下载。<br>hexo主题地址:<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/</a><br>点击到相应的github的主页，找到项目的地址，克隆到本地，比如我的博客使用的很受欢迎的yilia主题，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">cd themes //cd到themes目录下</span><br><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git yilia //下载到yilia文件夹</span><br></pre></td></tr></table></figure></p>\n<p>主题的目录结构如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── languages       //主题的语言包</span><br><span class=\"line\">├── layout  //主题样式</span><br><span class=\"line\">├── source       // 资源文件目录，例如图片</span><br><span class=\"line\">├── source-src     //</span><br><span class=\"line\">├── _config.yml   //配置文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<p>主要修改在于_config.yml配置<br>主要配置节选如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Header</span><br><span class=\"line\"></span><br><span class=\"line\">menu:</span><br><span class=\"line\">  主页: /</span><br><span class=\"line\">  随笔: /tags/随笔/</span><br><span class=\"line\">  技术: /tags/技术/</span><br><span class=\"line\">  </span><br><span class=\"line\"># SubNav</span><br><span class=\"line\">subnav:</span><br><span class=\"line\">  github: &quot;https://github.com/Fan4J&quot;</span><br><span class=\"line\">  weibo: &quot;http://weibo.com/2179165162/profile?topnav=1&amp;wvr=6&quot;</span><br><span class=\"line\">  #rss: &quot;#&quot;</span><br><span class=\"line\">  zhihu: &quot;https://www.zhihu.com/people/storm-spirit/activities&quot;</span><br><span class=\"line\">  #qq: &quot;#&quot;</span><br><span class=\"line\">  #weixin: &quot;#&quot;</span><br><span class=\"line\">  jianshu: &quot;http://www.jianshu.com/u/c4f8f0c4a19f&quot;</span><br><span class=\"line\">  #douban: &quot;#&quot;</span><br><span class=\"line\">  #segmentfault: &quot;#&quot;</span><br><span class=\"line\">  #bilibili: &quot;#&quot;</span><br><span class=\"line\">  #acfun: &quot;#&quot;</span><br><span class=\"line\">  #mail: &quot;fspirit@yeah.net&quot;</span><br><span class=\"line\">  #facebook: &quot;#&quot;</span><br><span class=\"line\">  #google: &quot;#&quot;</span><br><span class=\"line\">  #twitter: &quot;#&quot;</span><br><span class=\"line\">  #linkedin: &quot;#&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 打赏</span><br><span class=\"line\"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</span><br><span class=\"line\">reward_type: 2</span><br><span class=\"line\"># 打赏wording</span><br><span class=\"line\">reward_wording: &apos;多谢支持,一起努力~！&apos;</span><br><span class=\"line\"># 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</span><br><span class=\"line\">alipay: /img/payali.jpg</span><br><span class=\"line\"># 微信二维码图片地址</span><br><span class=\"line\">weixin: /img/paywechat.jpg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">smart_menu:</span><br><span class=\"line\">  innerArchive: &apos;所有文章&apos;</span><br><span class=\"line\">  friends: &apos;友链&apos;</span><br><span class=\"line\">  aboutme: &apos;关于我&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">friends:</span><br><span class=\"line\">  w3school: http://www.w3school.com.cn/</span><br><span class=\"line\">  hexo: https://hexo.io/</span><br><span class=\"line\">  hexo-theme-yilia: https://github.com/litten/hexo-theme-yilia/</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">aboutme: 为了美好生活而拼命努力的普通人</span><br></pre></td></tr></table></figure></p>\n<p>添加头像既可以用本地的资源路径，记得是theme文件夹下的路径，例如我的图片放在theme/img/目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avatar: /img/head.jpg</span><br></pre></td></tr></table></figure></p>\n<p>打赏的图片同理<br>同时对于标签的js-content，需要安装一个包才可不出错，记着是在hexo目录下操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">npm i hexo-generator-json-content --save</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-绑定Github并部署\"><a href=\"#5-绑定Github并部署\" class=\"headerlink\" title=\"5.绑定Github并部署\"></a>5.绑定Github并部署</h2><p>GithubPages是指特定命名方式的respository: namespace.github.io,比如我的就是fan4j.github.io<br>这样命名的仓库会被自动解析为githubpage,只需在hexo的全局配置文件中正确配置，即可简单部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\">npm deploy</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-发布新文章\"><a href=\"#6-发布新文章\" class=\"headerlink\" title=\"6.发布新文章\"></a>6.发布新文章</h2><p>以上内容弄好以后，发布新文章就很轻松了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">hexo new &quot;posttitle&quot;  //会在hexo/source/_posts目录下出现新的文章</span><br></pre></td></tr></table></figure></p>\n<p>打开文章，添加内容，修改配置，通常打开markdown文件可看到文件头，可以添加相应的文章标签，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 用GithubPages+Hexo搭建漂亮的博客</span><br><span class=\"line\">date: 2017-07-25 09:04:14</span><br><span class=\"line\">tags: </span><br><span class=\"line\">\t- 技术</span><br><span class=\"line\">\t- 博客</span><br></pre></td></tr></table></figure></p>\n<p>tags可以继续添加，修改完成后即可开始部署到github服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>部署完成，以后用这种方法部署即可<br>hexo现在也支持简写，构建过程更加简易<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo d == hexo deploy</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo n == hexo new</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"7-代码保存，其他配置\"><a href=\"#7-代码保存，其他配置\" class=\"headerlink\" title=\"7.代码保存，其他配置\"></a>7.代码保存，其他配置</h2><p>这时打开github可以看到仓库中已经是前端页面的代码，说明部署完毕，访问地址即可-&gt; <a href=\"https://fan4j.github.io/\">https://fan4j.github.io/</a><br>同时可以将部署内容保存到新的respository中，可以在多个电脑上进行新文章的发布部署。</p>\n<h2 id=\"8-结束语\"><a href=\"#8-结束语\" class=\"headerlink\" title=\"8.结束语\"></a>8.结束语</h2><p>部署结束，中间可能遇到些坑，浪费了些时间，但是都还是可以通过网上搜索获取答案，总体还是觉得很值的，最后套用某人的话，希望不是三分钟热度，一定要把这个博客坚持下去~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一直以来都想自己搭建博客，作为个人生活和技术的记录，终于在前几天开始动手，一天多时间搭建了自己的个人博客，搭建方式：github+hexo（注：没有绑定个人域名，直接通过github提供的个性链接访问），这种方式可能会在速度上由于github本身的一些原因受到影响，存储空间上其实github没有什么限制，大可放心使用。<br>本文主要记录搭建的过程以及遇到的一些坑，仅供大家参考。<a href=\"https://fan4j.github.io/\">浏览博客</a></p>\n</blockquote>\n<h2 id=\"1-准备Github-git-nodejs\"><a href=\"#1-准备Github-git-nodejs\" class=\"headerlink\" title=\"1.准备Github,git,nodejs\"></a>1.准备Github,git,nodejs</h2><p>第一步，注册github账号，安装git,nodejs<br>github地址:<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">https://github.com/</a><br>git下载地址:<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/downloads</a><br>nodejs下载地址:<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/</a><br>nodejs的学习可以参考官方文档:<a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/</a><br>git如果不会建议先看廖雪峰的git教程:<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">点击链接</a><br>一切就绪后可以在存放代码的目录下打开git bash,确认是否安装成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git</span><br><span class=\"line\">node -v</span><br><span class=\"line\">npm -v  //最新版的nodejs已经集成了npm包</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-初始化hexo\"><a href=\"#2-初始化hexo\" class=\"headerlink\" title=\"2.初始化hexo\"></a>2.初始化hexo</h2><p>依次进行安装hexo,查看是否安装成功，初始化博客，部署，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init hexo  //初始化目录</span><br><span class=\"line\">cd hexo  //进入目录</span><br><span class=\"line\">hexo generate  //生成html    </span><br><span class=\"line\">hexo server  //运行本地服务</span><br></pre></td></tr></table></figure></p>\n<p>在本地部署完成之后，可以在<br><a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a><br>查看部署效果，目录结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── .deploy       //需要部署的文件</span><br><span class=\"line\">├── node_modules  //Hexo插件</span><br><span class=\"line\">├── public        //生成的静态网页文件</span><br><span class=\"line\">├── scaffolds     //模板</span><br><span class=\"line\">├── source        //博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</span><br><span class=\"line\">|   ├── _drafts   //草稿</span><br><span class=\"line\">|   └── _posts    //文章</span><br><span class=\"line\">├── themes        //主题</span><br><span class=\"line\">├── _config.yml   //全局配置文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-修改-config-yml进行格式修改\"><a href=\"#3-修改-config-yml进行格式修改\" class=\"headerlink\" title=\"3.修改_config.yml进行格式修改\"></a>3.修改_config.yml进行格式修改</h2><p>主要配置如下，可以用于参考，需要注意的是yml格式非常严格，冒号后面需要加空格，后面jsContent是为了yilia标签库特效准备的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: 重塑自我</span><br><span class=\"line\">subtitle: 当你低头的瞬间，才发现脚下的路</span><br><span class=\"line\">description: 当你低头的瞬间，才发现脚下的路</span><br><span class=\"line\">author: Fan4j</span><br><span class=\"line\">language: zh-Hans</span><br><span class=\"line\">timezone: Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:Fan4J/fan4j.github.io.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">  </span><br><span class=\"line\">jsonContent:</span><br><span class=\"line\">    meta: false</span><br><span class=\"line\">    pages: false</span><br><span class=\"line\">    posts:</span><br><span class=\"line\">      title: true</span><br><span class=\"line\">      date: true</span><br><span class=\"line\">      path: true</span><br><span class=\"line\">      text: false</span><br><span class=\"line\">      raw: false</span><br><span class=\"line\">      content: false</span><br><span class=\"line\">      slug: false</span><br><span class=\"line\">      updated: false</span><br><span class=\"line\">      comments: false</span><br><span class=\"line\">      link: false</span><br><span class=\"line\">      permalink: false</span><br><span class=\"line\">      excerpt: false</span><br><span class=\"line\">      categories: false</span><br><span class=\"line\">      tags: true</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-修改主题\"><a href=\"#4-修改主题\" class=\"headerlink\" title=\"4.修改主题\"></a>4.修改主题</h2><p>进入主题目录下，从github上找自己喜欢的好看的hexo主题，并下载。<br>hexo主题地址:<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/</a><br>点击到相应的github的主页，找到项目的地址，克隆到本地，比如我的博客使用的很受欢迎的yilia主题，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">cd themes //cd到themes目录下</span><br><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git yilia //下载到yilia文件夹</span><br></pre></td></tr></table></figure></p>\n<p>主题的目录结构如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── languages       //主题的语言包</span><br><span class=\"line\">├── layout  //主题样式</span><br><span class=\"line\">├── source       // 资源文件目录，例如图片</span><br><span class=\"line\">├── source-src     //</span><br><span class=\"line\">├── _config.yml   //配置文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<p>主要修改在于_config.yml配置<br>主要配置节选如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Header</span><br><span class=\"line\"></span><br><span class=\"line\">menu:</span><br><span class=\"line\">  主页: /</span><br><span class=\"line\">  随笔: /tags/随笔/</span><br><span class=\"line\">  技术: /tags/技术/</span><br><span class=\"line\">  </span><br><span class=\"line\"># SubNav</span><br><span class=\"line\">subnav:</span><br><span class=\"line\">  github: &quot;https://github.com/Fan4J&quot;</span><br><span class=\"line\">  weibo: &quot;http://weibo.com/2179165162/profile?topnav=1&amp;wvr=6&quot;</span><br><span class=\"line\">  #rss: &quot;#&quot;</span><br><span class=\"line\">  zhihu: &quot;https://www.zhihu.com/people/storm-spirit/activities&quot;</span><br><span class=\"line\">  #qq: &quot;#&quot;</span><br><span class=\"line\">  #weixin: &quot;#&quot;</span><br><span class=\"line\">  jianshu: &quot;http://www.jianshu.com/u/c4f8f0c4a19f&quot;</span><br><span class=\"line\">  #douban: &quot;#&quot;</span><br><span class=\"line\">  #segmentfault: &quot;#&quot;</span><br><span class=\"line\">  #bilibili: &quot;#&quot;</span><br><span class=\"line\">  #acfun: &quot;#&quot;</span><br><span class=\"line\">  #mail: &quot;fspirit@yeah.net&quot;</span><br><span class=\"line\">  #facebook: &quot;#&quot;</span><br><span class=\"line\">  #google: &quot;#&quot;</span><br><span class=\"line\">  #twitter: &quot;#&quot;</span><br><span class=\"line\">  #linkedin: &quot;#&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 打赏</span><br><span class=\"line\"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</span><br><span class=\"line\">reward_type: 2</span><br><span class=\"line\"># 打赏wording</span><br><span class=\"line\">reward_wording: &apos;多谢支持,一起努力~！&apos;</span><br><span class=\"line\"># 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</span><br><span class=\"line\">alipay: /img/payali.jpg</span><br><span class=\"line\"># 微信二维码图片地址</span><br><span class=\"line\">weixin: /img/paywechat.jpg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">smart_menu:</span><br><span class=\"line\">  innerArchive: &apos;所有文章&apos;</span><br><span class=\"line\">  friends: &apos;友链&apos;</span><br><span class=\"line\">  aboutme: &apos;关于我&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">friends:</span><br><span class=\"line\">  w3school: http://www.w3school.com.cn/</span><br><span class=\"line\">  hexo: https://hexo.io/</span><br><span class=\"line\">  hexo-theme-yilia: https://github.com/litten/hexo-theme-yilia/</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">aboutme: 为了美好生活而拼命努力的普通人</span><br></pre></td></tr></table></figure></p>\n<p>添加头像既可以用本地的资源路径，记得是theme文件夹下的路径，例如我的图片放在theme/img/目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avatar: /img/head.jpg</span><br></pre></td></tr></table></figure></p>\n<p>打赏的图片同理<br>同时对于标签的js-content，需要安装一个包才可不出错，记着是在hexo目录下操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">npm i hexo-generator-json-content --save</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-绑定Github并部署\"><a href=\"#5-绑定Github并部署\" class=\"headerlink\" title=\"5.绑定Github并部署\"></a>5.绑定Github并部署</h2><p>GithubPages是指特定命名方式的respository: namespace.github.io,比如我的就是fan4j.github.io<br>这样命名的仓库会被自动解析为githubpage,只需在hexo的全局配置文件中正确配置，即可简单部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\">npm deploy</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-发布新文章\"><a href=\"#6-发布新文章\" class=\"headerlink\" title=\"6.发布新文章\"></a>6.发布新文章</h2><p>以上内容弄好以后，发布新文章就很轻松了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">hexo new &quot;posttitle&quot;  //会在hexo/source/_posts目录下出现新的文章</span><br></pre></td></tr></table></figure></p>\n<p>打开文章，添加内容，修改配置，通常打开markdown文件可看到文件头，可以添加相应的文章标签，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 用GithubPages+Hexo搭建漂亮的博客</span><br><span class=\"line\">date: 2017-07-25 09:04:14</span><br><span class=\"line\">tags: </span><br><span class=\"line\">\t- 技术</span><br><span class=\"line\">\t- 博客</span><br></pre></td></tr></table></figure></p>\n<p>tags可以继续添加，修改完成后即可开始部署到github服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>部署完成，以后用这种方法部署即可<br>hexo现在也支持简写，构建过程更加简易<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo d == hexo deploy</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo n == hexo new</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"7-代码保存，其他配置\"><a href=\"#7-代码保存，其他配置\" class=\"headerlink\" title=\"7.代码保存，其他配置\"></a>7.代码保存，其他配置</h2><p>这时打开github可以看到仓库中已经是前端页面的代码，说明部署完毕，访问地址即可-&gt; <a href=\"https://fan4j.github.io/\">https://fan4j.github.io/</a><br>同时可以将部署内容保存到新的respository中，可以在多个电脑上进行新文章的发布部署。</p>\n<h2 id=\"8-结束语\"><a href=\"#8-结束语\" class=\"headerlink\" title=\"8.结束语\"></a>8.结束语</h2><p>部署结束，中间可能遇到些坑，浪费了些时间，但是都还是可以通过网上搜索获取答案，总体还是觉得很值的，最后套用某人的话，希望不是三分钟热度，一定要把这个博客坚持下去~</p>\n"},{"title":"python json","date":"2017-08-18T03:05:37.000Z","_content":">python世界里，json和dict是天生一对，他们之间的转换是必须要熟练的\n\n# 1.dumps/loads \n```\ndict1 = {\"fan\":123456,\"gaga\":\"4j\"}\njson1 = json.dumps(dict1)\nprint(json1)\nprint(type(json1))\n\ndict2 = json.loads(str(json1))\nprint(dict2)\nprint(type(dict2))\n```\n输出如下\n```\n{\"gaga\": \"4j\", \"fan\": 123456}\n<class 'str'>\n{'fan': 123456, 'gaga': '4j'}\n<class 'dict'>\n```\n# 2.dump/load\n```\ndict = {\"fan\":1123,\"gaga\":\"12312\"}\nwith open(\"test.txt\",\"w\") as f:\n     json.dump(dict,f)\n\nwith open(\"test.txt\",\"r\") as f:\n     dict1 = json.load(f)\nprint(dict1)\nprint(type(dict1))\n```\n输出如下\n```\n{'gaga': '12312', 'fan': 1123}\n<class 'dict'>\n```\n以上，后面会继续补充","source":"_posts/python-json.md","raw":"---\ntitle: python json\ndate: 2017-08-18 11:05:37\ntags: \n\t- Python\n---\n>python世界里，json和dict是天生一对，他们之间的转换是必须要熟练的\n\n# 1.dumps/loads \n```\ndict1 = {\"fan\":123456,\"gaga\":\"4j\"}\njson1 = json.dumps(dict1)\nprint(json1)\nprint(type(json1))\n\ndict2 = json.loads(str(json1))\nprint(dict2)\nprint(type(dict2))\n```\n输出如下\n```\n{\"gaga\": \"4j\", \"fan\": 123456}\n<class 'str'>\n{'fan': 123456, 'gaga': '4j'}\n<class 'dict'>\n```\n# 2.dump/load\n```\ndict = {\"fan\":1123,\"gaga\":\"12312\"}\nwith open(\"test.txt\",\"w\") as f:\n     json.dump(dict,f)\n\nwith open(\"test.txt\",\"r\") as f:\n     dict1 = json.load(f)\nprint(dict1)\nprint(type(dict1))\n```\n输出如下\n```\n{'gaga': '12312', 'fan': 1123}\n<class 'dict'>\n```\n以上，后面会继续补充","slug":"python-json","published":1,"updated":"2018-05-29T11:37:20.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhrnqssn0007jd6idtilx74z","content":"<blockquote>\n<p>python世界里，json和dict是天生一对，他们之间的转换是必须要熟练的</p>\n</blockquote>\n<h1 id=\"1-dumps-loads\"><a href=\"#1-dumps-loads\" class=\"headerlink\" title=\"1.dumps/loads\"></a>1.dumps/loads</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict1 = &#123;&quot;fan&quot;:123456,&quot;gaga&quot;:&quot;4j&quot;&#125;</span><br><span class=\"line\">json1 = json.dumps(dict1)</span><br><span class=\"line\">print(json1)</span><br><span class=\"line\">print(type(json1))</span><br><span class=\"line\"></span><br><span class=\"line\">dict2 = json.loads(str(json1))</span><br><span class=\"line\">print(dict2)</span><br><span class=\"line\">print(type(dict2))</span><br></pre></td></tr></table></figure>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;gaga&quot;: &quot;4j&quot;, &quot;fan&quot;: 123456&#125;</span><br><span class=\"line\">&lt;class &apos;str&apos;&gt;</span><br><span class=\"line\">&#123;&apos;fan&apos;: 123456, &apos;gaga&apos;: &apos;4j&apos;&#125;</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-dump-load\"><a href=\"#2-dump-load\" class=\"headerlink\" title=\"2.dump/load\"></a>2.dump/load</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict = &#123;&quot;fan&quot;:1123,&quot;gaga&quot;:&quot;12312&quot;&#125;</span><br><span class=\"line\">with open(&quot;test.txt&quot;,&quot;w&quot;) as f:</span><br><span class=\"line\">     json.dump(dict,f)</span><br><span class=\"line\"></span><br><span class=\"line\">with open(&quot;test.txt&quot;,&quot;r&quot;) as f:</span><br><span class=\"line\">     dict1 = json.load(f)</span><br><span class=\"line\">print(dict1)</span><br><span class=\"line\">print(type(dict1))</span><br></pre></td></tr></table></figure>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;gaga&apos;: &apos;12312&apos;, &apos;fan&apos;: 1123&#125;</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以上，后面会继续补充</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>python世界里，json和dict是天生一对，他们之间的转换是必须要熟练的</p>\n</blockquote>\n<h1 id=\"1-dumps-loads\"><a href=\"#1-dumps-loads\" class=\"headerlink\" title=\"1.dumps/loads\"></a>1.dumps/loads</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict1 = &#123;&quot;fan&quot;:123456,&quot;gaga&quot;:&quot;4j&quot;&#125;</span><br><span class=\"line\">json1 = json.dumps(dict1)</span><br><span class=\"line\">print(json1)</span><br><span class=\"line\">print(type(json1))</span><br><span class=\"line\"></span><br><span class=\"line\">dict2 = json.loads(str(json1))</span><br><span class=\"line\">print(dict2)</span><br><span class=\"line\">print(type(dict2))</span><br></pre></td></tr></table></figure>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;gaga&quot;: &quot;4j&quot;, &quot;fan&quot;: 123456&#125;</span><br><span class=\"line\">&lt;class &apos;str&apos;&gt;</span><br><span class=\"line\">&#123;&apos;fan&apos;: 123456, &apos;gaga&apos;: &apos;4j&apos;&#125;</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-dump-load\"><a href=\"#2-dump-load\" class=\"headerlink\" title=\"2.dump/load\"></a>2.dump/load</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict = &#123;&quot;fan&quot;:1123,&quot;gaga&quot;:&quot;12312&quot;&#125;</span><br><span class=\"line\">with open(&quot;test.txt&quot;,&quot;w&quot;) as f:</span><br><span class=\"line\">     json.dump(dict,f)</span><br><span class=\"line\"></span><br><span class=\"line\">with open(&quot;test.txt&quot;,&quot;r&quot;) as f:</span><br><span class=\"line\">     dict1 = json.load(f)</span><br><span class=\"line\">print(dict1)</span><br><span class=\"line\">print(type(dict1))</span><br></pre></td></tr></table></figure>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;gaga&apos;: &apos;12312&apos;, &apos;fan&apos;: 1123&#125;</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以上，后面会继续补充</p>\n"},{"title":"用python模拟知乎登录","date":"2017-08-18T02:33:00.000Z","_content":">前言：最近看到公众号python之禅里面的历史文章，模拟登录知乎，又看到很多人在网上尝试写代码，自己也想试试，最新的验证码是选择倒立的汉字，本文采用手动输入验证码的形式完成验证，最后获取cookie，存入文件中，之后便可以无需登录直接访问了。\n>所用python的包：requests，BeautifulSoup，json\n\n首先之前使用python请求网页有层出不穷的包，但是用了requests之后才知道它有多方便，详情可以参考这篇文章，也是python之禅公众号的文章，这里帮忙推荐一波--->[链接](http://mp.weixin.qq.com/s/gO8E3lXZiL6_ql5rDuHwMQ)。\n下面一步步开始讲解如何模拟登录。\n## 1.观察请求参数（FireFox/Chrome）\n在向网站发送请求的时候，服务器会对访问用户进行标识，以cookie的形式存放在浏览器，该浏览器下次进行访问时，则可以跳过登陆直接浏览页面，这是我们模拟知乎登陆的主要目的，获取cookie后，使用cookie访问主页面，则可以跳过登陆。在火狐中，先清掉之前保存的cookie，以模拟浏览器首次访问。\n![清除火狐cookie](http://upload-images.jianshu.io/upload_images/5834071-9e6c660f8d81b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n清除cookie后，试着登陆知乎，发现有验证码，打开F12，一边发请求，一边观察网络中的变化。\n这里故意输错密码，看看发送了什么请求。\n\n![登陆请求头](http://upload-images.jianshu.io/upload_images/5834071-2679b4d38f31cd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n![登陆请求参数](http://upload-images.jianshu.io/upload_images/5834071-500e37e330a78361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n\n_xsrf的参数是用于防止xsrf攻击，如何防止xsrf攻击，可以参考[这篇文章](http://blog.csdn.net/newjueqi/article/details/7542409)，这是一种简单的恶意链接攻击，可以直接让你访问目标网站并且修改你的密码，所以一般在提交的表单中加个_xsrf参数，只有参数正确才可以进行提交。\n\n## 2.代码模拟请求\n可以看到知乎的主要请求参数，还有email,password,captcha,captcha_type。\n自己试验过，captcha_type可以不用填写，首先还是找到验证码的链接如下：\nhttps://www.zhihu.com/captcha.gif?r=1503020715890&type=login&lang=cn\n\n![获取验证码的链接](http://upload-images.jianshu.io/upload_images/5834071-8a5e858b5322688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n很明显，中间的数字是以毫秒为单位的时间戳，因此在代码中很容易模拟这个链接去发送请求获取验证码的图片。\n```\ndef get_captcha():\n    timestamp = str(time.time()*1000).split(\".\")[0]\n    url = \"https://www.zhihu.com/captcha.gif?r=%s&type=login&lang=cn\" % timestamp\n    print(url)\n    req = session.get(url,headers=headers)\n    with open(\"img1.png\",'wb') as f:\n        f.write(req.content)\n```\n我采用的方式是人工识别，所以把图片以二进制的形式写入文件，自己点开查看。\n得到的内容是一行汉字：\n![知乎验证码](http://upload-images.jianshu.io/upload_images/5834071-c31e380d68644a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400)\n点击倒立的汉字，获取响应的坐标，放在请求参数中，即可模拟鼠标点击的过程，可以自己点击几个点，大概找到1234567个汉字的坐标，然后根据汉字的个数，匹配响应的坐标点，填入参数中即可。\n```\ndef get_code():\n    get_captcha()\n    print(\"输入倒立汉字的位置，用逗号隔开\")\n    a = input(\"input:\")\n    indexs = a.split(\",\")\n    data=[[16.4,26.9],[33.4,26.9],[60.4,21.9],[84.4,24.9],[108.4,24.9],[130.4,24.9],[156.4,24.9]]\n    input_points = []\n    for idx in indexs:\n        input_points.append(data[int(idx)-1])\n    dict = {\n        \"img_size\": [200, 44],\n        \"input_points\": input_points\n    }\n    return dict\n```\n有了xsrf参数和验证码，输入自己的账号密码，即可模拟登录\n```\ndef login():\n    url = \"https://www.zhihu.com/login/email\"\n    data={\n        \"_xsrf\":get_xsrf(),\n        \"email\":'******@qq.com',\n        \"password\":'asfgasdfasf',\n        'captcha_type':get_code()\n    }\n    response = session.post(url, data=data,headers=headers)\n    login_code = response.json()\n    print(login_code['msg'])\n    response = session.get(\"https://www.zhihu.com/settings/profile\",headers=headers)\n    #将cookies->dict->json存放在txt|之后再json->dict直接使用\n    with open(\"cookies.txt\",'w') as f:\n        json.dump(session.cookies.get_dict(),f)\n    with open(\"login.html\",\"wb\") as f:\n        f.write(response.content)\n```\n第一次登录结束后，session.cookie会自动保持登录状态的cookie，下一次进行登录时，使用cookie即可，这里进行持久化，暂时写在txt文件中，下次使用时直接从文件获取。\n这里有个小插曲就是session.cookie的类型是RequestCookie不是dict或者str，这里使用get_dict()方法转化成dict，并用json的形式存在txt文件中，取出来的时候，json可以直接提取成dict，放入session.cookie可以直接使用。\n```\n#将cookies->dict->json存放在txt|之后再json->dict直接使用\n    with open(\"cookies.txt\",'w') as f:\n        json.dump(session.cookies.get_dict(),f)\n\n#从txt文件中获取cookies,json->dict存入session.cookies\n    with open(\"cookies.txt\",'r') as f:\n        cookies = json.load(f)\n    session.cookies.update(cookies)\n```\n这里也可以温习下，Python中Json的操作->[链接](http://www.jianshu.com/p/26cb66297a6a)\n获取cookie后，我尝试登录了(https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。\n## 3.总结\n写知乎登录，主要也是练练手，觉得挺有意思，后面可以尝试用phantomjs+selenium模拟下登录爬取，有了登录cookie之后，也可以爬一下知乎的内容，应该有很多有趣的内容，后续会继续更新的，谢谢关注~\ngithub上我也上传了代码，欢迎大家点评，学习。\n[源码地址](https://github.com/Fan4J/Spiders-of-frequently-used-website/tree/master/zhihuLogin)\n[重塑自我](https://fan4j.github.io/)","source":"_posts/python-知乎登录.md","raw":"---\ntitle: 用python模拟知乎登录\ndate: 2017-08-18 10:33:00\ntags: \n\t- Python\n\t- 知乎\n\t\n---\n>前言：最近看到公众号python之禅里面的历史文章，模拟登录知乎，又看到很多人在网上尝试写代码，自己也想试试，最新的验证码是选择倒立的汉字，本文采用手动输入验证码的形式完成验证，最后获取cookie，存入文件中，之后便可以无需登录直接访问了。\n>所用python的包：requests，BeautifulSoup，json\n\n首先之前使用python请求网页有层出不穷的包，但是用了requests之后才知道它有多方便，详情可以参考这篇文章，也是python之禅公众号的文章，这里帮忙推荐一波--->[链接](http://mp.weixin.qq.com/s/gO8E3lXZiL6_ql5rDuHwMQ)。\n下面一步步开始讲解如何模拟登录。\n## 1.观察请求参数（FireFox/Chrome）\n在向网站发送请求的时候，服务器会对访问用户进行标识，以cookie的形式存放在浏览器，该浏览器下次进行访问时，则可以跳过登陆直接浏览页面，这是我们模拟知乎登陆的主要目的，获取cookie后，使用cookie访问主页面，则可以跳过登陆。在火狐中，先清掉之前保存的cookie，以模拟浏览器首次访问。\n![清除火狐cookie](http://upload-images.jianshu.io/upload_images/5834071-9e6c660f8d81b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n清除cookie后，试着登陆知乎，发现有验证码，打开F12，一边发请求，一边观察网络中的变化。\n这里故意输错密码，看看发送了什么请求。\n\n![登陆请求头](http://upload-images.jianshu.io/upload_images/5834071-2679b4d38f31cd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n![登陆请求参数](http://upload-images.jianshu.io/upload_images/5834071-500e37e330a78361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n\n_xsrf的参数是用于防止xsrf攻击，如何防止xsrf攻击，可以参考[这篇文章](http://blog.csdn.net/newjueqi/article/details/7542409)，这是一种简单的恶意链接攻击，可以直接让你访问目标网站并且修改你的密码，所以一般在提交的表单中加个_xsrf参数，只有参数正确才可以进行提交。\n\n## 2.代码模拟请求\n可以看到知乎的主要请求参数，还有email,password,captcha,captcha_type。\n自己试验过，captcha_type可以不用填写，首先还是找到验证码的链接如下：\nhttps://www.zhihu.com/captcha.gif?r=1503020715890&type=login&lang=cn\n\n![获取验证码的链接](http://upload-images.jianshu.io/upload_images/5834071-8a5e858b5322688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n很明显，中间的数字是以毫秒为单位的时间戳，因此在代码中很容易模拟这个链接去发送请求获取验证码的图片。\n```\ndef get_captcha():\n    timestamp = str(time.time()*1000).split(\".\")[0]\n    url = \"https://www.zhihu.com/captcha.gif?r=%s&type=login&lang=cn\" % timestamp\n    print(url)\n    req = session.get(url,headers=headers)\n    with open(\"img1.png\",'wb') as f:\n        f.write(req.content)\n```\n我采用的方式是人工识别，所以把图片以二进制的形式写入文件，自己点开查看。\n得到的内容是一行汉字：\n![知乎验证码](http://upload-images.jianshu.io/upload_images/5834071-c31e380d68644a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400)\n点击倒立的汉字，获取响应的坐标，放在请求参数中，即可模拟鼠标点击的过程，可以自己点击几个点，大概找到1234567个汉字的坐标，然后根据汉字的个数，匹配响应的坐标点，填入参数中即可。\n```\ndef get_code():\n    get_captcha()\n    print(\"输入倒立汉字的位置，用逗号隔开\")\n    a = input(\"input:\")\n    indexs = a.split(\",\")\n    data=[[16.4,26.9],[33.4,26.9],[60.4,21.9],[84.4,24.9],[108.4,24.9],[130.4,24.9],[156.4,24.9]]\n    input_points = []\n    for idx in indexs:\n        input_points.append(data[int(idx)-1])\n    dict = {\n        \"img_size\": [200, 44],\n        \"input_points\": input_points\n    }\n    return dict\n```\n有了xsrf参数和验证码，输入自己的账号密码，即可模拟登录\n```\ndef login():\n    url = \"https://www.zhihu.com/login/email\"\n    data={\n        \"_xsrf\":get_xsrf(),\n        \"email\":'******@qq.com',\n        \"password\":'asfgasdfasf',\n        'captcha_type':get_code()\n    }\n    response = session.post(url, data=data,headers=headers)\n    login_code = response.json()\n    print(login_code['msg'])\n    response = session.get(\"https://www.zhihu.com/settings/profile\",headers=headers)\n    #将cookies->dict->json存放在txt|之后再json->dict直接使用\n    with open(\"cookies.txt\",'w') as f:\n        json.dump(session.cookies.get_dict(),f)\n    with open(\"login.html\",\"wb\") as f:\n        f.write(response.content)\n```\n第一次登录结束后，session.cookie会自动保持登录状态的cookie，下一次进行登录时，使用cookie即可，这里进行持久化，暂时写在txt文件中，下次使用时直接从文件获取。\n这里有个小插曲就是session.cookie的类型是RequestCookie不是dict或者str，这里使用get_dict()方法转化成dict，并用json的形式存在txt文件中，取出来的时候，json可以直接提取成dict，放入session.cookie可以直接使用。\n```\n#将cookies->dict->json存放在txt|之后再json->dict直接使用\n    with open(\"cookies.txt\",'w') as f:\n        json.dump(session.cookies.get_dict(),f)\n\n#从txt文件中获取cookies,json->dict存入session.cookies\n    with open(\"cookies.txt\",'r') as f:\n        cookies = json.load(f)\n    session.cookies.update(cookies)\n```\n这里也可以温习下，Python中Json的操作->[链接](http://www.jianshu.com/p/26cb66297a6a)\n获取cookie后，我尝试登录了(https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。\n## 3.总结\n写知乎登录，主要也是练练手，觉得挺有意思，后面可以尝试用phantomjs+selenium模拟下登录爬取，有了登录cookie之后，也可以爬一下知乎的内容，应该有很多有趣的内容，后续会继续更新的，谢谢关注~\ngithub上我也上传了代码，欢迎大家点评，学习。\n[源码地址](https://github.com/Fan4J/Spiders-of-frequently-used-website/tree/master/zhihuLogin)\n[重塑自我](https://fan4j.github.io/)","slug":"python-知乎登录","published":1,"updated":"2018-05-29T11:37:20.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjhrnqssp0008jd6iicakt5rk","content":"<blockquote>\n<p>前言：最近看到公众号python之禅里面的历史文章，模拟登录知乎，又看到很多人在网上尝试写代码，自己也想试试，最新的验证码是选择倒立的汉字，本文采用手动输入验证码的形式完成验证，最后获取cookie，存入文件中，之后便可以无需登录直接访问了。<br>所用python的包：requests，BeautifulSoup，json</p>\n</blockquote>\n<p>首先之前使用python请求网页有层出不穷的包，但是用了requests之后才知道它有多方便，详情可以参考这篇文章，也是python之禅公众号的文章，这里帮忙推荐一波—&gt;<a href=\"http://mp.weixin.qq.com/s/gO8E3lXZiL6_ql5rDuHwMQ\" target=\"_blank\" rel=\"noopener\">链接</a>。<br>下面一步步开始讲解如何模拟登录。</p>\n<h2 id=\"1-观察请求参数（FireFox-Chrome）\"><a href=\"#1-观察请求参数（FireFox-Chrome）\" class=\"headerlink\" title=\"1.观察请求参数（FireFox/Chrome）\"></a>1.观察请求参数（FireFox/Chrome）</h2><p>在向网站发送请求的时候，服务器会对访问用户进行标识，以cookie的形式存放在浏览器，该浏览器下次进行访问时，则可以跳过登陆直接浏览页面，这是我们模拟知乎登陆的主要目的，获取cookie后，使用cookie访问主页面，则可以跳过登陆。在火狐中，先清掉之前保存的cookie，以模拟浏览器首次访问。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9e6c660f8d81b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"清除火狐cookie\"><br>清除cookie后，试着登陆知乎，发现有验证码，打开F12，一边发请求，一边观察网络中的变化。<br>这里故意输错密码，看看发送了什么请求。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-2679b4d38f31cd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"登陆请求头\"><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-500e37e330a78361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"登陆请求参数\"></p>\n<p>_xsrf的参数是用于防止xsrf攻击，如何防止xsrf攻击，可以参考<a href=\"http://blog.csdn.net/newjueqi/article/details/7542409\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，这是一种简单的恶意链接攻击，可以直接让你访问目标网站并且修改你的密码，所以一般在提交的表单中加个_xsrf参数，只有参数正确才可以进行提交。</p>\n<h2 id=\"2-代码模拟请求\"><a href=\"#2-代码模拟请求\" class=\"headerlink\" title=\"2.代码模拟请求\"></a>2.代码模拟请求</h2><p>可以看到知乎的主要请求参数，还有email,password,captcha,captcha_type。<br>自己试验过，captcha_type可以不用填写，首先还是找到验证码的链接如下：<br><a href=\"https://www.zhihu.com/captcha.gif?r=1503020715890&amp;type=login&amp;lang=cn\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/captcha.gif?r=1503020715890&amp;type=login&amp;lang=cn</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-8a5e858b5322688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"获取验证码的链接\"><br>很明显，中间的数字是以毫秒为单位的时间戳，因此在代码中很容易模拟这个链接去发送请求获取验证码的图片。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_captcha():</span><br><span class=\"line\">    timestamp = str(time.time()*1000).split(&quot;.&quot;)[0]</span><br><span class=\"line\">    url = &quot;https://www.zhihu.com/captcha.gif?r=%s&amp;type=login&amp;lang=cn&quot; % timestamp</span><br><span class=\"line\">    print(url)</span><br><span class=\"line\">    req = session.get(url,headers=headers)</span><br><span class=\"line\">    with open(&quot;img1.png&quot;,&apos;wb&apos;) as f:</span><br><span class=\"line\">        f.write(req.content)</span><br></pre></td></tr></table></figure></p>\n<p>我采用的方式是人工识别，所以把图片以二进制的形式写入文件，自己点开查看。<br>得到的内容是一行汉字：<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-c31e380d68644a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400\" alt=\"知乎验证码\"><br>点击倒立的汉字，获取响应的坐标，放在请求参数中，即可模拟鼠标点击的过程，可以自己点击几个点，大概找到1234567个汉字的坐标，然后根据汉字的个数，匹配响应的坐标点，填入参数中即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_code():</span><br><span class=\"line\">    get_captcha()</span><br><span class=\"line\">    print(&quot;输入倒立汉字的位置，用逗号隔开&quot;)</span><br><span class=\"line\">    a = input(&quot;input:&quot;)</span><br><span class=\"line\">    indexs = a.split(&quot;,&quot;)</span><br><span class=\"line\">    data=[[16.4,26.9],[33.4,26.9],[60.4,21.9],[84.4,24.9],[108.4,24.9],[130.4,24.9],[156.4,24.9]]</span><br><span class=\"line\">    input_points = []</span><br><span class=\"line\">    for idx in indexs:</span><br><span class=\"line\">        input_points.append(data[int(idx)-1])</span><br><span class=\"line\">    dict = &#123;</span><br><span class=\"line\">        &quot;img_size&quot;: [200, 44],</span><br><span class=\"line\">        &quot;input_points&quot;: input_points</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dict</span><br></pre></td></tr></table></figure></p>\n<p>有了xsrf参数和验证码，输入自己的账号密码，即可模拟登录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def login():</span><br><span class=\"line\">    url = &quot;https://www.zhihu.com/login/email&quot;</span><br><span class=\"line\">    data=&#123;</span><br><span class=\"line\">        &quot;_xsrf&quot;:get_xsrf(),</span><br><span class=\"line\">        &quot;email&quot;:&apos;******@qq.com&apos;,</span><br><span class=\"line\">        &quot;password&quot;:&apos;asfgasdfasf&apos;,</span><br><span class=\"line\">        &apos;captcha_type&apos;:get_code()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    response = session.post(url, data=data,headers=headers)</span><br><span class=\"line\">    login_code = response.json()</span><br><span class=\"line\">    print(login_code[&apos;msg&apos;])</span><br><span class=\"line\">    response = session.get(&quot;https://www.zhihu.com/settings/profile&quot;,headers=headers)</span><br><span class=\"line\">    #将cookies-&gt;dict-&gt;json存放在txt|之后再json-&gt;dict直接使用</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;w&apos;) as f:</span><br><span class=\"line\">        json.dump(session.cookies.get_dict(),f)</span><br><span class=\"line\">    with open(&quot;login.html&quot;,&quot;wb&quot;) as f:</span><br><span class=\"line\">        f.write(response.content)</span><br></pre></td></tr></table></figure></p>\n<p>第一次登录结束后，session.cookie会自动保持登录状态的cookie，下一次进行登录时，使用cookie即可，这里进行持久化，暂时写在txt文件中，下次使用时直接从文件获取。<br>这里有个小插曲就是session.cookie的类型是RequestCookie不是dict或者str，这里使用get_dict()方法转化成dict，并用json的形式存在txt文件中，取出来的时候，json可以直接提取成dict，放入session.cookie可以直接使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#将cookies-&gt;dict-&gt;json存放在txt|之后再json-&gt;dict直接使用</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;w&apos;) as f:</span><br><span class=\"line\">        json.dump(session.cookies.get_dict(),f)</span><br><span class=\"line\"></span><br><span class=\"line\">#从txt文件中获取cookies,json-&gt;dict存入session.cookies</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;r&apos;) as f:</span><br><span class=\"line\">        cookies = json.load(f)</span><br><span class=\"line\">    session.cookies.update(cookies)</span><br></pre></td></tr></table></figure></p>\n<p>这里也可以温习下，Python中Json的操作-&gt;<a href=\"http://www.jianshu.com/p/26cb66297a6a\" target=\"_blank\" rel=\"noopener\">链接</a><br>获取cookie后，我尝试登录了(<a href=\"https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。</a></p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>写知乎登录，主要也是练练手，觉得挺有意思，后面可以尝试用phantomjs+selenium模拟下登录爬取，有了登录cookie之后，也可以爬一下知乎的内容，应该有很多有趣的内容，后续会继续更新的，谢谢关注~<br>github上我也上传了代码，欢迎大家点评，学习。<br><a href=\"https://github.com/Fan4J/Spiders-of-frequently-used-website/tree/master/zhihuLogin\" target=\"_blank\" rel=\"noopener\">源码地址</a><br><a href=\"https://fan4j.github.io/\">重塑自我</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>前言：最近看到公众号python之禅里面的历史文章，模拟登录知乎，又看到很多人在网上尝试写代码，自己也想试试，最新的验证码是选择倒立的汉字，本文采用手动输入验证码的形式完成验证，最后获取cookie，存入文件中，之后便可以无需登录直接访问了。<br>所用python的包：requests，BeautifulSoup，json</p>\n</blockquote>\n<p>首先之前使用python请求网页有层出不穷的包，但是用了requests之后才知道它有多方便，详情可以参考这篇文章，也是python之禅公众号的文章，这里帮忙推荐一波—&gt;<a href=\"http://mp.weixin.qq.com/s/gO8E3lXZiL6_ql5rDuHwMQ\" target=\"_blank\" rel=\"noopener\">链接</a>。<br>下面一步步开始讲解如何模拟登录。</p>\n<h2 id=\"1-观察请求参数（FireFox-Chrome）\"><a href=\"#1-观察请求参数（FireFox-Chrome）\" class=\"headerlink\" title=\"1.观察请求参数（FireFox/Chrome）\"></a>1.观察请求参数（FireFox/Chrome）</h2><p>在向网站发送请求的时候，服务器会对访问用户进行标识，以cookie的形式存放在浏览器，该浏览器下次进行访问时，则可以跳过登陆直接浏览页面，这是我们模拟知乎登陆的主要目的，获取cookie后，使用cookie访问主页面，则可以跳过登陆。在火狐中，先清掉之前保存的cookie，以模拟浏览器首次访问。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9e6c660f8d81b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"清除火狐cookie\"><br>清除cookie后，试着登陆知乎，发现有验证码，打开F12，一边发请求，一边观察网络中的变化。<br>这里故意输错密码，看看发送了什么请求。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-2679b4d38f31cd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"登陆请求头\"><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-500e37e330a78361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"登陆请求参数\"></p>\n<p>_xsrf的参数是用于防止xsrf攻击，如何防止xsrf攻击，可以参考<a href=\"http://blog.csdn.net/newjueqi/article/details/7542409\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，这是一种简单的恶意链接攻击，可以直接让你访问目标网站并且修改你的密码，所以一般在提交的表单中加个_xsrf参数，只有参数正确才可以进行提交。</p>\n<h2 id=\"2-代码模拟请求\"><a href=\"#2-代码模拟请求\" class=\"headerlink\" title=\"2.代码模拟请求\"></a>2.代码模拟请求</h2><p>可以看到知乎的主要请求参数，还有email,password,captcha,captcha_type。<br>自己试验过，captcha_type可以不用填写，首先还是找到验证码的链接如下：<br><a href=\"https://www.zhihu.com/captcha.gif?r=1503020715890&amp;type=login&amp;lang=cn\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/captcha.gif?r=1503020715890&amp;type=login&amp;lang=cn</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-8a5e858b5322688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"获取验证码的链接\"><br>很明显，中间的数字是以毫秒为单位的时间戳，因此在代码中很容易模拟这个链接去发送请求获取验证码的图片。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_captcha():</span><br><span class=\"line\">    timestamp = str(time.time()*1000).split(&quot;.&quot;)[0]</span><br><span class=\"line\">    url = &quot;https://www.zhihu.com/captcha.gif?r=%s&amp;type=login&amp;lang=cn&quot; % timestamp</span><br><span class=\"line\">    print(url)</span><br><span class=\"line\">    req = session.get(url,headers=headers)</span><br><span class=\"line\">    with open(&quot;img1.png&quot;,&apos;wb&apos;) as f:</span><br><span class=\"line\">        f.write(req.content)</span><br></pre></td></tr></table></figure></p>\n<p>我采用的方式是人工识别，所以把图片以二进制的形式写入文件，自己点开查看。<br>得到的内容是一行汉字：<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-c31e380d68644a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400\" alt=\"知乎验证码\"><br>点击倒立的汉字，获取响应的坐标，放在请求参数中，即可模拟鼠标点击的过程，可以自己点击几个点，大概找到1234567个汉字的坐标，然后根据汉字的个数，匹配响应的坐标点，填入参数中即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_code():</span><br><span class=\"line\">    get_captcha()</span><br><span class=\"line\">    print(&quot;输入倒立汉字的位置，用逗号隔开&quot;)</span><br><span class=\"line\">    a = input(&quot;input:&quot;)</span><br><span class=\"line\">    indexs = a.split(&quot;,&quot;)</span><br><span class=\"line\">    data=[[16.4,26.9],[33.4,26.9],[60.4,21.9],[84.4,24.9],[108.4,24.9],[130.4,24.9],[156.4,24.9]]</span><br><span class=\"line\">    input_points = []</span><br><span class=\"line\">    for idx in indexs:</span><br><span class=\"line\">        input_points.append(data[int(idx)-1])</span><br><span class=\"line\">    dict = &#123;</span><br><span class=\"line\">        &quot;img_size&quot;: [200, 44],</span><br><span class=\"line\">        &quot;input_points&quot;: input_points</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dict</span><br></pre></td></tr></table></figure></p>\n<p>有了xsrf参数和验证码，输入自己的账号密码，即可模拟登录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def login():</span><br><span class=\"line\">    url = &quot;https://www.zhihu.com/login/email&quot;</span><br><span class=\"line\">    data=&#123;</span><br><span class=\"line\">        &quot;_xsrf&quot;:get_xsrf(),</span><br><span class=\"line\">        &quot;email&quot;:&apos;******@qq.com&apos;,</span><br><span class=\"line\">        &quot;password&quot;:&apos;asfgasdfasf&apos;,</span><br><span class=\"line\">        &apos;captcha_type&apos;:get_code()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    response = session.post(url, data=data,headers=headers)</span><br><span class=\"line\">    login_code = response.json()</span><br><span class=\"line\">    print(login_code[&apos;msg&apos;])</span><br><span class=\"line\">    response = session.get(&quot;https://www.zhihu.com/settings/profile&quot;,headers=headers)</span><br><span class=\"line\">    #将cookies-&gt;dict-&gt;json存放在txt|之后再json-&gt;dict直接使用</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;w&apos;) as f:</span><br><span class=\"line\">        json.dump(session.cookies.get_dict(),f)</span><br><span class=\"line\">    with open(&quot;login.html&quot;,&quot;wb&quot;) as f:</span><br><span class=\"line\">        f.write(response.content)</span><br></pre></td></tr></table></figure></p>\n<p>第一次登录结束后，session.cookie会自动保持登录状态的cookie，下一次进行登录时，使用cookie即可，这里进行持久化，暂时写在txt文件中，下次使用时直接从文件获取。<br>这里有个小插曲就是session.cookie的类型是RequestCookie不是dict或者str，这里使用get_dict()方法转化成dict，并用json的形式存在txt文件中，取出来的时候，json可以直接提取成dict，放入session.cookie可以直接使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#将cookies-&gt;dict-&gt;json存放在txt|之后再json-&gt;dict直接使用</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;w&apos;) as f:</span><br><span class=\"line\">        json.dump(session.cookies.get_dict(),f)</span><br><span class=\"line\"></span><br><span class=\"line\">#从txt文件中获取cookies,json-&gt;dict存入session.cookies</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;r&apos;) as f:</span><br><span class=\"line\">        cookies = json.load(f)</span><br><span class=\"line\">    session.cookies.update(cookies)</span><br></pre></td></tr></table></figure></p>\n<p>这里也可以温习下，Python中Json的操作-&gt;<a href=\"http://www.jianshu.com/p/26cb66297a6a\" target=\"_blank\" rel=\"noopener\">链接</a><br>获取cookie后，我尝试登录了(<a href=\"https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。</a></p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>写知乎登录，主要也是练练手，觉得挺有意思，后面可以尝试用phantomjs+selenium模拟下登录爬取，有了登录cookie之后，也可以爬一下知乎的内容，应该有很多有趣的内容，后续会继续更新的，谢谢关注~<br>github上我也上传了代码，欢迎大家点评，学习。<br><a href=\"https://github.com/Fan4J/Spiders-of-frequently-used-website/tree/master/zhihuLogin\" target=\"_blank\" rel=\"noopener\">源码地址</a><br><a href=\"https://fan4j.github.io/\">重塑自我</a></p>\n"},{"title":"ubuntu之初体验","date":"2018-05-29T06:13:09.000Z","comments":1,"_content":">进来为了研究hadoop,心血来潮的把自己家里pc装了ubuntu.刚开始不太会用,这里记录下一些经验\n\n## 1 软件安装顺序\n1.java jdk 环境变量\n2.python\n3.idea pycharm\n4.搜狗拼音\n5.sublimetext\n6.shutter 暂时不太会用\n\n## 2 安装软件\n通常的方式有yum apt-get 例如\n```\nyum install python3.4\nsudo apt-get python\n```\n如果是yum库和ubuntu软件库没有添加的软件可以下载源码安装\n```\ntar -xf archive.tar\n```\n解压后放在自己熟悉的目录我一般是\n```\nsudo mv ~/Downloads/archive /usr/local/share\n```\n一般我会做两步 1.通过加软链接,实现终端打开软件 2.创建桌面图标,桌面打开 eg\n```\nln -s /usr/local/share/sublime_text_3 /usr/bin/sublime\n```\n完成后在终端的任何地方输入sublime即可打开\n```\ncd  /usr/share/applications\nvi  sublime.desktop\n```\n进入编辑 替换Name为软件的名字 Icon为图标的图片地址 Exec 是执行脚本的位置\n```\n[Desktop Entry]\n\nType=Application\n\nName=SublimeText\n\nIcon=/usr/local/share/sublime_text_3/Icon/256x256/sublime-text.png\n\nExec=/usr/local/share/sublime_text_3/sublime_text\n\nTerminal=false\n\nCategories=Network;InstantMessaging\n```\n完成以后可以在应用程序中看到,点击收藏即可显示在左边侧边栏了\n\n![屏幕截图.png](https://upload-images.jianshu.io/upload_images/5834071-9f2cb874755d2871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3 切换繁体简体\nCtrl+Shift+F\n","source":"_posts/ubuntu之初体验.md","raw":"---\ntitle: ubuntu之初体验\ndate: 2018-05-29 14:13:09\ntags: Linux\ncomments: true\n---\n>进来为了研究hadoop,心血来潮的把自己家里pc装了ubuntu.刚开始不太会用,这里记录下一些经验\n\n## 1 软件安装顺序\n1.java jdk 环境变量\n2.python\n3.idea pycharm\n4.搜狗拼音\n5.sublimetext\n6.shutter 暂时不太会用\n\n## 2 安装软件\n通常的方式有yum apt-get 例如\n```\nyum install python3.4\nsudo apt-get python\n```\n如果是yum库和ubuntu软件库没有添加的软件可以下载源码安装\n```\ntar -xf archive.tar\n```\n解压后放在自己熟悉的目录我一般是\n```\nsudo mv ~/Downloads/archive /usr/local/share\n```\n一般我会做两步 1.通过加软链接,实现终端打开软件 2.创建桌面图标,桌面打开 eg\n```\nln -s /usr/local/share/sublime_text_3 /usr/bin/sublime\n```\n完成后在终端的任何地方输入sublime即可打开\n```\ncd  /usr/share/applications\nvi  sublime.desktop\n```\n进入编辑 替换Name为软件的名字 Icon为图标的图片地址 Exec 是执行脚本的位置\n```\n[Desktop Entry]\n\nType=Application\n\nName=SublimeText\n\nIcon=/usr/local/share/sublime_text_3/Icon/256x256/sublime-text.png\n\nExec=/usr/local/share/sublime_text_3/sublime_text\n\nTerminal=false\n\nCategories=Network;InstantMessaging\n```\n完成以后可以在应用程序中看到,点击收藏即可显示在左边侧边栏了\n\n![屏幕截图.png](https://upload-images.jianshu.io/upload_images/5834071-9f2cb874755d2871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3 切换繁体简体\nCtrl+Shift+F\n","slug":"ubuntu之初体验","published":1,"updated":"2018-05-29T12:26:03.049Z","layout":"post","photos":[],"link":"","_id":"cjhrnqssr000ajd6ims9ceqtv","content":"<blockquote>\n<p>进来为了研究hadoop,心血来潮的把自己家里pc装了ubuntu.刚开始不太会用,这里记录下一些经验</p>\n</blockquote>\n<h2 id=\"1-软件安装顺序\"><a href=\"#1-软件安装顺序\" class=\"headerlink\" title=\"1 软件安装顺序\"></a>1 软件安装顺序</h2><p>1.java jdk 环境变量<br>2.python<br>3.idea pycharm<br>4.搜狗拼音<br>5.sublimetext<br>6.shutter 暂时不太会用</p>\n<h2 id=\"2-安装软件\"><a href=\"#2-安装软件\" class=\"headerlink\" title=\"2 安装软件\"></a>2 安装软件</h2><p>通常的方式有yum apt-get 例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python3.4</span><br><span class=\"line\">sudo apt-get python</span><br></pre></td></tr></table></figure></p>\n<p>如果是yum库和ubuntu软件库没有添加的软件可以下载源码安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf archive.tar</span><br></pre></td></tr></table></figure></p>\n<p>解压后放在自己熟悉的目录我一般是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mv ~/Downloads/archive /usr/local/share</span><br></pre></td></tr></table></figure></p>\n<p>一般我会做两步 1.通过加软链接,实现终端打开软件 2.创建桌面图标,桌面打开 eg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /usr/local/share/sublime_text_3 /usr/bin/sublime</span><br></pre></td></tr></table></figure></p>\n<p>完成后在终端的任何地方输入sublime即可打开<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd  /usr/share/applications</span><br><span class=\"line\">vi  sublime.desktop</span><br></pre></td></tr></table></figure></p>\n<p>进入编辑 替换Name为软件的名字 Icon为图标的图片地址 Exec 是执行脚本的位置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\"></span><br><span class=\"line\">Type=Application</span><br><span class=\"line\"></span><br><span class=\"line\">Name=SublimeText</span><br><span class=\"line\"></span><br><span class=\"line\">Icon=/usr/local/share/sublime_text_3/Icon/256x256/sublime-text.png</span><br><span class=\"line\"></span><br><span class=\"line\">Exec=/usr/local/share/sublime_text_3/sublime_text</span><br><span class=\"line\"></span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\"></span><br><span class=\"line\">Categories=Network;InstantMessaging</span><br></pre></td></tr></table></figure></p>\n<p>完成以后可以在应用程序中看到,点击收藏即可显示在左边侧边栏了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5834071-9f2cb874755d2871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图.png\"></p>\n<h2 id=\"3-切换繁体简体\"><a href=\"#3-切换繁体简体\" class=\"headerlink\" title=\"3 切换繁体简体\"></a>3 切换繁体简体</h2><p>Ctrl+Shift+F</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>进来为了研究hadoop,心血来潮的把自己家里pc装了ubuntu.刚开始不太会用,这里记录下一些经验</p>\n</blockquote>\n<h2 id=\"1-软件安装顺序\"><a href=\"#1-软件安装顺序\" class=\"headerlink\" title=\"1 软件安装顺序\"></a>1 软件安装顺序</h2><p>1.java jdk 环境变量<br>2.python<br>3.idea pycharm<br>4.搜狗拼音<br>5.sublimetext<br>6.shutter 暂时不太会用</p>\n<h2 id=\"2-安装软件\"><a href=\"#2-安装软件\" class=\"headerlink\" title=\"2 安装软件\"></a>2 安装软件</h2><p>通常的方式有yum apt-get 例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python3.4</span><br><span class=\"line\">sudo apt-get python</span><br></pre></td></tr></table></figure></p>\n<p>如果是yum库和ubuntu软件库没有添加的软件可以下载源码安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf archive.tar</span><br></pre></td></tr></table></figure></p>\n<p>解压后放在自己熟悉的目录我一般是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mv ~/Downloads/archive /usr/local/share</span><br></pre></td></tr></table></figure></p>\n<p>一般我会做两步 1.通过加软链接,实现终端打开软件 2.创建桌面图标,桌面打开 eg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /usr/local/share/sublime_text_3 /usr/bin/sublime</span><br></pre></td></tr></table></figure></p>\n<p>完成后在终端的任何地方输入sublime即可打开<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd  /usr/share/applications</span><br><span class=\"line\">vi  sublime.desktop</span><br></pre></td></tr></table></figure></p>\n<p>进入编辑 替换Name为软件的名字 Icon为图标的图片地址 Exec 是执行脚本的位置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\"></span><br><span class=\"line\">Type=Application</span><br><span class=\"line\"></span><br><span class=\"line\">Name=SublimeText</span><br><span class=\"line\"></span><br><span class=\"line\">Icon=/usr/local/share/sublime_text_3/Icon/256x256/sublime-text.png</span><br><span class=\"line\"></span><br><span class=\"line\">Exec=/usr/local/share/sublime_text_3/sublime_text</span><br><span class=\"line\"></span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\"></span><br><span class=\"line\">Categories=Network;InstantMessaging</span><br></pre></td></tr></table></figure></p>\n<p>完成以后可以在应用程序中看到,点击收藏即可显示在左边侧边栏了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5834071-9f2cb874755d2871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图.png\"></p>\n<h2 id=\"3-切换繁体简体\"><a href=\"#3-切换繁体简体\" class=\"headerlink\" title=\"3 切换繁体简体\"></a>3 切换繁体简体</h2><p>Ctrl+Shift+F</p>\n"},{"title":"新的开始","date":"2017-07-24T06:13:09.000Z","comments":1,"_content":"\n```\n勤学，\n\n苦练，\n\n只想赶上，\n\n平行世界，\n\n更好的那个自己，\n\n以此自勉。\n\n```","source":"_posts/第一篇博客.md","raw":"---\ntitle: 新的开始\ndate: 2017-07-24 14:13:09\ntags: \"随笔\"\ncomments: true\n---\n\n```\n勤学，\n\n苦练，\n\n只想赶上，\n\n平行世界，\n\n更好的那个自己，\n\n以此自勉。\n\n```","slug":"第一篇博客","published":1,"updated":"2018-05-29T11:37:20.702Z","layout":"post","photos":[],"link":"","_id":"cjhrnqssv000cjd6ilyefilpc","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">勤学，</span><br><span class=\"line\"></span><br><span class=\"line\">苦练，</span><br><span class=\"line\"></span><br><span class=\"line\">只想赶上，</span><br><span class=\"line\"></span><br><span class=\"line\">平行世界，</span><br><span class=\"line\"></span><br><span class=\"line\">更好的那个自己，</span><br><span class=\"line\"></span><br><span class=\"line\">以此自勉。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">勤学，</span><br><span class=\"line\"></span><br><span class=\"line\">苦练，</span><br><span class=\"line\"></span><br><span class=\"line\">只想赶上，</span><br><span class=\"line\"></span><br><span class=\"line\">平行世界，</span><br><span class=\"line\"></span><br><span class=\"line\">更好的那个自己，</span><br><span class=\"line\"></span><br><span class=\"line\">以此自勉。</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjhrnqsrs0000jd6iwuvxm3p1","tag_id":"cjhrnqss60002jd6i85an0txy","_id":"cjhrnqssu000bjd6io83owep6"},{"post_id":"cjhrnqsrs0000jd6iwuvxm3p1","tag_id":"cjhrnqssl0006jd6ive5lvf2l","_id":"cjhrnqssx000djd6ips89lpk5"},{"post_id":"cjhrnqsrz0001jd6i0z7ynp9m","tag_id":"cjhrnqssr0009jd6ihh7x5zos","_id":"cjhrnqssz000fjd6iu89sqq7k"},{"post_id":"cjhrnqss90003jd6ip3s4nap5","tag_id":"cjhrnqssr0009jd6ihh7x5zos","_id":"cjhrnqst2000jjd6iss7pdru9"},{"post_id":"cjhrnqss90003jd6ip3s4nap5","tag_id":"cjhrnqst0000gjd6ifn8wj4c3","_id":"cjhrnqst3000kjd6ic5arylww"},{"post_id":"cjhrnqss90003jd6ip3s4nap5","tag_id":"cjhrnqst1000hjd6ibvbehy67","_id":"cjhrnqst3000mjd6ijil6iwya"},{"post_id":"cjhrnqsse0004jd6i6frzxtv2","tag_id":"cjhrnqssr0009jd6ihh7x5zos","_id":"cjhrnqst7000pjd6i51cmx28v"},{"post_id":"cjhrnqsse0004jd6i6frzxtv2","tag_id":"cjhrnqst3000ljd6i4gpshtt7","_id":"cjhrnqst7000qjd6io0iqh93v"},{"post_id":"cjhrnqsse0004jd6i6frzxtv2","tag_id":"cjhrnqst4000njd6idliu1xol","_id":"cjhrnqst9000sjd6idiuknbx0"},{"post_id":"cjhrnqssk0005jd6i0o82a7hc","tag_id":"cjhrnqss60002jd6i85an0txy","_id":"cjhrnqst9000tjd6iagsaixzp"},{"post_id":"cjhrnqssk0005jd6i0o82a7hc","tag_id":"cjhrnqssl0006jd6ive5lvf2l","_id":"cjhrnqsta000vjd6ifn86vvw5"},{"post_id":"cjhrnqssn0007jd6idtilx74z","tag_id":"cjhrnqst8000rjd6igi17w97z","_id":"cjhrnqstc000wjd6iisdq4e3h"},{"post_id":"cjhrnqssp0008jd6iicakt5rk","tag_id":"cjhrnqst8000rjd6igi17w97z","_id":"cjhrnqstd000zjd6i5g4clb74"},{"post_id":"cjhrnqssp0008jd6iicakt5rk","tag_id":"cjhrnqstc000xjd6ip3gep2fx","_id":"cjhrnqste0010jd6ifdts8t6a"},{"post_id":"cjhrnqssr000ajd6ims9ceqtv","tag_id":"cjhrnqst0000gjd6ifn8wj4c3","_id":"cjhrnqstg0012jd6iiq5gerw0"},{"post_id":"cjhrnqssv000cjd6ilyefilpc","tag_id":"cjhrnqste0011jd6iv6jw40yy","_id":"cjhrnqstg0013jd6iivy217pm"}],"Tag":[{"name":"技术","_id":"cjhrnqss60002jd6i85an0txy"},{"name":"博客","_id":"cjhrnqssl0006jd6ive5lvf2l"},{"name":"Java","_id":"cjhrnqssr0009jd6ihh7x5zos"},{"name":"Linux","_id":"cjhrnqst0000gjd6ifn8wj4c3"},{"name":"JVM","_id":"cjhrnqst1000hjd6ibvbehy67"},{"name":"Spring","_id":"cjhrnqst3000ljd6i4gpshtt7"},{"name":"Rest","_id":"cjhrnqst4000njd6idliu1xol"},{"name":"Python","_id":"cjhrnqst8000rjd6igi17w97z"},{"name":"知乎","_id":"cjhrnqstc000xjd6ip3gep2fx"},{"name":"随笔","_id":"cjhrnqste0011jd6iv6jw40yy"}]}}