{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/me.jpg","path":"image/me.jpg","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1532963099015},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1532963099015},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1532963099015},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1532963099015},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1532963099016},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1532963099023},{"_id":"source/_posts/Charles进行Https抓包 .md","hash":"a3c80e0fc5ce39d101d9924ca5bdfc2f47122e42","modified":1532963099013},{"_id":"source/_posts/Enum类用法详解.md","hash":"e3c3b58781c22d89266e0dba8986d7906336889c","modified":1532963099013},{"_id":"source/_posts/JAVA应用内存泄漏排查记录.md","hash":"518ebe0a12a6d790f3ea2198d55292defaca6be4","modified":1532963099014},{"_id":"source/_posts/Java关键字之static.md","hash":"ec9d109bb411a7e91ed19f5508183378e3a0636a","modified":1532964017449},{"_id":"source/_posts/SpringBoot实现REST.md","hash":"56a622a81588636803f1437a6fba1ba44e5fb883","modified":1532963099014},{"_id":"source/_posts/how-to-build-this-blog.md","hash":"42e1a53f9d82b1d6263870d5a4ec62d585f791bb","modified":1532963099014},{"_id":"source/_posts/python-json.md","hash":"9d76dbe7e713aba2e4ce3cff123cb01f87ee26f7","modified":1532963099014},{"_id":"source/_posts/python-知乎登录.md","hash":"0cf50bec8f89ed498e93399e0acb75c320f1c969","modified":1532963099014},{"_id":"source/_posts/第一篇博客.md","hash":"d0c8fe132d595d00c220283f3d7774d4129324e0","modified":1532963099015},{"_id":"source/_posts/ubuntu之初体验.md","hash":"db5c1e556be808703346a57b63ed241aefadc7bc","modified":1532963099014},{"_id":"source/image/me.jpg","hash":"1d37dd8a479f1140c4a59218bb31e1a099297fea","modified":1532963099015},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1532963099016},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1532963099016},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1532963099016},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1532963099016},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1532963099016},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1532963099016},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1532963099017},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1532963099017},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1532963099017},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1532963099017},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1532963099017},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1532963099017},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1532963099020},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1532963099021},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1532963099021},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1532963099021},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1532963099023},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1532963099023},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1532963099023},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1532963099023},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1532963099017},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1532963099018},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1532963099018},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1532963099018},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1532963099018},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1532963099018},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1532963099018},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1532963099018},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1532963099019},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1532963099019},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1532963099020},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1532963099020},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1532963099020},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1532963099020},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1532963099020},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1532963099020},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1532963099023},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1532963099025},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1532963099030},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1532963099030},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1532963099030},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1532963099030},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1532963099030},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1532963099030},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1532963099031},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1532963099032},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1532963099032},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1532963099032},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1532963099032},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1532963099019},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1532963099019},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1532963099019},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1532963099019},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1532963099019},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1532963099020},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1532963099024},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1532963099024},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1532963099024},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1532963099024},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1532963099024},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1532963099024},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1532963099024},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1532963099025},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1532963099025},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1532963099025},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1532963099025},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1532963099025},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1532963099026},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1532963099026},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1532963099028},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1532963099031},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1532963099031},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1532963099031},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1532963099031},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1532963099031},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1532963099031},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1532963099028},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1532963099027},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1532963099029},{"_id":"public/content.json","hash":"914301739165e5957e55f29f1063ab2615170874","modified":1563161840182},{"_id":"public/2018/05/29/ubuntu之初体验/index.html","hash":"cf9767a8b7b37ccb20a446b7c0920a3ae28a796e","modified":1563161840290},{"_id":"public/2017/08/18/python-json/index.html","hash":"cd4629c151da4d6cb099603f0ce0d222ef49f48a","modified":1563161840290},{"_id":"public/2017/07/24/第一篇博客/index.html","hash":"cca83ce7247cde4e98bc93f5f11c12a34f482863","modified":1563161840290},{"_id":"public/archives/index.html","hash":"909741e0898a311ef54376388131b5e6f32d02fa","modified":1563161840290},{"_id":"public/archives/2017/index.html","hash":"b31881829314215413386c7b3a511961145e99b4","modified":1563161840290},{"_id":"public/archives/2017/07/index.html","hash":"2b65341e9d45c9dc6560558ab479769b6fceeadc","modified":1563161840290},{"_id":"public/archives/2017/08/index.html","hash":"b47d7afe100332c6e8c1a2a915a859cea144db45","modified":1563161840291},{"_id":"public/archives/2017/10/index.html","hash":"06465448cc8c09f636d0d87bbc5419886c143d94","modified":1563161840291},{"_id":"public/archives/2018/index.html","hash":"2f7ca1bdf26f7c92f8332747dbe66a8319d8f583","modified":1563161840291},{"_id":"public/archives/2018/05/index.html","hash":"bb7f872f22ed55fd15cc8d928abf9516638f26d0","modified":1563161840291},{"_id":"public/archives/2018/07/index.html","hash":"6305016263a2397b6c6875e0a377ed77db9d9551","modified":1563161840291},{"_id":"public/tags/技术/index.html","hash":"9dd77a614844158b01606bae7de3199bcc840d35","modified":1563161840291},{"_id":"public/tags/博客/index.html","hash":"31abb2096891e1a0f380ac8fa5b9bba6f8015dd3","modified":1563161840291},{"_id":"public/tags/Java/index.html","hash":"69ad03087056c3bd41f77826481f234d27e3dd56","modified":1563161840291},{"_id":"public/tags/Linux/index.html","hash":"ca738acca7e3784b7fac9de5a1ef0558c61282f1","modified":1563161840291},{"_id":"public/tags/JVM/index.html","hash":"d1872c0615d2120adbc46f05594f19ba88b8d852","modified":1563161840291},{"_id":"public/tags/Python/index.html","hash":"f4a28fba8a39f38238ca9076ced012a6c9de5757","modified":1563161840291},{"_id":"public/tags/知乎/index.html","hash":"d30520158eaed1df5d13ca4f7b5fecd1920f6c98","modified":1563161840291},{"_id":"public/tags/随笔/index.html","hash":"61a17bbd761d1f5cbf023f90c775a2d2559e6cb3","modified":1563161840292},{"_id":"public/tags/Spring/index.html","hash":"6c3a036cf47be7cd888e9946d83be8490786e385","modified":1563161840292},{"_id":"public/tags/Rest/index.html","hash":"23f4164a8fb8093b024a5ebac3c9ef81e4d7f0f9","modified":1563161840292},{"_id":"public/2018/07/30/Java关键字之static/index.html","hash":"28d5ba0d22e40dd74df77e32493eb8d586db3b06","modified":1563161840292},{"_id":"public/2017/10/25/SpringBoot实现REST/index.html","hash":"a27f84c7120bc2ae89cc36bcae73e79b22c69b29","modified":1563161840292},{"_id":"public/2017/10/24/Enum类用法详解/index.html","hash":"aebdb2625c87343e489b0de59354b8d60c506661","modified":1563161840292},{"_id":"public/2017/10/20/JAVA应用内存泄漏排查记录/index.html","hash":"de396f2596013a6c7357ccda231d0e48fda2c85e","modified":1563161840292},{"_id":"public/2017/10/10/Charles进行Https抓包 /index.html","hash":"6f5e7dfd30e5569b766a7d031e41d7c831228049","modified":1563161840292},{"_id":"public/2017/08/18/python-知乎登录/index.html","hash":"596b8a9a43e99ddce1928c958e2567fb9ba4d90e","modified":1563161840292},{"_id":"public/2017/07/25/how-to-build-this-blog/index.html","hash":"4e90f16359b61d0f7d26f95aaedc82f5804d404e","modified":1563161840292},{"_id":"public/index.html","hash":"365dce660e180fa6ecc7206b8000a00564ccb248","modified":1563161840292},{"_id":"public/image/me.jpg","hash":"1d37dd8a479f1140c4a59218bb31e1a099297fea","modified":1563161840296},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1563161840296},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1563161840296},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1563161840296},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1563161840296},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1563161840296},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1563161840296},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1563161840296},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1563161840296},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1563161840296},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1563161840633},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1563161840634},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1563161840639},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1563161840639},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1563161840639},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1563161840639},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1563161840639},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1563161840639},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1563161840639},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1563161840639},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1563161840646},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1563161840646},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1563161840650},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1563161840658}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Charles进行Htpps抓包","date":"2017-10-10T01:04:14.000Z","_content":">今天在公司打开电脑发现没法登陆Https的网站，知乎百度等，github也上不了，后来查看了自己电脑的代理设置发现代理还开着，原来是蓝灯开机启动直接挂着代理，发现本地还在用Charles代理，研究了下，Charles代理相当于从本地的localhost:8888地址发送请求，如果遇到Http协议的网站，可以直接解析获取数据，遇到Https的网站，无法获取数据包，特此研究一下。\n\n## 1.Charles抓包原理和设置\n\n![Paste_Image.png](http://upload-images.jianshu.io/upload_images/5834071-b1a503f7f689ad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这段话已经清晰的解释了Charles抓包SSL协议的原理，这里首先要回顾下SSL协议请求的原理\n\n![Charles SSL Proxy](http://upload-images.jianshu.io/upload_images/5834071-75935e4d3196cc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上面这张图来源是简书里的另外一篇文章，简单的说客户端向服务端发送请求后，服务端会把自己的证书给客户端看，客户端信任了证书（公钥）之后，通过握手将协商密钥通过公钥加密发送，服务端用私钥解密并校验消息长度并返回给客户端，客户端校验消息长度一致完成后建立连接，双方开始用协商秘钥通过对称加密（比非对称加密速度快）。\nCharles抓Https包的原理就是Charles做中间人，Charles信任远程网站的证书（比如百度https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图\n![初始情况.png](http://upload-images.jianshu.io/upload_images/5834071-203446fcfff97edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n此时Charles没法获取https的数据包，这时设置一下Charles的SSL代理配置，加入www.baidu.com,https的端口号默认为443，加入后再次访问，\n\n![修改CharlesProxy后.png](http://upload-images.jianshu.io/upload_images/5834071-214ebc94f86c2600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![访问百度.png](http://upload-images.jianshu.io/upload_images/5834071-9cacf508ab47e7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时发现可以访问，不过进入网址时会提示是否信任证书，点击继续访问，才会出现如下数据包，里面是进入百度的一些请求，浏览器上可以看到访问风险的图标，点开可以看到是Charles信任baidu的一个证书。\n![证书.png](http://upload-images.jianshu.io/upload_images/5834071-a2faa8183b561283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n浏览器中可以导入证书，信任Charles的根证书之后，正常情况下访问https相应的网站就不会有问题，同时还可以愉快的进行抓包。\n\n## 2. 如何用手机配合Charles抓api\n手机app可以很方便进行抓包，charles/help/SSLProxying下面有个install CA on remote device，点开如下\n![charles](http://upload-images.jianshu.io/upload_images/5834071-6f355164f58db1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这里的Ip实际就是本机在局域网的ip和端口号，这些可以在cmd/ipconfig里面查看，打开手机，设置手机和电脑连接同一个网络，在网络下设置手动代理，proxy地址即为该提示的地址，保存网络\n![网络设置.png](http://upload-images.jianshu.io/upload_images/5834071-9273352b0d1160d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时在手机上点开weibo，电脑上的charles即可看到请求，但是无法抓包，全是unknow，在SSL中添加api.weibo.cn:443，发现同样无法抓包。因为手机上要安装Charles根证书。本人用的是红米，在charles点击保存整数，保存为.pem格式（.cer格式证书无法读取），然后在手机上，wifi/高级设置/安装证书 通过文件查找到这个.pem的证书，起名CharlesProxy，即可。\n再次点开微博，到电脑端查看，如下：\n![微博抓包.png](http://upload-images.jianshu.io/upload_images/5834071-b5c214af6d3f9f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这样就可以看到我们想要的api了，少量的爬取些数据都是ok的。\n\n## 3.关于.cer/.pem有什么区别\n在charles保存CA证书的时候，会发现两种格式，其实这两个文件都是证书，我的手机只能识别.pem的，当然也有些是可以识别.cer的，只是编码的方式不同。证书的作用也是在握手环节用于进行加密，建立连接。\n![save.png](http://upload-images.jianshu.io/upload_images/5834071-8f53d4398cd7bfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[参考文章](http://www.jianshu.com/p/870451cb4eb0)\n[个人博客](https://fan4j.github.io/) 欢迎访问~","source":"_posts/Charles进行Https抓包 .md","raw":"---\ntitle: Charles进行Htpps抓包\ndate: 2017-10-10 09:04:14\ntags: \n\t- 技术\n\t- 博客\n\n---\n>今天在公司打开电脑发现没法登陆Https的网站，知乎百度等，github也上不了，后来查看了自己电脑的代理设置发现代理还开着，原来是蓝灯开机启动直接挂着代理，发现本地还在用Charles代理，研究了下，Charles代理相当于从本地的localhost:8888地址发送请求，如果遇到Http协议的网站，可以直接解析获取数据，遇到Https的网站，无法获取数据包，特此研究一下。\n\n## 1.Charles抓包原理和设置\n\n![Paste_Image.png](http://upload-images.jianshu.io/upload_images/5834071-b1a503f7f689ad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这段话已经清晰的解释了Charles抓包SSL协议的原理，这里首先要回顾下SSL协议请求的原理\n\n![Charles SSL Proxy](http://upload-images.jianshu.io/upload_images/5834071-75935e4d3196cc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上面这张图来源是简书里的另外一篇文章，简单的说客户端向服务端发送请求后，服务端会把自己的证书给客户端看，客户端信任了证书（公钥）之后，通过握手将协商密钥通过公钥加密发送，服务端用私钥解密并校验消息长度并返回给客户端，客户端校验消息长度一致完成后建立连接，双方开始用协商秘钥通过对称加密（比非对称加密速度快）。\nCharles抓Https包的原理就是Charles做中间人，Charles信任远程网站的证书（比如百度https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图\n![初始情况.png](http://upload-images.jianshu.io/upload_images/5834071-203446fcfff97edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n此时Charles没法获取https的数据包，这时设置一下Charles的SSL代理配置，加入www.baidu.com,https的端口号默认为443，加入后再次访问，\n\n![修改CharlesProxy后.png](http://upload-images.jianshu.io/upload_images/5834071-214ebc94f86c2600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![访问百度.png](http://upload-images.jianshu.io/upload_images/5834071-9cacf508ab47e7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时发现可以访问，不过进入网址时会提示是否信任证书，点击继续访问，才会出现如下数据包，里面是进入百度的一些请求，浏览器上可以看到访问风险的图标，点开可以看到是Charles信任baidu的一个证书。\n![证书.png](http://upload-images.jianshu.io/upload_images/5834071-a2faa8183b561283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n浏览器中可以导入证书，信任Charles的根证书之后，正常情况下访问https相应的网站就不会有问题，同时还可以愉快的进行抓包。\n\n## 2. 如何用手机配合Charles抓api\n手机app可以很方便进行抓包，charles/help/SSLProxying下面有个install CA on remote device，点开如下\n![charles](http://upload-images.jianshu.io/upload_images/5834071-6f355164f58db1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这里的Ip实际就是本机在局域网的ip和端口号，这些可以在cmd/ipconfig里面查看，打开手机，设置手机和电脑连接同一个网络，在网络下设置手动代理，proxy地址即为该提示的地址，保存网络\n![网络设置.png](http://upload-images.jianshu.io/upload_images/5834071-9273352b0d1160d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时在手机上点开weibo，电脑上的charles即可看到请求，但是无法抓包，全是unknow，在SSL中添加api.weibo.cn:443，发现同样无法抓包。因为手机上要安装Charles根证书。本人用的是红米，在charles点击保存整数，保存为.pem格式（.cer格式证书无法读取），然后在手机上，wifi/高级设置/安装证书 通过文件查找到这个.pem的证书，起名CharlesProxy，即可。\n再次点开微博，到电脑端查看，如下：\n![微博抓包.png](http://upload-images.jianshu.io/upload_images/5834071-b5c214af6d3f9f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这样就可以看到我们想要的api了，少量的爬取些数据都是ok的。\n\n## 3.关于.cer/.pem有什么区别\n在charles保存CA证书的时候，会发现两种格式，其实这两个文件都是证书，我的手机只能识别.pem的，当然也有些是可以识别.cer的，只是编码的方式不同。证书的作用也是在握手环节用于进行加密，建立连接。\n![save.png](http://upload-images.jianshu.io/upload_images/5834071-8f53d4398cd7bfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[参考文章](http://www.jianshu.com/p/870451cb4eb0)\n[个人博客](https://fan4j.github.io/) 欢迎访问~","slug":"Charles进行Https抓包 ","published":1,"updated":"2018-07-30T15:04:59.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy3u76vr0000tgrl07o7u1ro","content":"<blockquote>\n<p>今天在公司打开电脑发现没法登陆Https的网站，知乎百度等，github也上不了，后来查看了自己电脑的代理设置发现代理还开着，原来是蓝灯开机启动直接挂着代理，发现本地还在用Charles代理，研究了下，Charles代理相当于从本地的localhost:8888地址发送请求，如果遇到Http协议的网站，可以直接解析获取数据，遇到Https的网站，无法获取数据包，特此研究一下。</p>\n</blockquote>\n<h2 id=\"1-Charles抓包原理和设置\"><a href=\"#1-Charles抓包原理和设置\" class=\"headerlink\" title=\"1.Charles抓包原理和设置\"></a>1.Charles抓包原理和设置</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-b1a503f7f689ad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></p>\n<p>这段话已经清晰的解释了Charles抓包SSL协议的原理，这里首先要回顾下SSL协议请求的原理</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-75935e4d3196cc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Charles SSL Proxy\"><br>上面这张图来源是简书里的另外一篇文章，简单的说客户端向服务端发送请求后，服务端会把自己的证书给客户端看，客户端信任了证书（公钥）之后，通过握手将协商密钥通过公钥加密发送，服务端用私钥解密并校验消息长度并返回给客户端，客户端校验消息长度一致完成后建立连接，双方开始用协商秘钥通过对称加密（比非对称加密速度快）。<br>Charles抓Https包的原理就是Charles做中间人，Charles信任远程网站的证书（比如百度<a href=\"https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图</a><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-203446fcfff97edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"初始情况.png\"><br>此时Charles没法获取https的数据包，这时设置一下Charles的SSL代理配置，加入<a href=\"http://www.baidu.com,https的端口号默认为443，加入后再次访问，\" target=\"_blank\" rel=\"noopener\">www.baidu.com,https的端口号默认为443，加入后再次访问，</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-214ebc94f86c2600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改CharlesProxy后.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9cacf508ab47e7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"访问百度.png\"><br>这时发现可以访问，不过进入网址时会提示是否信任证书，点击继续访问，才会出现如下数据包，里面是进入百度的一些请求，浏览器上可以看到访问风险的图标，点开可以看到是Charles信任baidu的一个证书。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-a2faa8183b561283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"证书.png\"><br>浏览器中可以导入证书，信任Charles的根证书之后，正常情况下访问https相应的网站就不会有问题，同时还可以愉快的进行抓包。</p>\n<h2 id=\"2-如何用手机配合Charles抓api\"><a href=\"#2-如何用手机配合Charles抓api\" class=\"headerlink\" title=\"2. 如何用手机配合Charles抓api\"></a>2. 如何用手机配合Charles抓api</h2><p>手机app可以很方便进行抓包，charles/help/SSLProxying下面有个install CA on remote device，点开如下<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-6f355164f58db1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"charles\"><br>这里的Ip实际就是本机在局域网的ip和端口号，这些可以在cmd/ipconfig里面查看，打开手机，设置手机和电脑连接同一个网络，在网络下设置手动代理，proxy地址即为该提示的地址，保存网络<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9273352b0d1160d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网络设置.png\"><br>这时在手机上点开weibo，电脑上的charles即可看到请求，但是无法抓包，全是unknow，在SSL中添加api.weibo.cn:443，发现同样无法抓包。因为手机上要安装Charles根证书。本人用的是红米，在charles点击保存整数，保存为.pem格式（.cer格式证书无法读取），然后在手机上，wifi/高级设置/安装证书 通过文件查找到这个.pem的证书，起名CharlesProxy，即可。<br>再次点开微博，到电脑端查看，如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-b5c214af6d3f9f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博抓包.png\"><br>这样就可以看到我们想要的api了，少量的爬取些数据都是ok的。</p>\n<h2 id=\"3-关于-cer-pem有什么区别\"><a href=\"#3-关于-cer-pem有什么区别\" class=\"headerlink\" title=\"3.关于.cer/.pem有什么区别\"></a>3.关于.cer/.pem有什么区别</h2><p>在charles保存CA证书的时候，会发现两种格式，其实这两个文件都是证书，我的手机只能识别.pem的，当然也有些是可以识别.cer的，只是编码的方式不同。证书的作用也是在握手环节用于进行加密，建立连接。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-8f53d4398cd7bfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"save.png\"></p>\n<p><a href=\"http://www.jianshu.com/p/870451cb4eb0\" target=\"_blank\" rel=\"noopener\">参考文章</a><br><a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">个人博客</a> 欢迎访问~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>今天在公司打开电脑发现没法登陆Https的网站，知乎百度等，github也上不了，后来查看了自己电脑的代理设置发现代理还开着，原来是蓝灯开机启动直接挂着代理，发现本地还在用Charles代理，研究了下，Charles代理相当于从本地的localhost:8888地址发送请求，如果遇到Http协议的网站，可以直接解析获取数据，遇到Https的网站，无法获取数据包，特此研究一下。</p>\n</blockquote>\n<h2 id=\"1-Charles抓包原理和设置\"><a href=\"#1-Charles抓包原理和设置\" class=\"headerlink\" title=\"1.Charles抓包原理和设置\"></a>1.Charles抓包原理和设置</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-b1a503f7f689ad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></p>\n<p>这段话已经清晰的解释了Charles抓包SSL协议的原理，这里首先要回顾下SSL协议请求的原理</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-75935e4d3196cc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Charles SSL Proxy\"><br>上面这张图来源是简书里的另外一篇文章，简单的说客户端向服务端发送请求后，服务端会把自己的证书给客户端看，客户端信任了证书（公钥）之后，通过握手将协商密钥通过公钥加密发送，服务端用私钥解密并校验消息长度并返回给客户端，客户端校验消息长度一致完成后建立连接，双方开始用协商秘钥通过对称加密（比非对称加密速度快）。<br>Charles抓Https包的原理就是Charles做中间人，Charles信任远程网站的证书（比如百度<a href=\"https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com）,本地信任Charles的证书，然后本地发送的请求先和Charles建立连接，Charles再和百度建立连接进行请求，间接的获取了通信的数据。如果不经过任何设置，打开Charles，如下图</a><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-203446fcfff97edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"初始情况.png\"><br>此时Charles没法获取https的数据包，这时设置一下Charles的SSL代理配置，加入<a href=\"http://www.baidu.com,https的端口号默认为443，加入后再次访问，\" target=\"_blank\" rel=\"noopener\">www.baidu.com,https的端口号默认为443，加入后再次访问，</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-214ebc94f86c2600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改CharlesProxy后.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9cacf508ab47e7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"访问百度.png\"><br>这时发现可以访问，不过进入网址时会提示是否信任证书，点击继续访问，才会出现如下数据包，里面是进入百度的一些请求，浏览器上可以看到访问风险的图标，点开可以看到是Charles信任baidu的一个证书。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-a2faa8183b561283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"证书.png\"><br>浏览器中可以导入证书，信任Charles的根证书之后，正常情况下访问https相应的网站就不会有问题，同时还可以愉快的进行抓包。</p>\n<h2 id=\"2-如何用手机配合Charles抓api\"><a href=\"#2-如何用手机配合Charles抓api\" class=\"headerlink\" title=\"2. 如何用手机配合Charles抓api\"></a>2. 如何用手机配合Charles抓api</h2><p>手机app可以很方便进行抓包，charles/help/SSLProxying下面有个install CA on remote device，点开如下<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-6f355164f58db1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"charles\"><br>这里的Ip实际就是本机在局域网的ip和端口号，这些可以在cmd/ipconfig里面查看，打开手机，设置手机和电脑连接同一个网络，在网络下设置手动代理，proxy地址即为该提示的地址，保存网络<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9273352b0d1160d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网络设置.png\"><br>这时在手机上点开weibo，电脑上的charles即可看到请求，但是无法抓包，全是unknow，在SSL中添加api.weibo.cn:443，发现同样无法抓包。因为手机上要安装Charles根证书。本人用的是红米，在charles点击保存整数，保存为.pem格式（.cer格式证书无法读取），然后在手机上，wifi/高级设置/安装证书 通过文件查找到这个.pem的证书，起名CharlesProxy，即可。<br>再次点开微博，到电脑端查看，如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-b5c214af6d3f9f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"微博抓包.png\"><br>这样就可以看到我们想要的api了，少量的爬取些数据都是ok的。</p>\n<h2 id=\"3-关于-cer-pem有什么区别\"><a href=\"#3-关于-cer-pem有什么区别\" class=\"headerlink\" title=\"3.关于.cer/.pem有什么区别\"></a>3.关于.cer/.pem有什么区别</h2><p>在charles保存CA证书的时候，会发现两种格式，其实这两个文件都是证书，我的手机只能识别.pem的，当然也有些是可以识别.cer的，只是编码的方式不同。证书的作用也是在握手环节用于进行加密，建立连接。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-8f53d4398cd7bfa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"save.png\"></p>\n<p><a href=\"http://www.jianshu.com/p/870451cb4eb0\" target=\"_blank\" rel=\"noopener\">参考文章</a><br><a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">个人博客</a> 欢迎访问~</p>\n"},{"title":"Enum类使用详解","date":"2017-10-24T09:26:09.000Z","comments":1,"_content":"\n>今天自己研究RestApi，其中对请求的响应结果封装成Result类，Result类里面又是三个参数,int类型的code,String类型的message,和object类型的data,其中code是枚举类封装的，特此学习一下，枚举类还是很有用的。\n\n## 1.项目代码中对响应code的封装\n先上代码\n```\npublic enum ResultCode {\n    SUCCESS(200),//成功\n    FAIL(400),//失败\n    UNAUTHORIZED(401),//未认证（签名错误）\n    NOT_FOUND(404),//接口不存在\n    INTERNAL_SERVER_ERROR(500);//服务器内部错误\n\n    int code;\n\n    ResultCode(int code) {\n        this.code = code;\n    }\n}\n```\n枚举类的应用场景：通常用来列举一个类型的有限实例集合，例如颜色，日期，代码等等。\njava.object包下的Enum可以用idea查看下源码，下面有很多子类，如下\n\n![Enum子类.png](http://upload-images.jianshu.io/upload_images/5834071-08cf731d9b97b188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n随便打开一个，都是enum枚举类，代表着各种适合枚举的实例\n\n![MemoryType.png](http://upload-images.jianshu.io/upload_images/5834071-cba8a47b0d36207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n对我们项目中的ResultCode类进行编译，然后反编译，如下：\n```\njavac ResultCode.java #编译得到.class文件\njavap ResultCode.class #反编译\n```\n结果如下\n```\nCompiled from \"ResultCode.java\"\npublic final class ResultCode extends java.lang.Enum<ResultCode> {\n  public static final ResultCode SUCCESS;\n  public static final ResultCode FAIL;\n  public static final ResultCode UNAUTHORIZED;\n  public static final ResultCode NOT_FOUND;\n  public static final ResultCode INTERNAL_SERVER_ERROR;\n  int code;\n  public static ResultCode[] values();\n  public static ResultCode valueOf(java.lang.String);\n  static {};\n}\n```\n可以看到编译后的enum类其实是一个final的class，而且默认集成了java.lang.Enum，因此任何enum类是不能被继承，也不能再继承其他类的。通过这个可以看出，枚举类中包含N个该枚举类的静态的final实例。\n\n## 2 简单的enum类\n```\npublic enum Week {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\n\n```\n在一个TestClass里\n\n![Enum方法.png](http://upload-images.jianshu.io/upload_images/5834071-ec4dcbf913e2ff2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\npublic static void main(String[] args) {\n        Week week = Week.FRI;\n        System.out.println(week.ordinal());\n        System.out.println(week.compareTo(Week.THU));\n        System.out.println(week.name());\n        System.out.println(Week.valueOf(\"FRI\"));\n        System.out.println(Week.values());\n    }\n```\n输出如下\n```\n5\n1\nFRI\nFRI\n[Lcom.j4fan.JiCheng.Week;@2b193f2d\n```\n其中.ordinal()方法是输出枚举类该对象的下标，compareTo()方法也很简单，直接使用下标进行比较\n源码如下，都比较简单。name()和toString()方法都是返回name，因此结果也是一样的，都是该对象的name，还有个静态方法values()，返回该enum下所有的静态实例，是个隐式的方法。\n![compareTo方法.png](http://upload-images.jianshu.io/upload_images/5834071-5bce54d91e0929ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![values()](http://upload-images.jianshu.io/upload_images/5834071-a929957c51713e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3.带有变量的enum类\n先上代码\n```\npublic enum Weekdays {\n    SUN(0), MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6);\n    int value;\n\n    Weekdays(int value) {\n        this.value = value;\n    }\n\n    public static Weekdays getNextDay(Weekdays day) {\n        if (day.value == 6) {\n            return Weekdays.SUN;\n        } else {\n            return getWeekDaysByValue(day.value + 1);\n        }\n    }\n\n    public static Weekdays getWeekDaysByValue(int value) {\n        for (Weekdays c : Weekdays.values()) {\n            if (c.value == value) {\n                return c;\n            }\n        }\n        return null;\n    }\n}\n```\n用法还是很简单的，其次变量可以更加丰富，比如code+message，只需进行封装即可；\n```\npublic enum WeekNote {\n    MON(0,\"work\"),\n    TUE(1,\"play\"),\n    WED(2,\"talk\"),\n    THU(3,\"learn\"),\n    FRI(4,\"read\"),\n    SAT(5,\"laugh\"),\n    SUN(6,\"greet\");\n\n    int code;\n    String message;\n\n    WeekNote(int code,String message){\n        this.code = code;\n        this.message = message;\n    }\n}\n```\n\n## 4.向enum类中添加方法\n其实enum可以对属性加上get/set方法，这里我产生了疑问，既然每个enum实例是final类型的，为什么还可以set呢，这里我做了个实验\n```\npublic class TestClass {\n    private static final User user = new User(\"fan\",\"male\");\n\n    public static void setName(String s) {\n        user.setName(s);\n    }\n\n    public User getUser(){\n        return user;\n    }\n\n    public static void main(String[] args) {\n        TestClass t = new TestClass();\n        t.setName(\"jiang\");\n        System.out.println(t.getUser().getName());\n    }\n}\n```\n这里在方法内部new一个final对象，运行结果证明确实属性被修改了，查找资料，发现我对final的理解有误，对于变量来说，是指不可修改，对于对象来说，是对象的引用不可修改，以后一定要注意。\n\n## 5.enum的其他用法\nenum类虽然是继承了Enum方法，但是还是可以实现其他接口的，因此可以在enum类中加入其他的接口，添加对应的实现。偷懒贴段别人的代码\n```\npublic interface Behaviour {  \n    void print();  \n    String getInfo();  \n}  \npublic enum Color implements Behaviour{  \n    RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n    // 成员变量  \n    private String name;  \n    private int index;  \n    // 构造方法  \n    private Color(String name, int index) {  \n        this.name = name;  \n        this.index = index;  \n    }  \n//接口方法  \n    @Override  \n    public String getInfo() {  \n        return this.name;  \n    }  \n    //接口方法  \n    @Override  \n    public void print() {  \n        System.out.println(this.index+\":\"+this.name);  \n    }  \n}  \n```\n## 总结\nenum枚举类在项目中应用还是挺多的，其实它可以用一个常量类代替，常量类里面都是private static final类型的静态变量，但是容易出现有的朋友调用没有的变量，或者传入一个非主流的code，导致特殊的异常，enum还是有用武之地的。弄完这些，继续去研究restapi了，撤~\n[个人博客](https://fan4j.github.io/)欢迎访问","source":"_posts/Enum类用法详解.md","raw":"---\ntitle: Enum类使用详解\ndate: 2017-10-24 17:26:09\ntags: \n\t- Java\ncomments: true\n---\n\n>今天自己研究RestApi，其中对请求的响应结果封装成Result类，Result类里面又是三个参数,int类型的code,String类型的message,和object类型的data,其中code是枚举类封装的，特此学习一下，枚举类还是很有用的。\n\n## 1.项目代码中对响应code的封装\n先上代码\n```\npublic enum ResultCode {\n    SUCCESS(200),//成功\n    FAIL(400),//失败\n    UNAUTHORIZED(401),//未认证（签名错误）\n    NOT_FOUND(404),//接口不存在\n    INTERNAL_SERVER_ERROR(500);//服务器内部错误\n\n    int code;\n\n    ResultCode(int code) {\n        this.code = code;\n    }\n}\n```\n枚举类的应用场景：通常用来列举一个类型的有限实例集合，例如颜色，日期，代码等等。\njava.object包下的Enum可以用idea查看下源码，下面有很多子类，如下\n\n![Enum子类.png](http://upload-images.jianshu.io/upload_images/5834071-08cf731d9b97b188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n随便打开一个，都是enum枚举类，代表着各种适合枚举的实例\n\n![MemoryType.png](http://upload-images.jianshu.io/upload_images/5834071-cba8a47b0d36207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n对我们项目中的ResultCode类进行编译，然后反编译，如下：\n```\njavac ResultCode.java #编译得到.class文件\njavap ResultCode.class #反编译\n```\n结果如下\n```\nCompiled from \"ResultCode.java\"\npublic final class ResultCode extends java.lang.Enum<ResultCode> {\n  public static final ResultCode SUCCESS;\n  public static final ResultCode FAIL;\n  public static final ResultCode UNAUTHORIZED;\n  public static final ResultCode NOT_FOUND;\n  public static final ResultCode INTERNAL_SERVER_ERROR;\n  int code;\n  public static ResultCode[] values();\n  public static ResultCode valueOf(java.lang.String);\n  static {};\n}\n```\n可以看到编译后的enum类其实是一个final的class，而且默认集成了java.lang.Enum，因此任何enum类是不能被继承，也不能再继承其他类的。通过这个可以看出，枚举类中包含N个该枚举类的静态的final实例。\n\n## 2 简单的enum类\n```\npublic enum Week {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\n\n```\n在一个TestClass里\n\n![Enum方法.png](http://upload-images.jianshu.io/upload_images/5834071-ec4dcbf913e2ff2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\npublic static void main(String[] args) {\n        Week week = Week.FRI;\n        System.out.println(week.ordinal());\n        System.out.println(week.compareTo(Week.THU));\n        System.out.println(week.name());\n        System.out.println(Week.valueOf(\"FRI\"));\n        System.out.println(Week.values());\n    }\n```\n输出如下\n```\n5\n1\nFRI\nFRI\n[Lcom.j4fan.JiCheng.Week;@2b193f2d\n```\n其中.ordinal()方法是输出枚举类该对象的下标，compareTo()方法也很简单，直接使用下标进行比较\n源码如下，都比较简单。name()和toString()方法都是返回name，因此结果也是一样的，都是该对象的name，还有个静态方法values()，返回该enum下所有的静态实例，是个隐式的方法。\n![compareTo方法.png](http://upload-images.jianshu.io/upload_images/5834071-5bce54d91e0929ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![values()](http://upload-images.jianshu.io/upload_images/5834071-a929957c51713e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3.带有变量的enum类\n先上代码\n```\npublic enum Weekdays {\n    SUN(0), MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6);\n    int value;\n\n    Weekdays(int value) {\n        this.value = value;\n    }\n\n    public static Weekdays getNextDay(Weekdays day) {\n        if (day.value == 6) {\n            return Weekdays.SUN;\n        } else {\n            return getWeekDaysByValue(day.value + 1);\n        }\n    }\n\n    public static Weekdays getWeekDaysByValue(int value) {\n        for (Weekdays c : Weekdays.values()) {\n            if (c.value == value) {\n                return c;\n            }\n        }\n        return null;\n    }\n}\n```\n用法还是很简单的，其次变量可以更加丰富，比如code+message，只需进行封装即可；\n```\npublic enum WeekNote {\n    MON(0,\"work\"),\n    TUE(1,\"play\"),\n    WED(2,\"talk\"),\n    THU(3,\"learn\"),\n    FRI(4,\"read\"),\n    SAT(5,\"laugh\"),\n    SUN(6,\"greet\");\n\n    int code;\n    String message;\n\n    WeekNote(int code,String message){\n        this.code = code;\n        this.message = message;\n    }\n}\n```\n\n## 4.向enum类中添加方法\n其实enum可以对属性加上get/set方法，这里我产生了疑问，既然每个enum实例是final类型的，为什么还可以set呢，这里我做了个实验\n```\npublic class TestClass {\n    private static final User user = new User(\"fan\",\"male\");\n\n    public static void setName(String s) {\n        user.setName(s);\n    }\n\n    public User getUser(){\n        return user;\n    }\n\n    public static void main(String[] args) {\n        TestClass t = new TestClass();\n        t.setName(\"jiang\");\n        System.out.println(t.getUser().getName());\n    }\n}\n```\n这里在方法内部new一个final对象，运行结果证明确实属性被修改了，查找资料，发现我对final的理解有误，对于变量来说，是指不可修改，对于对象来说，是对象的引用不可修改，以后一定要注意。\n\n## 5.enum的其他用法\nenum类虽然是继承了Enum方法，但是还是可以实现其他接口的，因此可以在enum类中加入其他的接口，添加对应的实现。偷懒贴段别人的代码\n```\npublic interface Behaviour {  \n    void print();  \n    String getInfo();  \n}  \npublic enum Color implements Behaviour{  \n    RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);  \n    // 成员变量  \n    private String name;  \n    private int index;  \n    // 构造方法  \n    private Color(String name, int index) {  \n        this.name = name;  \n        this.index = index;  \n    }  \n//接口方法  \n    @Override  \n    public String getInfo() {  \n        return this.name;  \n    }  \n    //接口方法  \n    @Override  \n    public void print() {  \n        System.out.println(this.index+\":\"+this.name);  \n    }  \n}  \n```\n## 总结\nenum枚举类在项目中应用还是挺多的，其实它可以用一个常量类代替，常量类里面都是private static final类型的静态变量，但是容易出现有的朋友调用没有的变量，或者传入一个非主流的code，导致特殊的异常，enum还是有用武之地的。弄完这些，继续去研究restapi了，撤~\n[个人博客](https://fan4j.github.io/)欢迎访问","slug":"Enum类用法详解","published":1,"updated":"2018-07-30T15:04:59.013Z","layout":"post","photos":[],"link":"","_id":"cjy3u76vx0001tgrlgr1fq6h9","content":"<blockquote>\n<p>今天自己研究RestApi，其中对请求的响应结果封装成Result类，Result类里面又是三个参数,int类型的code,String类型的message,和object类型的data,其中code是枚举类封装的，特此学习一下，枚举类还是很有用的。</p>\n</blockquote>\n<h2 id=\"1-项目代码中对响应code的封装\"><a href=\"#1-项目代码中对响应code的封装\" class=\"headerlink\" title=\"1.项目代码中对响应code的封装\"></a>1.项目代码中对响应code的封装</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum ResultCode &#123;</span><br><span class=\"line\">    SUCCESS(200),//成功</span><br><span class=\"line\">    FAIL(400),//失败</span><br><span class=\"line\">    UNAUTHORIZED(401),//未认证（签名错误）</span><br><span class=\"line\">    NOT_FOUND(404),//接口不存在</span><br><span class=\"line\">    INTERNAL_SERVER_ERROR(500);//服务器内部错误</span><br><span class=\"line\"></span><br><span class=\"line\">    int code;</span><br><span class=\"line\"></span><br><span class=\"line\">    ResultCode(int code) &#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>枚举类的应用场景：通常用来列举一个类型的有限实例集合，例如颜色，日期，代码等等。<br>java.object包下的Enum可以用idea查看下源码，下面有很多子类，如下</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-08cf731d9b97b188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Enum子类.png\"><br>随便打开一个，都是enum枚举类，代表着各种适合枚举的实例</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-cba8a47b0d36207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MemoryType.png\"><br>对我们项目中的ResultCode类进行编译，然后反编译，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac ResultCode.java #编译得到.class文件</span><br><span class=\"line\">javap ResultCode.class #反编译</span><br></pre></td></tr></table></figure></p>\n<p>结果如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from &quot;ResultCode.java&quot;</span><br><span class=\"line\">public final class ResultCode extends java.lang.Enum&lt;ResultCode&gt; &#123;</span><br><span class=\"line\">  public static final ResultCode SUCCESS;</span><br><span class=\"line\">  public static final ResultCode FAIL;</span><br><span class=\"line\">  public static final ResultCode UNAUTHORIZED;</span><br><span class=\"line\">  public static final ResultCode NOT_FOUND;</span><br><span class=\"line\">  public static final ResultCode INTERNAL_SERVER_ERROR;</span><br><span class=\"line\">  int code;</span><br><span class=\"line\">  public static ResultCode[] values();</span><br><span class=\"line\">  public static ResultCode valueOf(java.lang.String);</span><br><span class=\"line\">  static &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到编译后的enum类其实是一个final的class，而且默认集成了java.lang.Enum，因此任何enum类是不能被继承，也不能再继承其他类的。通过这个可以看出，枚举类中包含N个该枚举类的静态的final实例。</p>\n<h2 id=\"2-简单的enum类\"><a href=\"#2-简单的enum类\" class=\"headerlink\" title=\"2 简单的enum类\"></a>2 简单的enum类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Week &#123;</span><br><span class=\"line\">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在一个TestClass里</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-ec4dcbf913e2ff2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Enum方法.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        Week week = Week.FRI;</span><br><span class=\"line\">        System.out.println(week.ordinal());</span><br><span class=\"line\">        System.out.println(week.compareTo(Week.THU));</span><br><span class=\"line\">        System.out.println(week.name());</span><br><span class=\"line\">        System.out.println(Week.valueOf(&quot;FRI&quot;));</span><br><span class=\"line\">        System.out.println(Week.values());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1</span><br><span class=\"line\">FRI</span><br><span class=\"line\">FRI</span><br><span class=\"line\">[Lcom.j4fan.JiCheng.Week;@2b193f2d</span><br></pre></td></tr></table></figure></p>\n<p>其中.ordinal()方法是输出枚举类该对象的下标，compareTo()方法也很简单，直接使用下标进行比较<br>源码如下，都比较简单。name()和toString()方法都是返回name，因此结果也是一样的，都是该对象的name，还有个静态方法values()，返回该enum下所有的静态实例，是个隐式的方法。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-5bce54d91e0929ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"compareTo方法.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-a929957c51713e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"values()\"></p>\n<h2 id=\"3-带有变量的enum类\"><a href=\"#3-带有变量的enum类\" class=\"headerlink\" title=\"3.带有变量的enum类\"></a>3.带有变量的enum类</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Weekdays &#123;</span><br><span class=\"line\">    SUN(0), MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6);</span><br><span class=\"line\">    int value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Weekdays(int value) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Weekdays getNextDay(Weekdays day) &#123;</span><br><span class=\"line\">        if (day.value == 6) &#123;</span><br><span class=\"line\">            return Weekdays.SUN;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return getWeekDaysByValue(day.value + 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Weekdays getWeekDaysByValue(int value) &#123;</span><br><span class=\"line\">        for (Weekdays c : Weekdays.values()) &#123;</span><br><span class=\"line\">            if (c.value == value) &#123;</span><br><span class=\"line\">                return c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用法还是很简单的，其次变量可以更加丰富，比如code+message，只需进行封装即可；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum WeekNote &#123;</span><br><span class=\"line\">    MON(0,&quot;work&quot;),</span><br><span class=\"line\">    TUE(1,&quot;play&quot;),</span><br><span class=\"line\">    WED(2,&quot;talk&quot;),</span><br><span class=\"line\">    THU(3,&quot;learn&quot;),</span><br><span class=\"line\">    FRI(4,&quot;read&quot;),</span><br><span class=\"line\">    SAT(5,&quot;laugh&quot;),</span><br><span class=\"line\">    SUN(6,&quot;greet&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    int code;</span><br><span class=\"line\">    String message;</span><br><span class=\"line\"></span><br><span class=\"line\">    WeekNote(int code,String message)&#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">        this.message = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-向enum类中添加方法\"><a href=\"#4-向enum类中添加方法\" class=\"headerlink\" title=\"4.向enum类中添加方法\"></a>4.向enum类中添加方法</h2><p>其实enum可以对属性加上get/set方法，这里我产生了疑问，既然每个enum实例是final类型的，为什么还可以set呢，这里我做了个实验<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestClass &#123;</span><br><span class=\"line\">    private static final User user = new User(&quot;fan&quot;,&quot;male&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void setName(String s) &#123;</span><br><span class=\"line\">        user.setName(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User getUser()&#123;</span><br><span class=\"line\">        return user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        TestClass t = new TestClass();</span><br><span class=\"line\">        t.setName(&quot;jiang&quot;);</span><br><span class=\"line\">        System.out.println(t.getUser().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里在方法内部new一个final对象，运行结果证明确实属性被修改了，查找资料，发现我对final的理解有误，对于变量来说，是指不可修改，对于对象来说，是对象的引用不可修改，以后一定要注意。</p>\n<h2 id=\"5-enum的其他用法\"><a href=\"#5-enum的其他用法\" class=\"headerlink\" title=\"5.enum的其他用法\"></a>5.enum的其他用法</h2><p>enum类虽然是继承了Enum方法，但是还是可以实现其他接口的，因此可以在enum类中加入其他的接口，添加对应的实现。偷懒贴段别人的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Behaviour &#123;  </span><br><span class=\"line\">    void print();  </span><br><span class=\"line\">    String getInfo();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public enum Color implements Behaviour&#123;  </span><br><span class=\"line\">    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class=\"line\">    // 成员变量  </span><br><span class=\"line\">    private String name;  </span><br><span class=\"line\">    private int index;  </span><br><span class=\"line\">    // 构造方法  </span><br><span class=\"line\">    private Color(String name, int index) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.index = index;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">//接口方法  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String getInfo() &#123;  </span><br><span class=\"line\">        return this.name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    //接口方法  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void print() &#123;  </span><br><span class=\"line\">        System.out.println(this.index+&quot;:&quot;+this.name);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>enum枚举类在项目中应用还是挺多的，其实它可以用一个常量类代替，常量类里面都是private static final类型的静态变量，但是容易出现有的朋友调用没有的变量，或者传入一个非主流的code，导致特殊的异常，enum还是有用武之地的。弄完这些，继续去研究restapi了，撤~<br><a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">个人博客</a>欢迎访问</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>今天自己研究RestApi，其中对请求的响应结果封装成Result类，Result类里面又是三个参数,int类型的code,String类型的message,和object类型的data,其中code是枚举类封装的，特此学习一下，枚举类还是很有用的。</p>\n</blockquote>\n<h2 id=\"1-项目代码中对响应code的封装\"><a href=\"#1-项目代码中对响应code的封装\" class=\"headerlink\" title=\"1.项目代码中对响应code的封装\"></a>1.项目代码中对响应code的封装</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum ResultCode &#123;</span><br><span class=\"line\">    SUCCESS(200),//成功</span><br><span class=\"line\">    FAIL(400),//失败</span><br><span class=\"line\">    UNAUTHORIZED(401),//未认证（签名错误）</span><br><span class=\"line\">    NOT_FOUND(404),//接口不存在</span><br><span class=\"line\">    INTERNAL_SERVER_ERROR(500);//服务器内部错误</span><br><span class=\"line\"></span><br><span class=\"line\">    int code;</span><br><span class=\"line\"></span><br><span class=\"line\">    ResultCode(int code) &#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>枚举类的应用场景：通常用来列举一个类型的有限实例集合，例如颜色，日期，代码等等。<br>java.object包下的Enum可以用idea查看下源码，下面有很多子类，如下</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-08cf731d9b97b188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Enum子类.png\"><br>随便打开一个，都是enum枚举类，代表着各种适合枚举的实例</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-cba8a47b0d36207b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MemoryType.png\"><br>对我们项目中的ResultCode类进行编译，然后反编译，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac ResultCode.java #编译得到.class文件</span><br><span class=\"line\">javap ResultCode.class #反编译</span><br></pre></td></tr></table></figure></p>\n<p>结果如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from &quot;ResultCode.java&quot;</span><br><span class=\"line\">public final class ResultCode extends java.lang.Enum&lt;ResultCode&gt; &#123;</span><br><span class=\"line\">  public static final ResultCode SUCCESS;</span><br><span class=\"line\">  public static final ResultCode FAIL;</span><br><span class=\"line\">  public static final ResultCode UNAUTHORIZED;</span><br><span class=\"line\">  public static final ResultCode NOT_FOUND;</span><br><span class=\"line\">  public static final ResultCode INTERNAL_SERVER_ERROR;</span><br><span class=\"line\">  int code;</span><br><span class=\"line\">  public static ResultCode[] values();</span><br><span class=\"line\">  public static ResultCode valueOf(java.lang.String);</span><br><span class=\"line\">  static &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到编译后的enum类其实是一个final的class，而且默认集成了java.lang.Enum，因此任何enum类是不能被继承，也不能再继承其他类的。通过这个可以看出，枚举类中包含N个该枚举类的静态的final实例。</p>\n<h2 id=\"2-简单的enum类\"><a href=\"#2-简单的enum类\" class=\"headerlink\" title=\"2 简单的enum类\"></a>2 简单的enum类</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Week &#123;</span><br><span class=\"line\">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在一个TestClass里</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-ec4dcbf913e2ff2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Enum方法.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        Week week = Week.FRI;</span><br><span class=\"line\">        System.out.println(week.ordinal());</span><br><span class=\"line\">        System.out.println(week.compareTo(Week.THU));</span><br><span class=\"line\">        System.out.println(week.name());</span><br><span class=\"line\">        System.out.println(Week.valueOf(&quot;FRI&quot;));</span><br><span class=\"line\">        System.out.println(Week.values());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1</span><br><span class=\"line\">FRI</span><br><span class=\"line\">FRI</span><br><span class=\"line\">[Lcom.j4fan.JiCheng.Week;@2b193f2d</span><br></pre></td></tr></table></figure></p>\n<p>其中.ordinal()方法是输出枚举类该对象的下标，compareTo()方法也很简单，直接使用下标进行比较<br>源码如下，都比较简单。name()和toString()方法都是返回name，因此结果也是一样的，都是该对象的name，还有个静态方法values()，返回该enum下所有的静态实例，是个隐式的方法。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-5bce54d91e0929ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"compareTo方法.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-a929957c51713e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"values()\"></p>\n<h2 id=\"3-带有变量的enum类\"><a href=\"#3-带有变量的enum类\" class=\"headerlink\" title=\"3.带有变量的enum类\"></a>3.带有变量的enum类</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Weekdays &#123;</span><br><span class=\"line\">    SUN(0), MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6);</span><br><span class=\"line\">    int value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Weekdays(int value) &#123;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Weekdays getNextDay(Weekdays day) &#123;</span><br><span class=\"line\">        if (day.value == 6) &#123;</span><br><span class=\"line\">            return Weekdays.SUN;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return getWeekDaysByValue(day.value + 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static Weekdays getWeekDaysByValue(int value) &#123;</span><br><span class=\"line\">        for (Weekdays c : Weekdays.values()) &#123;</span><br><span class=\"line\">            if (c.value == value) &#123;</span><br><span class=\"line\">                return c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用法还是很简单的，其次变量可以更加丰富，比如code+message，只需进行封装即可；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum WeekNote &#123;</span><br><span class=\"line\">    MON(0,&quot;work&quot;),</span><br><span class=\"line\">    TUE(1,&quot;play&quot;),</span><br><span class=\"line\">    WED(2,&quot;talk&quot;),</span><br><span class=\"line\">    THU(3,&quot;learn&quot;),</span><br><span class=\"line\">    FRI(4,&quot;read&quot;),</span><br><span class=\"line\">    SAT(5,&quot;laugh&quot;),</span><br><span class=\"line\">    SUN(6,&quot;greet&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    int code;</span><br><span class=\"line\">    String message;</span><br><span class=\"line\"></span><br><span class=\"line\">    WeekNote(int code,String message)&#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">        this.message = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-向enum类中添加方法\"><a href=\"#4-向enum类中添加方法\" class=\"headerlink\" title=\"4.向enum类中添加方法\"></a>4.向enum类中添加方法</h2><p>其实enum可以对属性加上get/set方法，这里我产生了疑问，既然每个enum实例是final类型的，为什么还可以set呢，这里我做了个实验<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestClass &#123;</span><br><span class=\"line\">    private static final User user = new User(&quot;fan&quot;,&quot;male&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void setName(String s) &#123;</span><br><span class=\"line\">        user.setName(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User getUser()&#123;</span><br><span class=\"line\">        return user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        TestClass t = new TestClass();</span><br><span class=\"line\">        t.setName(&quot;jiang&quot;);</span><br><span class=\"line\">        System.out.println(t.getUser().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里在方法内部new一个final对象，运行结果证明确实属性被修改了，查找资料，发现我对final的理解有误，对于变量来说，是指不可修改，对于对象来说，是对象的引用不可修改，以后一定要注意。</p>\n<h2 id=\"5-enum的其他用法\"><a href=\"#5-enum的其他用法\" class=\"headerlink\" title=\"5.enum的其他用法\"></a>5.enum的其他用法</h2><p>enum类虽然是继承了Enum方法，但是还是可以实现其他接口的，因此可以在enum类中加入其他的接口，添加对应的实现。偷懒贴段别人的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Behaviour &#123;  </span><br><span class=\"line\">    void print();  </span><br><span class=\"line\">    String getInfo();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">public enum Color implements Behaviour&#123;  </span><br><span class=\"line\">    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class=\"line\">    // 成员变量  </span><br><span class=\"line\">    private String name;  </span><br><span class=\"line\">    private int index;  </span><br><span class=\"line\">    // 构造方法  </span><br><span class=\"line\">    private Color(String name, int index) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.index = index;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">//接口方法  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String getInfo() &#123;  </span><br><span class=\"line\">        return this.name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    //接口方法  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void print() &#123;  </span><br><span class=\"line\">        System.out.println(this.index+&quot;:&quot;+this.name);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>enum枚举类在项目中应用还是挺多的，其实它可以用一个常量类代替，常量类里面都是private static final类型的静态变量，但是容易出现有的朋友调用没有的变量，或者传入一个非主流的code，导致特殊的异常，enum还是有用武之地的。弄完这些，继续去研究restapi了，撤~<br><a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">个人博客</a>欢迎访问</p>\n"},{"title":"JAVA应用内存泄漏排查记录","date":"2017-10-20T02:21:00.000Z","comments":1,"_content":">最近公司的一台服务器频繁报警，老大让我研究下代码出了什么问题，咋一看才知道代码是用大名鼎鼎的异步框架Vert.x写的，本文记录本菜鸟排查问题的辛酸过程，仅作为以后的一点经验参考。本服务器阿里云双核ECS实例，2G内存，CentOS7系统。\n\n## 1.查看服务器硬盘内存状况\n```\ntop #查看服务器内存和硬盘容量\n\n```\n![top](http://upload-images.jianshu.io/upload_images/5834071-261a02461a048ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n看了下参数，以为这些挺重要的，其实发现CPU和Mem都很正常，内存看似要用完了，其实free+buffers+cached大概容量也有900M，完全够用。\n\n## 2.查看服务器进程的堆栈\n```\njcmd #查看进程，发现有两个java项目，一个是公司的web项目，另一个是报警的Vertx项目\njinfo [pid] 查看堆内存，发现一个项目的内存参数-Xms1450M，本项目采用的默认配置，暂时看不出分配多少内存\nor ps aux | grep tomcat | grep -v grep  查看初始内存使用\njstack [pid] 看栈信息，发现很多歌vert.thread在等待，因为服务器相应缓慢，看了下Log，看到了NPE\n```\n初步分析，NullPointerException导致了服务器相应缓慢。\n首先调查，为什么会NullPointerException,根据Log很容易找到原因，最后配合前端同事知道新版本的前端请求格式不对造成报错。\n那么问题来了，报错为什么会导致应用相应缓慢。可能是连接没有释放，或者是持久层插入错误数据报错没有释放连接。\n\n## 3 查看进程具体内存\n```\njinfo [pid] 查看到初始化的配置 \n```\n看到Vertx最大堆内存300M,old区只有50M，这个我很纳闷，照理说默认配置新生区和old区比例是1:2起码也有200M,这样不会oom吗。\n```\njmap -heap [pid] 查看堆内存各个分区大小,old区使用率90%以上，如果加大Old，如果还不行，肯定是内存泄漏了，就是对象没有释放。\njstat -gcutil [pid] 1s 发现最近发生了6次FGC old区依然降不下去\n```\n果然过了一天，log就出现了heap Out Of Memory.\n\n## 4 尝试增加虚拟机内存分配\njavaweb项目部署在tomcat下,系统为它分配了1450M的内存，打开tomcat/bin/catalina.sh，修改\n```\nJAVA_OPTS= -Xms1000M -Xmx1000M，这里保证初始分配内存和最大堆内存相同，放置系统调整内存空间产生的消耗。\n```\n同时给报警的Vertx项目增加内存，\n```\njava -Xms700M -Xmx700M -jar >>t.log 2>&1 & 将标准输出重定向\n参数说明如下\n-Xms 初始化对内存\n-Xmx 最大堆内存\n-Xss每个线程内存\n-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64\n-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4\n```\n重启项目后，过一段时间继续查看\n```\njmap -heap [pid] 发现堆内存Old区飙升，还是达到了90%\n```\n## 5 查看代码，检查内存泄漏位置\n```\njstat -gcutil [pid] 60000  查看从程序启动到现在进行了多少FGC,查看下old区百分比\njmap -histo:live [pid] >f 打印堆内存存活对象信息\nvi f\n```\n通过查看对象信息，从上往下发现有个对象EventItem被实例化了10w+次，这个类里面包含的数组，对象数组响应实例化次数也和其他不在同一数量级。确定是这个问题，回到代码中，我找到了初始化该对象的位置，应该是报错之后，request没有释放，request里面的private对象UploadRequest没有释放，导致错误的EventItem也无法释放。\n于是我在出错的try.catch语句中直接将整个请求return,因为这些数据其实都是些无效的数据，直接return也可以节约不少开销。\n\n## 后续观察\n修改代码后，重新发布，已近观察3天，出错项目的heap的old区使用率终于降下来了，dump了对象信息也没有大量的EventItem，服务器运行终于正常，说明问题解决了。这个过程中经历了一些坑，比如错误的以为是另外一个项目影响造成，浪费了不少时间排查，不过学到不少东西。\njinfo/jmap/jstat这些命令是调优时候常用的，dump出文件查看对象信息，jconsole监控本地jvm运行状况，通过修改jvm参数调整服务响应时间等等。\n代码没有贴出来，具体信息也没细说，因为涉及公司项目还是保密为好，文章就留着以后回顾下吧。","source":"_posts/JAVA应用内存泄漏排查记录.md","raw":"---\ntitle: JAVA应用内存泄漏排查记录\ndate: 2017-10-20 10:21:00\ntags: \n\t- Java\n\t- Linux\n\t- JVM\ncomments: true\n---\n>最近公司的一台服务器频繁报警，老大让我研究下代码出了什么问题，咋一看才知道代码是用大名鼎鼎的异步框架Vert.x写的，本文记录本菜鸟排查问题的辛酸过程，仅作为以后的一点经验参考。本服务器阿里云双核ECS实例，2G内存，CentOS7系统。\n\n## 1.查看服务器硬盘内存状况\n```\ntop #查看服务器内存和硬盘容量\n\n```\n![top](http://upload-images.jianshu.io/upload_images/5834071-261a02461a048ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n看了下参数，以为这些挺重要的，其实发现CPU和Mem都很正常，内存看似要用完了，其实free+buffers+cached大概容量也有900M，完全够用。\n\n## 2.查看服务器进程的堆栈\n```\njcmd #查看进程，发现有两个java项目，一个是公司的web项目，另一个是报警的Vertx项目\njinfo [pid] 查看堆内存，发现一个项目的内存参数-Xms1450M，本项目采用的默认配置，暂时看不出分配多少内存\nor ps aux | grep tomcat | grep -v grep  查看初始内存使用\njstack [pid] 看栈信息，发现很多歌vert.thread在等待，因为服务器相应缓慢，看了下Log，看到了NPE\n```\n初步分析，NullPointerException导致了服务器相应缓慢。\n首先调查，为什么会NullPointerException,根据Log很容易找到原因，最后配合前端同事知道新版本的前端请求格式不对造成报错。\n那么问题来了，报错为什么会导致应用相应缓慢。可能是连接没有释放，或者是持久层插入错误数据报错没有释放连接。\n\n## 3 查看进程具体内存\n```\njinfo [pid] 查看到初始化的配置 \n```\n看到Vertx最大堆内存300M,old区只有50M，这个我很纳闷，照理说默认配置新生区和old区比例是1:2起码也有200M,这样不会oom吗。\n```\njmap -heap [pid] 查看堆内存各个分区大小,old区使用率90%以上，如果加大Old，如果还不行，肯定是内存泄漏了，就是对象没有释放。\njstat -gcutil [pid] 1s 发现最近发生了6次FGC old区依然降不下去\n```\n果然过了一天，log就出现了heap Out Of Memory.\n\n## 4 尝试增加虚拟机内存分配\njavaweb项目部署在tomcat下,系统为它分配了1450M的内存，打开tomcat/bin/catalina.sh，修改\n```\nJAVA_OPTS= -Xms1000M -Xmx1000M，这里保证初始分配内存和最大堆内存相同，放置系统调整内存空间产生的消耗。\n```\n同时给报警的Vertx项目增加内存，\n```\njava -Xms700M -Xmx700M -jar >>t.log 2>&1 & 将标准输出重定向\n参数说明如下\n-Xms 初始化对内存\n-Xmx 最大堆内存\n-Xss每个线程内存\n-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64\n-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4\n```\n重启项目后，过一段时间继续查看\n```\njmap -heap [pid] 发现堆内存Old区飙升，还是达到了90%\n```\n## 5 查看代码，检查内存泄漏位置\n```\njstat -gcutil [pid] 60000  查看从程序启动到现在进行了多少FGC,查看下old区百分比\njmap -histo:live [pid] >f 打印堆内存存活对象信息\nvi f\n```\n通过查看对象信息，从上往下发现有个对象EventItem被实例化了10w+次，这个类里面包含的数组，对象数组响应实例化次数也和其他不在同一数量级。确定是这个问题，回到代码中，我找到了初始化该对象的位置，应该是报错之后，request没有释放，request里面的private对象UploadRequest没有释放，导致错误的EventItem也无法释放。\n于是我在出错的try.catch语句中直接将整个请求return,因为这些数据其实都是些无效的数据，直接return也可以节约不少开销。\n\n## 后续观察\n修改代码后，重新发布，已近观察3天，出错项目的heap的old区使用率终于降下来了，dump了对象信息也没有大量的EventItem，服务器运行终于正常，说明问题解决了。这个过程中经历了一些坑，比如错误的以为是另外一个项目影响造成，浪费了不少时间排查，不过学到不少东西。\njinfo/jmap/jstat这些命令是调优时候常用的，dump出文件查看对象信息，jconsole监控本地jvm运行状况，通过修改jvm参数调整服务响应时间等等。\n代码没有贴出来，具体信息也没细说，因为涉及公司项目还是保密为好，文章就留着以后回顾下吧。","slug":"JAVA应用内存泄漏排查记录","published":1,"updated":"2018-07-30T15:04:59.014Z","layout":"post","photos":[],"link":"","_id":"cjy3u76w00003tgrlu54sqjsc","content":"<blockquote>\n<p>最近公司的一台服务器频繁报警，老大让我研究下代码出了什么问题，咋一看才知道代码是用大名鼎鼎的异步框架Vert.x写的，本文记录本菜鸟排查问题的辛酸过程，仅作为以后的一点经验参考。本服务器阿里云双核ECS实例，2G内存，CentOS7系统。</p>\n</blockquote>\n<h2 id=\"1-查看服务器硬盘内存状况\"><a href=\"#1-查看服务器硬盘内存状况\" class=\"headerlink\" title=\"1.查看服务器硬盘内存状况\"></a>1.查看服务器硬盘内存状况</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top #查看服务器内存和硬盘容量</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-261a02461a048ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"top\"><br>看了下参数，以为这些挺重要的，其实发现CPU和Mem都很正常，内存看似要用完了，其实free+buffers+cached大概容量也有900M，完全够用。</p>\n<h2 id=\"2-查看服务器进程的堆栈\"><a href=\"#2-查看服务器进程的堆栈\" class=\"headerlink\" title=\"2.查看服务器进程的堆栈\"></a>2.查看服务器进程的堆栈</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jcmd #查看进程，发现有两个java项目，一个是公司的web项目，另一个是报警的Vertx项目</span><br><span class=\"line\">jinfo [pid] 查看堆内存，发现一个项目的内存参数-Xms1450M，本项目采用的默认配置，暂时看不出分配多少内存</span><br><span class=\"line\">or ps aux | grep tomcat | grep -v grep  查看初始内存使用</span><br><span class=\"line\">jstack [pid] 看栈信息，发现很多歌vert.thread在等待，因为服务器相应缓慢，看了下Log，看到了NPE</span><br></pre></td></tr></table></figure>\n<p>初步分析，NullPointerException导致了服务器相应缓慢。<br>首先调查，为什么会NullPointerException,根据Log很容易找到原因，最后配合前端同事知道新版本的前端请求格式不对造成报错。<br>那么问题来了，报错为什么会导致应用相应缓慢。可能是连接没有释放，或者是持久层插入错误数据报错没有释放连接。</p>\n<h2 id=\"3-查看进程具体内存\"><a href=\"#3-查看进程具体内存\" class=\"headerlink\" title=\"3 查看进程具体内存\"></a>3 查看进程具体内存</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [pid] 查看到初始化的配置</span><br></pre></td></tr></table></figure>\n<p>看到Vertx最大堆内存300M,old区只有50M，这个我很纳闷，照理说默认配置新生区和old区比例是1:2起码也有200M,这样不会oom吗。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap [pid] 查看堆内存各个分区大小,old区使用率90%以上，如果加大Old，如果还不行，肯定是内存泄漏了，就是对象没有释放。</span><br><span class=\"line\">jstat -gcutil [pid] 1s 发现最近发生了6次FGC old区依然降不下去</span><br></pre></td></tr></table></figure></p>\n<p>果然过了一天，log就出现了heap Out Of Memory.</p>\n<h2 id=\"4-尝试增加虚拟机内存分配\"><a href=\"#4-尝试增加虚拟机内存分配\" class=\"headerlink\" title=\"4 尝试增加虚拟机内存分配\"></a>4 尝试增加虚拟机内存分配</h2><p>javaweb项目部署在tomcat下,系统为它分配了1450M的内存，打开tomcat/bin/catalina.sh，修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_OPTS= -Xms1000M -Xmx1000M，这里保证初始分配内存和最大堆内存相同，放置系统调整内存空间产生的消耗。</span><br></pre></td></tr></table></figure></p>\n<p>同时给报警的Vertx项目增加内存，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xms700M -Xmx700M -jar &gt;&gt;t.log 2&gt;&amp;1 &amp; 将标准输出重定向</span><br><span class=\"line\">参数说明如下</span><br><span class=\"line\">-Xms 初始化对内存</span><br><span class=\"line\">-Xmx 最大堆内存</span><br><span class=\"line\">-Xss每个线程内存</span><br><span class=\"line\">-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64</span><br><span class=\"line\">-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4</span><br></pre></td></tr></table></figure></p>\n<p>重启项目后，过一段时间继续查看<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap [pid] 发现堆内存Old区飙升，还是达到了90%</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-查看代码，检查内存泄漏位置\"><a href=\"#5-查看代码，检查内存泄漏位置\" class=\"headerlink\" title=\"5 查看代码，检查内存泄漏位置\"></a>5 查看代码，检查内存泄漏位置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -gcutil [pid] 60000  查看从程序启动到现在进行了多少FGC,查看下old区百分比</span><br><span class=\"line\">jmap -histo:live [pid] &gt;f 打印堆内存存活对象信息</span><br><span class=\"line\">vi f</span><br></pre></td></tr></table></figure>\n<p>通过查看对象信息，从上往下发现有个对象EventItem被实例化了10w+次，这个类里面包含的数组，对象数组响应实例化次数也和其他不在同一数量级。确定是这个问题，回到代码中，我找到了初始化该对象的位置，应该是报错之后，request没有释放，request里面的private对象UploadRequest没有释放，导致错误的EventItem也无法释放。<br>于是我在出错的try.catch语句中直接将整个请求return,因为这些数据其实都是些无效的数据，直接return也可以节约不少开销。</p>\n<h2 id=\"后续观察\"><a href=\"#后续观察\" class=\"headerlink\" title=\"后续观察\"></a>后续观察</h2><p>修改代码后，重新发布，已近观察3天，出错项目的heap的old区使用率终于降下来了，dump了对象信息也没有大量的EventItem，服务器运行终于正常，说明问题解决了。这个过程中经历了一些坑，比如错误的以为是另外一个项目影响造成，浪费了不少时间排查，不过学到不少东西。<br>jinfo/jmap/jstat这些命令是调优时候常用的，dump出文件查看对象信息，jconsole监控本地jvm运行状况，通过修改jvm参数调整服务响应时间等等。<br>代码没有贴出来，具体信息也没细说，因为涉及公司项目还是保密为好，文章就留着以后回顾下吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近公司的一台服务器频繁报警，老大让我研究下代码出了什么问题，咋一看才知道代码是用大名鼎鼎的异步框架Vert.x写的，本文记录本菜鸟排查问题的辛酸过程，仅作为以后的一点经验参考。本服务器阿里云双核ECS实例，2G内存，CentOS7系统。</p>\n</blockquote>\n<h2 id=\"1-查看服务器硬盘内存状况\"><a href=\"#1-查看服务器硬盘内存状况\" class=\"headerlink\" title=\"1.查看服务器硬盘内存状况\"></a>1.查看服务器硬盘内存状况</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top #查看服务器内存和硬盘容量</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-261a02461a048ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"top\"><br>看了下参数，以为这些挺重要的，其实发现CPU和Mem都很正常，内存看似要用完了，其实free+buffers+cached大概容量也有900M，完全够用。</p>\n<h2 id=\"2-查看服务器进程的堆栈\"><a href=\"#2-查看服务器进程的堆栈\" class=\"headerlink\" title=\"2.查看服务器进程的堆栈\"></a>2.查看服务器进程的堆栈</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jcmd #查看进程，发现有两个java项目，一个是公司的web项目，另一个是报警的Vertx项目</span><br><span class=\"line\">jinfo [pid] 查看堆内存，发现一个项目的内存参数-Xms1450M，本项目采用的默认配置，暂时看不出分配多少内存</span><br><span class=\"line\">or ps aux | grep tomcat | grep -v grep  查看初始内存使用</span><br><span class=\"line\">jstack [pid] 看栈信息，发现很多歌vert.thread在等待，因为服务器相应缓慢，看了下Log，看到了NPE</span><br></pre></td></tr></table></figure>\n<p>初步分析，NullPointerException导致了服务器相应缓慢。<br>首先调查，为什么会NullPointerException,根据Log很容易找到原因，最后配合前端同事知道新版本的前端请求格式不对造成报错。<br>那么问题来了，报错为什么会导致应用相应缓慢。可能是连接没有释放，或者是持久层插入错误数据报错没有释放连接。</p>\n<h2 id=\"3-查看进程具体内存\"><a href=\"#3-查看进程具体内存\" class=\"headerlink\" title=\"3 查看进程具体内存\"></a>3 查看进程具体内存</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [pid] 查看到初始化的配置</span><br></pre></td></tr></table></figure>\n<p>看到Vertx最大堆内存300M,old区只有50M，这个我很纳闷，照理说默认配置新生区和old区比例是1:2起码也有200M,这样不会oom吗。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap [pid] 查看堆内存各个分区大小,old区使用率90%以上，如果加大Old，如果还不行，肯定是内存泄漏了，就是对象没有释放。</span><br><span class=\"line\">jstat -gcutil [pid] 1s 发现最近发生了6次FGC old区依然降不下去</span><br></pre></td></tr></table></figure></p>\n<p>果然过了一天，log就出现了heap Out Of Memory.</p>\n<h2 id=\"4-尝试增加虚拟机内存分配\"><a href=\"#4-尝试增加虚拟机内存分配\" class=\"headerlink\" title=\"4 尝试增加虚拟机内存分配\"></a>4 尝试增加虚拟机内存分配</h2><p>javaweb项目部署在tomcat下,系统为它分配了1450M的内存，打开tomcat/bin/catalina.sh，修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_OPTS= -Xms1000M -Xmx1000M，这里保证初始分配内存和最大堆内存相同，放置系统调整内存空间产生的消耗。</span><br></pre></td></tr></table></figure></p>\n<p>同时给报警的Vertx项目增加内存，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xms700M -Xmx700M -jar &gt;&gt;t.log 2&gt;&amp;1 &amp; 将标准输出重定向</span><br><span class=\"line\">参数说明如下</span><br><span class=\"line\">-Xms 初始化对内存</span><br><span class=\"line\">-Xmx 最大堆内存</span><br><span class=\"line\">-Xss每个线程内存</span><br><span class=\"line\">-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64</span><br><span class=\"line\">-XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4</span><br></pre></td></tr></table></figure></p>\n<p>重启项目后，过一段时间继续查看<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap [pid] 发现堆内存Old区飙升，还是达到了90%</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-查看代码，检查内存泄漏位置\"><a href=\"#5-查看代码，检查内存泄漏位置\" class=\"headerlink\" title=\"5 查看代码，检查内存泄漏位置\"></a>5 查看代码，检查内存泄漏位置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -gcutil [pid] 60000  查看从程序启动到现在进行了多少FGC,查看下old区百分比</span><br><span class=\"line\">jmap -histo:live [pid] &gt;f 打印堆内存存活对象信息</span><br><span class=\"line\">vi f</span><br></pre></td></tr></table></figure>\n<p>通过查看对象信息，从上往下发现有个对象EventItem被实例化了10w+次，这个类里面包含的数组，对象数组响应实例化次数也和其他不在同一数量级。确定是这个问题，回到代码中，我找到了初始化该对象的位置，应该是报错之后，request没有释放，request里面的private对象UploadRequest没有释放，导致错误的EventItem也无法释放。<br>于是我在出错的try.catch语句中直接将整个请求return,因为这些数据其实都是些无效的数据，直接return也可以节约不少开销。</p>\n<h2 id=\"后续观察\"><a href=\"#后续观察\" class=\"headerlink\" title=\"后续观察\"></a>后续观察</h2><p>修改代码后，重新发布，已近观察3天，出错项目的heap的old区使用率终于降下来了，dump了对象信息也没有大量的EventItem，服务器运行终于正常，说明问题解决了。这个过程中经历了一些坑，比如错误的以为是另外一个项目影响造成，浪费了不少时间排查，不过学到不少东西。<br>jinfo/jmap/jstat这些命令是调优时候常用的，dump出文件查看对象信息，jconsole监控本地jvm运行状况，通过修改jvm参数调整服务响应时间等等。<br>代码没有贴出来，具体信息也没细说，因为涉及公司项目还是保密为好，文章就留着以后回顾下吧。</p>\n"},{"title":"用GithubPages+Hexo搭建漂亮的博客","date":"2017-07-25T01:04:14.000Z","_content":">一直以来都想自己搭建博客，作为个人生活和技术的记录，终于在前几天开始动手，一天多时间搭建了自己的个人博客，搭建方式：github+hexo（注：没有绑定个人域名，直接通过github提供的个性链接访问），这种方式可能会在速度上由于github本身的一些原因受到影响，存储空间上其实github没有什么限制，大可放心使用。\n本文主要记录搭建的过程以及遇到的一些坑，仅供大家参考。[浏览博客](https://fan4j.github.io/)\n\n## 1.准备Github,git,nodejs\n第一步，注册github账号，安装git,nodejs\ngithub地址:https://github.com/\ngit下载地址:https://git-scm.com/downloads\nnodejs下载地址:http://nodejs.cn/ \nnodejs的学习可以参考官方文档:http://nodejs.cn/api/\ngit如果不会建议先看廖雪峰的git教程:[点击链接](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n一切就绪后可以在存放代码的目录下打开git bash,确认是否安装成功\n```\ngit\nnode -v\nnpm -v  //最新版的nodejs已经集成了npm包\n```\n## 2.初始化hexo\n依次进行安装hexo,查看是否安装成功，初始化博客，部署，如下\n```\nhexo init hexo  //初始化目录\ncd hexo  //进入目录\nhexo generate  //生成html    \nhexo server  //运行本地服务\n```\n在本地部署完成之后，可以在\nhttp://localhost:4000/\n查看部署效果，目录结构如下：\n```\n├── .deploy       //需要部署的文件\n├── node_modules  //Hexo插件\n├── public        //生成的静态网页文件\n├── scaffolds     //模板\n├── source        //博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里\n|   ├── _drafts   //草稿\n|   └── _posts    //文章\n├── themes        //主题\n├── _config.yml   //全局配置文件\n└── package.json\n```\n## 3.修改_config.yml进行格式修改\n主要配置如下，可以用于参考，需要注意的是yml格式非常严格，冒号后面需要加空格，后面jsContent是为了yilia标签库特效准备的\n```\n# Site\ntitle: 重塑自我\nsubtitle: 当你低头的瞬间，才发现脚下的路\ndescription: 当你低头的瞬间，才发现脚下的路\nauthor: Fan4j\nlanguage: zh-Hans\ntimezone: Asia/Shanghai\n\ndeploy:\n  type: git\n  repo: git@github.com:Fan4J/fan4j.github.io.git\n  branch: master\n  \njsonContent:\n    meta: false\n    pages: false\n    posts:\n      title: true\n      date: true\n      path: true\n      text: false\n      raw: false\n      content: false\n      slug: false\n      updated: false\n      comments: false\n      link: false\n      permalink: false\n      excerpt: false\n      categories: false\n      tags: true\n```\n## 4.修改主题\n进入主题目录下，从github上找自己喜欢的好看的hexo主题，并下载。\nhexo主题地址:https://hexo.io/themes/\n点击到相应的github的主页，找到项目的地址，克隆到本地，比如我的博客使用的很受欢迎的yilia主题，如下\n```\ncd hexo\ncd themes //cd到themes目录下\ngit clone https://github.com/litten/hexo-theme-yilia.git yilia //下载到yilia文件夹\n```\n主题的目录结构如下\n```\n├── languages       //主题的语言包\n├── layout  //主题样式\n├── source       // 资源文件目录，例如图片\n├── source-src     //\n├── _config.yml   //配置文件\n└── package.json\n```\n主要修改在于_config.yml配置\n主要配置节选如下\n```\n# Header\n\nmenu:\n  主页: /\n  随笔: /tags/随笔/\n  技术: /tags/技术/\n  \n# SubNav\nsubnav:\n  github: \"https://github.com/Fan4J\"\n  weibo: \"http://weibo.com/2179165162/profile?topnav=1&wvr=6\"\n  #rss: \"#\"\n  zhihu: \"https://www.zhihu.com/people/storm-spirit/activities\"\n  #qq: \"#\"\n  #weixin: \"#\"\n  jianshu: \"http://www.jianshu.com/u/c4f8f0c4a19f\"\n  #douban: \"#\"\n  #segmentfault: \"#\"\n  #bilibili: \"#\"\n  #acfun: \"#\"\n  #mail: \"fspirit@yeah.net\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\n# 打赏\n# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏\nreward_type: 2\n# 打赏wording\nreward_wording: '多谢支持,一起努力~！'\n# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg\nalipay: /img/payali.jpg\n# 微信二维码图片地址\nweixin: /img/paywechat.jpg\n\n\nsmart_menu:\n  innerArchive: '所有文章'\n  friends: '友链'\n  aboutme: '关于我'\n\nfriends:\n  w3school: http://www.w3school.com.cn/\n  hexo: https://hexo.io/\n  hexo-theme-yilia: https://github.com/litten/hexo-theme-yilia/\n  \n\naboutme: 为了美好生活而拼命努力的普通人\n```\n添加头像既可以用本地的资源路径，记得是theme文件夹下的路径，例如我的图片放在theme/img/目录下\n```\navatar: /img/head.jpg\n```\n打赏的图片同理\n同时对于标签的js-content，需要安装一个包才可不出错，记着是在hexo目录下操作\n```\ncd hexo\nnpm i hexo-generator-json-content --save\n```\n## 5.绑定Github并部署\nGithubPages是指特定命名方式的respository: namespace.github.io,比如我的就是fan4j.github.io\n这样命名的仓库会被自动解析为githubpage,只需在hexo的全局配置文件中正确配置，即可简单部署\n```\nnpm install hexo-deployer-git --save\nnpm deploy \n```\n## 6.发布新文章\n以上内容弄好以后，发布新文章就很轻松了\n```\ncd hexo\nhexo new \"posttitle\"  //会在hexo/source/_posts目录下出现新的文章\n```\n打开文章，添加内容，修改配置，通常打开markdown文件可看到文件头，可以添加相应的文章标签，\n```\ntitle: 用GithubPages+Hexo搭建漂亮的博客\ndate: 2017-07-25 09:04:14\ntags: \n\t- 技术\n\t- 博客\n```\ntags可以继续添加，修改完成后即可开始部署到github服务器\n```\nhexo generate \nhexo deploy\n```\n部署完成，以后用这种方法部署即可\nhexo现在也支持简写，构建过程更加简易\n```\nhexo g == hexo generate\nhexo d == hexo deploy\nhexo s == hexo server\nhexo n == hexo new\n```\n## 7.代码保存，其他配置\n这时打开github可以看到仓库中已经是前端页面的代码，说明部署完毕，访问地址即可-> https://fan4j.github.io/\n同时可以将部署内容保存到新的respository中，可以在多个电脑上进行新文章的发布部署。\n## 8.结束语\n部署结束，中间可能遇到些坑，浪费了些时间，但是都还是可以通过网上搜索获取答案，总体还是觉得很值的，最后套用某人的话，希望不是三分钟热度，一定要把这个博客坚持下去~","source":"_posts/how-to-build-this-blog.md","raw":"---\ntitle: 用GithubPages+Hexo搭建漂亮的博客\ndate: 2017-07-25 09:04:14\ntags: \n\t- 技术\n\t- 博客\n\n---\n>一直以来都想自己搭建博客，作为个人生活和技术的记录，终于在前几天开始动手，一天多时间搭建了自己的个人博客，搭建方式：github+hexo（注：没有绑定个人域名，直接通过github提供的个性链接访问），这种方式可能会在速度上由于github本身的一些原因受到影响，存储空间上其实github没有什么限制，大可放心使用。\n本文主要记录搭建的过程以及遇到的一些坑，仅供大家参考。[浏览博客](https://fan4j.github.io/)\n\n## 1.准备Github,git,nodejs\n第一步，注册github账号，安装git,nodejs\ngithub地址:https://github.com/\ngit下载地址:https://git-scm.com/downloads\nnodejs下载地址:http://nodejs.cn/ \nnodejs的学习可以参考官方文档:http://nodejs.cn/api/\ngit如果不会建议先看廖雪峰的git教程:[点击链接](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n一切就绪后可以在存放代码的目录下打开git bash,确认是否安装成功\n```\ngit\nnode -v\nnpm -v  //最新版的nodejs已经集成了npm包\n```\n## 2.初始化hexo\n依次进行安装hexo,查看是否安装成功，初始化博客，部署，如下\n```\nhexo init hexo  //初始化目录\ncd hexo  //进入目录\nhexo generate  //生成html    \nhexo server  //运行本地服务\n```\n在本地部署完成之后，可以在\nhttp://localhost:4000/\n查看部署效果，目录结构如下：\n```\n├── .deploy       //需要部署的文件\n├── node_modules  //Hexo插件\n├── public        //生成的静态网页文件\n├── scaffolds     //模板\n├── source        //博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里\n|   ├── _drafts   //草稿\n|   └── _posts    //文章\n├── themes        //主题\n├── _config.yml   //全局配置文件\n└── package.json\n```\n## 3.修改_config.yml进行格式修改\n主要配置如下，可以用于参考，需要注意的是yml格式非常严格，冒号后面需要加空格，后面jsContent是为了yilia标签库特效准备的\n```\n# Site\ntitle: 重塑自我\nsubtitle: 当你低头的瞬间，才发现脚下的路\ndescription: 当你低头的瞬间，才发现脚下的路\nauthor: Fan4j\nlanguage: zh-Hans\ntimezone: Asia/Shanghai\n\ndeploy:\n  type: git\n  repo: git@github.com:Fan4J/fan4j.github.io.git\n  branch: master\n  \njsonContent:\n    meta: false\n    pages: false\n    posts:\n      title: true\n      date: true\n      path: true\n      text: false\n      raw: false\n      content: false\n      slug: false\n      updated: false\n      comments: false\n      link: false\n      permalink: false\n      excerpt: false\n      categories: false\n      tags: true\n```\n## 4.修改主题\n进入主题目录下，从github上找自己喜欢的好看的hexo主题，并下载。\nhexo主题地址:https://hexo.io/themes/\n点击到相应的github的主页，找到项目的地址，克隆到本地，比如我的博客使用的很受欢迎的yilia主题，如下\n```\ncd hexo\ncd themes //cd到themes目录下\ngit clone https://github.com/litten/hexo-theme-yilia.git yilia //下载到yilia文件夹\n```\n主题的目录结构如下\n```\n├── languages       //主题的语言包\n├── layout  //主题样式\n├── source       // 资源文件目录，例如图片\n├── source-src     //\n├── _config.yml   //配置文件\n└── package.json\n```\n主要修改在于_config.yml配置\n主要配置节选如下\n```\n# Header\n\nmenu:\n  主页: /\n  随笔: /tags/随笔/\n  技术: /tags/技术/\n  \n# SubNav\nsubnav:\n  github: \"https://github.com/Fan4J\"\n  weibo: \"http://weibo.com/2179165162/profile?topnav=1&wvr=6\"\n  #rss: \"#\"\n  zhihu: \"https://www.zhihu.com/people/storm-spirit/activities\"\n  #qq: \"#\"\n  #weixin: \"#\"\n  jianshu: \"http://www.jianshu.com/u/c4f8f0c4a19f\"\n  #douban: \"#\"\n  #segmentfault: \"#\"\n  #bilibili: \"#\"\n  #acfun: \"#\"\n  #mail: \"fspirit@yeah.net\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\n# 打赏\n# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏\nreward_type: 2\n# 打赏wording\nreward_wording: '多谢支持,一起努力~！'\n# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg\nalipay: /img/payali.jpg\n# 微信二维码图片地址\nweixin: /img/paywechat.jpg\n\n\nsmart_menu:\n  innerArchive: '所有文章'\n  friends: '友链'\n  aboutme: '关于我'\n\nfriends:\n  w3school: http://www.w3school.com.cn/\n  hexo: https://hexo.io/\n  hexo-theme-yilia: https://github.com/litten/hexo-theme-yilia/\n  \n\naboutme: 为了美好生活而拼命努力的普通人\n```\n添加头像既可以用本地的资源路径，记得是theme文件夹下的路径，例如我的图片放在theme/img/目录下\n```\navatar: /img/head.jpg\n```\n打赏的图片同理\n同时对于标签的js-content，需要安装一个包才可不出错，记着是在hexo目录下操作\n```\ncd hexo\nnpm i hexo-generator-json-content --save\n```\n## 5.绑定Github并部署\nGithubPages是指特定命名方式的respository: namespace.github.io,比如我的就是fan4j.github.io\n这样命名的仓库会被自动解析为githubpage,只需在hexo的全局配置文件中正确配置，即可简单部署\n```\nnpm install hexo-deployer-git --save\nnpm deploy \n```\n## 6.发布新文章\n以上内容弄好以后，发布新文章就很轻松了\n```\ncd hexo\nhexo new \"posttitle\"  //会在hexo/source/_posts目录下出现新的文章\n```\n打开文章，添加内容，修改配置，通常打开markdown文件可看到文件头，可以添加相应的文章标签，\n```\ntitle: 用GithubPages+Hexo搭建漂亮的博客\ndate: 2017-07-25 09:04:14\ntags: \n\t- 技术\n\t- 博客\n```\ntags可以继续添加，修改完成后即可开始部署到github服务器\n```\nhexo generate \nhexo deploy\n```\n部署完成，以后用这种方法部署即可\nhexo现在也支持简写，构建过程更加简易\n```\nhexo g == hexo generate\nhexo d == hexo deploy\nhexo s == hexo server\nhexo n == hexo new\n```\n## 7.代码保存，其他配置\n这时打开github可以看到仓库中已经是前端页面的代码，说明部署完毕，访问地址即可-> https://fan4j.github.io/\n同时可以将部署内容保存到新的respository中，可以在多个电脑上进行新文章的发布部署。\n## 8.结束语\n部署结束，中间可能遇到些坑，浪费了些时间，但是都还是可以通过网上搜索获取答案，总体还是觉得很值的，最后套用某人的话，希望不是三分钟热度，一定要把这个博客坚持下去~","slug":"how-to-build-this-blog","published":1,"updated":"2018-07-30T15:04:59.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy3u76w10004tgrl2n8kky80","content":"<blockquote>\n<p>一直以来都想自己搭建博客，作为个人生活和技术的记录，终于在前几天开始动手，一天多时间搭建了自己的个人博客，搭建方式：github+hexo（注：没有绑定个人域名，直接通过github提供的个性链接访问），这种方式可能会在速度上由于github本身的一些原因受到影响，存储空间上其实github没有什么限制，大可放心使用。<br>本文主要记录搭建的过程以及遇到的一些坑，仅供大家参考。<a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">浏览博客</a></p>\n</blockquote>\n<h2 id=\"1-准备Github-git-nodejs\"><a href=\"#1-准备Github-git-nodejs\" class=\"headerlink\" title=\"1.准备Github,git,nodejs\"></a>1.准备Github,git,nodejs</h2><p>第一步，注册github账号，安装git,nodejs<br>github地址:<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">https://github.com/</a><br>git下载地址:<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/downloads</a><br>nodejs下载地址:<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/</a><br>nodejs的学习可以参考官方文档:<a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/</a><br>git如果不会建议先看廖雪峰的git教程:<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">点击链接</a><br>一切就绪后可以在存放代码的目录下打开git bash,确认是否安装成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git</span><br><span class=\"line\">node -v</span><br><span class=\"line\">npm -v  //最新版的nodejs已经集成了npm包</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-初始化hexo\"><a href=\"#2-初始化hexo\" class=\"headerlink\" title=\"2.初始化hexo\"></a>2.初始化hexo</h2><p>依次进行安装hexo,查看是否安装成功，初始化博客，部署，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init hexo  //初始化目录</span><br><span class=\"line\">cd hexo  //进入目录</span><br><span class=\"line\">hexo generate  //生成html    </span><br><span class=\"line\">hexo server  //运行本地服务</span><br></pre></td></tr></table></figure></p>\n<p>在本地部署完成之后，可以在<br><a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a><br>查看部署效果，目录结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── .deploy       //需要部署的文件</span><br><span class=\"line\">├── node_modules  //Hexo插件</span><br><span class=\"line\">├── public        //生成的静态网页文件</span><br><span class=\"line\">├── scaffolds     //模板</span><br><span class=\"line\">├── source        //博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</span><br><span class=\"line\">|   ├── _drafts   //草稿</span><br><span class=\"line\">|   └── _posts    //文章</span><br><span class=\"line\">├── themes        //主题</span><br><span class=\"line\">├── _config.yml   //全局配置文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-修改-config-yml进行格式修改\"><a href=\"#3-修改-config-yml进行格式修改\" class=\"headerlink\" title=\"3.修改_config.yml进行格式修改\"></a>3.修改_config.yml进行格式修改</h2><p>主要配置如下，可以用于参考，需要注意的是yml格式非常严格，冒号后面需要加空格，后面jsContent是为了yilia标签库特效准备的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: 重塑自我</span><br><span class=\"line\">subtitle: 当你低头的瞬间，才发现脚下的路</span><br><span class=\"line\">description: 当你低头的瞬间，才发现脚下的路</span><br><span class=\"line\">author: Fan4j</span><br><span class=\"line\">language: zh-Hans</span><br><span class=\"line\">timezone: Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:Fan4J/fan4j.github.io.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">  </span><br><span class=\"line\">jsonContent:</span><br><span class=\"line\">    meta: false</span><br><span class=\"line\">    pages: false</span><br><span class=\"line\">    posts:</span><br><span class=\"line\">      title: true</span><br><span class=\"line\">      date: true</span><br><span class=\"line\">      path: true</span><br><span class=\"line\">      text: false</span><br><span class=\"line\">      raw: false</span><br><span class=\"line\">      content: false</span><br><span class=\"line\">      slug: false</span><br><span class=\"line\">      updated: false</span><br><span class=\"line\">      comments: false</span><br><span class=\"line\">      link: false</span><br><span class=\"line\">      permalink: false</span><br><span class=\"line\">      excerpt: false</span><br><span class=\"line\">      categories: false</span><br><span class=\"line\">      tags: true</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-修改主题\"><a href=\"#4-修改主题\" class=\"headerlink\" title=\"4.修改主题\"></a>4.修改主题</h2><p>进入主题目录下，从github上找自己喜欢的好看的hexo主题，并下载。<br>hexo主题地址:<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/</a><br>点击到相应的github的主页，找到项目的地址，克隆到本地，比如我的博客使用的很受欢迎的yilia主题，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">cd themes //cd到themes目录下</span><br><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git yilia //下载到yilia文件夹</span><br></pre></td></tr></table></figure></p>\n<p>主题的目录结构如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── languages       //主题的语言包</span><br><span class=\"line\">├── layout  //主题样式</span><br><span class=\"line\">├── source       // 资源文件目录，例如图片</span><br><span class=\"line\">├── source-src     //</span><br><span class=\"line\">├── _config.yml   //配置文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<p>主要修改在于_config.yml配置<br>主要配置节选如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Header</span><br><span class=\"line\"></span><br><span class=\"line\">menu:</span><br><span class=\"line\">  主页: /</span><br><span class=\"line\">  随笔: /tags/随笔/</span><br><span class=\"line\">  技术: /tags/技术/</span><br><span class=\"line\">  </span><br><span class=\"line\"># SubNav</span><br><span class=\"line\">subnav:</span><br><span class=\"line\">  github: &quot;https://github.com/Fan4J&quot;</span><br><span class=\"line\">  weibo: &quot;http://weibo.com/2179165162/profile?topnav=1&amp;wvr=6&quot;</span><br><span class=\"line\">  #rss: &quot;#&quot;</span><br><span class=\"line\">  zhihu: &quot;https://www.zhihu.com/people/storm-spirit/activities&quot;</span><br><span class=\"line\">  #qq: &quot;#&quot;</span><br><span class=\"line\">  #weixin: &quot;#&quot;</span><br><span class=\"line\">  jianshu: &quot;http://www.jianshu.com/u/c4f8f0c4a19f&quot;</span><br><span class=\"line\">  #douban: &quot;#&quot;</span><br><span class=\"line\">  #segmentfault: &quot;#&quot;</span><br><span class=\"line\">  #bilibili: &quot;#&quot;</span><br><span class=\"line\">  #acfun: &quot;#&quot;</span><br><span class=\"line\">  #mail: &quot;fspirit@yeah.net&quot;</span><br><span class=\"line\">  #facebook: &quot;#&quot;</span><br><span class=\"line\">  #google: &quot;#&quot;</span><br><span class=\"line\">  #twitter: &quot;#&quot;</span><br><span class=\"line\">  #linkedin: &quot;#&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 打赏</span><br><span class=\"line\"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</span><br><span class=\"line\">reward_type: 2</span><br><span class=\"line\"># 打赏wording</span><br><span class=\"line\">reward_wording: &apos;多谢支持,一起努力~！&apos;</span><br><span class=\"line\"># 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</span><br><span class=\"line\">alipay: /img/payali.jpg</span><br><span class=\"line\"># 微信二维码图片地址</span><br><span class=\"line\">weixin: /img/paywechat.jpg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">smart_menu:</span><br><span class=\"line\">  innerArchive: &apos;所有文章&apos;</span><br><span class=\"line\">  friends: &apos;友链&apos;</span><br><span class=\"line\">  aboutme: &apos;关于我&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">friends:</span><br><span class=\"line\">  w3school: http://www.w3school.com.cn/</span><br><span class=\"line\">  hexo: https://hexo.io/</span><br><span class=\"line\">  hexo-theme-yilia: https://github.com/litten/hexo-theme-yilia/</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">aboutme: 为了美好生活而拼命努力的普通人</span><br></pre></td></tr></table></figure></p>\n<p>添加头像既可以用本地的资源路径，记得是theme文件夹下的路径，例如我的图片放在theme/img/目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avatar: /img/head.jpg</span><br></pre></td></tr></table></figure></p>\n<p>打赏的图片同理<br>同时对于标签的js-content，需要安装一个包才可不出错，记着是在hexo目录下操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">npm i hexo-generator-json-content --save</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-绑定Github并部署\"><a href=\"#5-绑定Github并部署\" class=\"headerlink\" title=\"5.绑定Github并部署\"></a>5.绑定Github并部署</h2><p>GithubPages是指特定命名方式的respository: namespace.github.io,比如我的就是fan4j.github.io<br>这样命名的仓库会被自动解析为githubpage,只需在hexo的全局配置文件中正确配置，即可简单部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\">npm deploy</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-发布新文章\"><a href=\"#6-发布新文章\" class=\"headerlink\" title=\"6.发布新文章\"></a>6.发布新文章</h2><p>以上内容弄好以后，发布新文章就很轻松了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">hexo new &quot;posttitle&quot;  //会在hexo/source/_posts目录下出现新的文章</span><br></pre></td></tr></table></figure></p>\n<p>打开文章，添加内容，修改配置，通常打开markdown文件可看到文件头，可以添加相应的文章标签，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 用GithubPages+Hexo搭建漂亮的博客</span><br><span class=\"line\">date: 2017-07-25 09:04:14</span><br><span class=\"line\">tags: </span><br><span class=\"line\">\t- 技术</span><br><span class=\"line\">\t- 博客</span><br></pre></td></tr></table></figure></p>\n<p>tags可以继续添加，修改完成后即可开始部署到github服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>部署完成，以后用这种方法部署即可<br>hexo现在也支持简写，构建过程更加简易<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo d == hexo deploy</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo n == hexo new</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"7-代码保存，其他配置\"><a href=\"#7-代码保存，其他配置\" class=\"headerlink\" title=\"7.代码保存，其他配置\"></a>7.代码保存，其他配置</h2><p>这时打开github可以看到仓库中已经是前端页面的代码，说明部署完毕，访问地址即可-&gt; <a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">https://fan4j.github.io/</a><br>同时可以将部署内容保存到新的respository中，可以在多个电脑上进行新文章的发布部署。</p>\n<h2 id=\"8-结束语\"><a href=\"#8-结束语\" class=\"headerlink\" title=\"8.结束语\"></a>8.结束语</h2><p>部署结束，中间可能遇到些坑，浪费了些时间，但是都还是可以通过网上搜索获取答案，总体还是觉得很值的，最后套用某人的话，希望不是三分钟热度，一定要把这个博客坚持下去~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一直以来都想自己搭建博客，作为个人生活和技术的记录，终于在前几天开始动手，一天多时间搭建了自己的个人博客，搭建方式：github+hexo（注：没有绑定个人域名，直接通过github提供的个性链接访问），这种方式可能会在速度上由于github本身的一些原因受到影响，存储空间上其实github没有什么限制，大可放心使用。<br>本文主要记录搭建的过程以及遇到的一些坑，仅供大家参考。<a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">浏览博客</a></p>\n</blockquote>\n<h2 id=\"1-准备Github-git-nodejs\"><a href=\"#1-准备Github-git-nodejs\" class=\"headerlink\" title=\"1.准备Github,git,nodejs\"></a>1.准备Github,git,nodejs</h2><p>第一步，注册github账号，安装git,nodejs<br>github地址:<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">https://github.com/</a><br>git下载地址:<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/downloads</a><br>nodejs下载地址:<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/</a><br>nodejs的学习可以参考官方文档:<a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/</a><br>git如果不会建议先看廖雪峰的git教程:<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">点击链接</a><br>一切就绪后可以在存放代码的目录下打开git bash,确认是否安装成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git</span><br><span class=\"line\">node -v</span><br><span class=\"line\">npm -v  //最新版的nodejs已经集成了npm包</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-初始化hexo\"><a href=\"#2-初始化hexo\" class=\"headerlink\" title=\"2.初始化hexo\"></a>2.初始化hexo</h2><p>依次进行安装hexo,查看是否安装成功，初始化博客，部署，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init hexo  //初始化目录</span><br><span class=\"line\">cd hexo  //进入目录</span><br><span class=\"line\">hexo generate  //生成html    </span><br><span class=\"line\">hexo server  //运行本地服务</span><br></pre></td></tr></table></figure></p>\n<p>在本地部署完成之后，可以在<br><a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a><br>查看部署效果，目录结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── .deploy       //需要部署的文件</span><br><span class=\"line\">├── node_modules  //Hexo插件</span><br><span class=\"line\">├── public        //生成的静态网页文件</span><br><span class=\"line\">├── scaffolds     //模板</span><br><span class=\"line\">├── source        //博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</span><br><span class=\"line\">|   ├── _drafts   //草稿</span><br><span class=\"line\">|   └── _posts    //文章</span><br><span class=\"line\">├── themes        //主题</span><br><span class=\"line\">├── _config.yml   //全局配置文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-修改-config-yml进行格式修改\"><a href=\"#3-修改-config-yml进行格式修改\" class=\"headerlink\" title=\"3.修改_config.yml进行格式修改\"></a>3.修改_config.yml进行格式修改</h2><p>主要配置如下，可以用于参考，需要注意的是yml格式非常严格，冒号后面需要加空格，后面jsContent是为了yilia标签库特效准备的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: 重塑自我</span><br><span class=\"line\">subtitle: 当你低头的瞬间，才发现脚下的路</span><br><span class=\"line\">description: 当你低头的瞬间，才发现脚下的路</span><br><span class=\"line\">author: Fan4j</span><br><span class=\"line\">language: zh-Hans</span><br><span class=\"line\">timezone: Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:Fan4J/fan4j.github.io.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">  </span><br><span class=\"line\">jsonContent:</span><br><span class=\"line\">    meta: false</span><br><span class=\"line\">    pages: false</span><br><span class=\"line\">    posts:</span><br><span class=\"line\">      title: true</span><br><span class=\"line\">      date: true</span><br><span class=\"line\">      path: true</span><br><span class=\"line\">      text: false</span><br><span class=\"line\">      raw: false</span><br><span class=\"line\">      content: false</span><br><span class=\"line\">      slug: false</span><br><span class=\"line\">      updated: false</span><br><span class=\"line\">      comments: false</span><br><span class=\"line\">      link: false</span><br><span class=\"line\">      permalink: false</span><br><span class=\"line\">      excerpt: false</span><br><span class=\"line\">      categories: false</span><br><span class=\"line\">      tags: true</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-修改主题\"><a href=\"#4-修改主题\" class=\"headerlink\" title=\"4.修改主题\"></a>4.修改主题</h2><p>进入主题目录下，从github上找自己喜欢的好看的hexo主题，并下载。<br>hexo主题地址:<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/</a><br>点击到相应的github的主页，找到项目的地址，克隆到本地，比如我的博客使用的很受欢迎的yilia主题，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">cd themes //cd到themes目录下</span><br><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git yilia //下载到yilia文件夹</span><br></pre></td></tr></table></figure></p>\n<p>主题的目录结构如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── languages       //主题的语言包</span><br><span class=\"line\">├── layout  //主题样式</span><br><span class=\"line\">├── source       // 资源文件目录，例如图片</span><br><span class=\"line\">├── source-src     //</span><br><span class=\"line\">├── _config.yml   //配置文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure></p>\n<p>主要修改在于_config.yml配置<br>主要配置节选如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Header</span><br><span class=\"line\"></span><br><span class=\"line\">menu:</span><br><span class=\"line\">  主页: /</span><br><span class=\"line\">  随笔: /tags/随笔/</span><br><span class=\"line\">  技术: /tags/技术/</span><br><span class=\"line\">  </span><br><span class=\"line\"># SubNav</span><br><span class=\"line\">subnav:</span><br><span class=\"line\">  github: &quot;https://github.com/Fan4J&quot;</span><br><span class=\"line\">  weibo: &quot;http://weibo.com/2179165162/profile?topnav=1&amp;wvr=6&quot;</span><br><span class=\"line\">  #rss: &quot;#&quot;</span><br><span class=\"line\">  zhihu: &quot;https://www.zhihu.com/people/storm-spirit/activities&quot;</span><br><span class=\"line\">  #qq: &quot;#&quot;</span><br><span class=\"line\">  #weixin: &quot;#&quot;</span><br><span class=\"line\">  jianshu: &quot;http://www.jianshu.com/u/c4f8f0c4a19f&quot;</span><br><span class=\"line\">  #douban: &quot;#&quot;</span><br><span class=\"line\">  #segmentfault: &quot;#&quot;</span><br><span class=\"line\">  #bilibili: &quot;#&quot;</span><br><span class=\"line\">  #acfun: &quot;#&quot;</span><br><span class=\"line\">  #mail: &quot;fspirit@yeah.net&quot;</span><br><span class=\"line\">  #facebook: &quot;#&quot;</span><br><span class=\"line\">  #google: &quot;#&quot;</span><br><span class=\"line\">  #twitter: &quot;#&quot;</span><br><span class=\"line\">  #linkedin: &quot;#&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 打赏</span><br><span class=\"line\"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</span><br><span class=\"line\">reward_type: 2</span><br><span class=\"line\"># 打赏wording</span><br><span class=\"line\">reward_wording: &apos;多谢支持,一起努力~！&apos;</span><br><span class=\"line\"># 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</span><br><span class=\"line\">alipay: /img/payali.jpg</span><br><span class=\"line\"># 微信二维码图片地址</span><br><span class=\"line\">weixin: /img/paywechat.jpg</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">smart_menu:</span><br><span class=\"line\">  innerArchive: &apos;所有文章&apos;</span><br><span class=\"line\">  friends: &apos;友链&apos;</span><br><span class=\"line\">  aboutme: &apos;关于我&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">friends:</span><br><span class=\"line\">  w3school: http://www.w3school.com.cn/</span><br><span class=\"line\">  hexo: https://hexo.io/</span><br><span class=\"line\">  hexo-theme-yilia: https://github.com/litten/hexo-theme-yilia/</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">aboutme: 为了美好生活而拼命努力的普通人</span><br></pre></td></tr></table></figure></p>\n<p>添加头像既可以用本地的资源路径，记得是theme文件夹下的路径，例如我的图片放在theme/img/目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avatar: /img/head.jpg</span><br></pre></td></tr></table></figure></p>\n<p>打赏的图片同理<br>同时对于标签的js-content，需要安装一个包才可不出错，记着是在hexo目录下操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">npm i hexo-generator-json-content --save</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-绑定Github并部署\"><a href=\"#5-绑定Github并部署\" class=\"headerlink\" title=\"5.绑定Github并部署\"></a>5.绑定Github并部署</h2><p>GithubPages是指特定命名方式的respository: namespace.github.io,比如我的就是fan4j.github.io<br>这样命名的仓库会被自动解析为githubpage,只需在hexo的全局配置文件中正确配置，即可简单部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\">npm deploy</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-发布新文章\"><a href=\"#6-发布新文章\" class=\"headerlink\" title=\"6.发布新文章\"></a>6.发布新文章</h2><p>以上内容弄好以后，发布新文章就很轻松了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo</span><br><span class=\"line\">hexo new &quot;posttitle&quot;  //会在hexo/source/_posts目录下出现新的文章</span><br></pre></td></tr></table></figure></p>\n<p>打开文章，添加内容，修改配置，通常打开markdown文件可看到文件头，可以添加相应的文章标签，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 用GithubPages+Hexo搭建漂亮的博客</span><br><span class=\"line\">date: 2017-07-25 09:04:14</span><br><span class=\"line\">tags: </span><br><span class=\"line\">\t- 技术</span><br><span class=\"line\">\t- 博客</span><br></pre></td></tr></table></figure></p>\n<p>tags可以继续添加，修改完成后即可开始部署到github服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>部署完成，以后用这种方法部署即可<br>hexo现在也支持简写，构建过程更加简易<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo d == hexo deploy</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo n == hexo new</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"7-代码保存，其他配置\"><a href=\"#7-代码保存，其他配置\" class=\"headerlink\" title=\"7.代码保存，其他配置\"></a>7.代码保存，其他配置</h2><p>这时打开github可以看到仓库中已经是前端页面的代码，说明部署完毕，访问地址即可-&gt; <a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">https://fan4j.github.io/</a><br>同时可以将部署内容保存到新的respository中，可以在多个电脑上进行新文章的发布部署。</p>\n<h2 id=\"8-结束语\"><a href=\"#8-结束语\" class=\"headerlink\" title=\"8.结束语\"></a>8.结束语</h2><p>部署结束，中间可能遇到些坑，浪费了些时间，但是都还是可以通过网上搜索获取答案，总体还是觉得很值的，最后套用某人的话，希望不是三分钟热度，一定要把这个博客坚持下去~</p>\n"},{"title":"python json","date":"2017-08-18T03:05:37.000Z","_content":">python世界里，json和dict是天生一对，他们之间的转换是必须要熟练的\n\n# 1.dumps/loads \n```\ndict1 = {\"fan\":123456,\"gaga\":\"4j\"}\njson1 = json.dumps(dict1)\nprint(json1)\nprint(type(json1))\n\ndict2 = json.loads(str(json1))\nprint(dict2)\nprint(type(dict2))\n```\n输出如下\n```\n{\"gaga\": \"4j\", \"fan\": 123456}\n<class 'str'>\n{'fan': 123456, 'gaga': '4j'}\n<class 'dict'>\n```\n# 2.dump/load\n```\ndict = {\"fan\":1123,\"gaga\":\"12312\"}\nwith open(\"test.txt\",\"w\") as f:\n     json.dump(dict,f)\n\nwith open(\"test.txt\",\"r\") as f:\n     dict1 = json.load(f)\nprint(dict1)\nprint(type(dict1))\n```\n输出如下\n```\n{'gaga': '12312', 'fan': 1123}\n<class 'dict'>\n```\n以上，后面会继续补充","source":"_posts/python-json.md","raw":"---\ntitle: python json\ndate: 2017-08-18 11:05:37\ntags: \n\t- Python\n---\n>python世界里，json和dict是天生一对，他们之间的转换是必须要熟练的\n\n# 1.dumps/loads \n```\ndict1 = {\"fan\":123456,\"gaga\":\"4j\"}\njson1 = json.dumps(dict1)\nprint(json1)\nprint(type(json1))\n\ndict2 = json.loads(str(json1))\nprint(dict2)\nprint(type(dict2))\n```\n输出如下\n```\n{\"gaga\": \"4j\", \"fan\": 123456}\n<class 'str'>\n{'fan': 123456, 'gaga': '4j'}\n<class 'dict'>\n```\n# 2.dump/load\n```\ndict = {\"fan\":1123,\"gaga\":\"12312\"}\nwith open(\"test.txt\",\"w\") as f:\n     json.dump(dict,f)\n\nwith open(\"test.txt\",\"r\") as f:\n     dict1 = json.load(f)\nprint(dict1)\nprint(type(dict1))\n```\n输出如下\n```\n{'gaga': '12312', 'fan': 1123}\n<class 'dict'>\n```\n以上，后面会继续补充","slug":"python-json","published":1,"updated":"2018-07-30T15:04:59.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy3u76w20005tgrlt0462zwn","content":"<blockquote>\n<p>python世界里，json和dict是天生一对，他们之间的转换是必须要熟练的</p>\n</blockquote>\n<h1 id=\"1-dumps-loads\"><a href=\"#1-dumps-loads\" class=\"headerlink\" title=\"1.dumps/loads\"></a>1.dumps/loads</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict1 = &#123;&quot;fan&quot;:123456,&quot;gaga&quot;:&quot;4j&quot;&#125;</span><br><span class=\"line\">json1 = json.dumps(dict1)</span><br><span class=\"line\">print(json1)</span><br><span class=\"line\">print(type(json1))</span><br><span class=\"line\"></span><br><span class=\"line\">dict2 = json.loads(str(json1))</span><br><span class=\"line\">print(dict2)</span><br><span class=\"line\">print(type(dict2))</span><br></pre></td></tr></table></figure>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;gaga&quot;: &quot;4j&quot;, &quot;fan&quot;: 123456&#125;</span><br><span class=\"line\">&lt;class &apos;str&apos;&gt;</span><br><span class=\"line\">&#123;&apos;fan&apos;: 123456, &apos;gaga&apos;: &apos;4j&apos;&#125;</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-dump-load\"><a href=\"#2-dump-load\" class=\"headerlink\" title=\"2.dump/load\"></a>2.dump/load</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict = &#123;&quot;fan&quot;:1123,&quot;gaga&quot;:&quot;12312&quot;&#125;</span><br><span class=\"line\">with open(&quot;test.txt&quot;,&quot;w&quot;) as f:</span><br><span class=\"line\">     json.dump(dict,f)</span><br><span class=\"line\"></span><br><span class=\"line\">with open(&quot;test.txt&quot;,&quot;r&quot;) as f:</span><br><span class=\"line\">     dict1 = json.load(f)</span><br><span class=\"line\">print(dict1)</span><br><span class=\"line\">print(type(dict1))</span><br></pre></td></tr></table></figure>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;gaga&apos;: &apos;12312&apos;, &apos;fan&apos;: 1123&#125;</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以上，后面会继续补充</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>python世界里，json和dict是天生一对，他们之间的转换是必须要熟练的</p>\n</blockquote>\n<h1 id=\"1-dumps-loads\"><a href=\"#1-dumps-loads\" class=\"headerlink\" title=\"1.dumps/loads\"></a>1.dumps/loads</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict1 = &#123;&quot;fan&quot;:123456,&quot;gaga&quot;:&quot;4j&quot;&#125;</span><br><span class=\"line\">json1 = json.dumps(dict1)</span><br><span class=\"line\">print(json1)</span><br><span class=\"line\">print(type(json1))</span><br><span class=\"line\"></span><br><span class=\"line\">dict2 = json.loads(str(json1))</span><br><span class=\"line\">print(dict2)</span><br><span class=\"line\">print(type(dict2))</span><br></pre></td></tr></table></figure>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;gaga&quot;: &quot;4j&quot;, &quot;fan&quot;: 123456&#125;</span><br><span class=\"line\">&lt;class &apos;str&apos;&gt;</span><br><span class=\"line\">&#123;&apos;fan&apos;: 123456, &apos;gaga&apos;: &apos;4j&apos;&#125;</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-dump-load\"><a href=\"#2-dump-load\" class=\"headerlink\" title=\"2.dump/load\"></a>2.dump/load</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict = &#123;&quot;fan&quot;:1123,&quot;gaga&quot;:&quot;12312&quot;&#125;</span><br><span class=\"line\">with open(&quot;test.txt&quot;,&quot;w&quot;) as f:</span><br><span class=\"line\">     json.dump(dict,f)</span><br><span class=\"line\"></span><br><span class=\"line\">with open(&quot;test.txt&quot;,&quot;r&quot;) as f:</span><br><span class=\"line\">     dict1 = json.load(f)</span><br><span class=\"line\">print(dict1)</span><br><span class=\"line\">print(type(dict1))</span><br></pre></td></tr></table></figure>\n<p>输出如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&apos;gaga&apos;: &apos;12312&apos;, &apos;fan&apos;: 1123&#125;</span><br><span class=\"line\">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以上，后面会继续补充</p>\n"},{"title":"用python模拟知乎登录","date":"2017-08-18T02:33:00.000Z","_content":">前言：最近看到公众号python之禅里面的历史文章，模拟登录知乎，又看到很多人在网上尝试写代码，自己也想试试，最新的验证码是选择倒立的汉字，本文采用手动输入验证码的形式完成验证，最后获取cookie，存入文件中，之后便可以无需登录直接访问了。\n>所用python的包：requests，BeautifulSoup，json\n\n首先之前使用python请求网页有层出不穷的包，但是用了requests之后才知道它有多方便，详情可以参考这篇文章，也是python之禅公众号的文章，这里帮忙推荐一波--->[链接](http://mp.weixin.qq.com/s/gO8E3lXZiL6_ql5rDuHwMQ)。\n下面一步步开始讲解如何模拟登录。\n## 1.观察请求参数（FireFox/Chrome）\n在向网站发送请求的时候，服务器会对访问用户进行标识，以cookie的形式存放在浏览器，该浏览器下次进行访问时，则可以跳过登陆直接浏览页面，这是我们模拟知乎登陆的主要目的，获取cookie后，使用cookie访问主页面，则可以跳过登陆。在火狐中，先清掉之前保存的cookie，以模拟浏览器首次访问。\n![清除火狐cookie](http://upload-images.jianshu.io/upload_images/5834071-9e6c660f8d81b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n清除cookie后，试着登陆知乎，发现有验证码，打开F12，一边发请求，一边观察网络中的变化。\n这里故意输错密码，看看发送了什么请求。\n\n![登陆请求头](http://upload-images.jianshu.io/upload_images/5834071-2679b4d38f31cd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n![登陆请求参数](http://upload-images.jianshu.io/upload_images/5834071-500e37e330a78361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n\n_xsrf的参数是用于防止xsrf攻击，如何防止xsrf攻击，可以参考[这篇文章](http://blog.csdn.net/newjueqi/article/details/7542409)，这是一种简单的恶意链接攻击，可以直接让你访问目标网站并且修改你的密码，所以一般在提交的表单中加个_xsrf参数，只有参数正确才可以进行提交。\n\n## 2.代码模拟请求\n可以看到知乎的主要请求参数，还有email,password,captcha,captcha_type。\n自己试验过，captcha_type可以不用填写，首先还是找到验证码的链接如下：\nhttps://www.zhihu.com/captcha.gif?r=1503020715890&type=login&lang=cn\n\n![获取验证码的链接](http://upload-images.jianshu.io/upload_images/5834071-8a5e858b5322688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n很明显，中间的数字是以毫秒为单位的时间戳，因此在代码中很容易模拟这个链接去发送请求获取验证码的图片。\n```\ndef get_captcha():\n    timestamp = str(time.time()*1000).split(\".\")[0]\n    url = \"https://www.zhihu.com/captcha.gif?r=%s&type=login&lang=cn\" % timestamp\n    print(url)\n    req = session.get(url,headers=headers)\n    with open(\"img1.png\",'wb') as f:\n        f.write(req.content)\n```\n我采用的方式是人工识别，所以把图片以二进制的形式写入文件，自己点开查看。\n得到的内容是一行汉字：\n![知乎验证码](http://upload-images.jianshu.io/upload_images/5834071-c31e380d68644a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400)\n点击倒立的汉字，获取响应的坐标，放在请求参数中，即可模拟鼠标点击的过程，可以自己点击几个点，大概找到1234567个汉字的坐标，然后根据汉字的个数，匹配响应的坐标点，填入参数中即可。\n```\ndef get_code():\n    get_captcha()\n    print(\"输入倒立汉字的位置，用逗号隔开\")\n    a = input(\"input:\")\n    indexs = a.split(\",\")\n    data=[[16.4,26.9],[33.4,26.9],[60.4,21.9],[84.4,24.9],[108.4,24.9],[130.4,24.9],[156.4,24.9]]\n    input_points = []\n    for idx in indexs:\n        input_points.append(data[int(idx)-1])\n    dict = {\n        \"img_size\": [200, 44],\n        \"input_points\": input_points\n    }\n    return dict\n```\n有了xsrf参数和验证码，输入自己的账号密码，即可模拟登录\n```\ndef login():\n    url = \"https://www.zhihu.com/login/email\"\n    data={\n        \"_xsrf\":get_xsrf(),\n        \"email\":'******@qq.com',\n        \"password\":'asfgasdfasf',\n        'captcha_type':get_code()\n    }\n    response = session.post(url, data=data,headers=headers)\n    login_code = response.json()\n    print(login_code['msg'])\n    response = session.get(\"https://www.zhihu.com/settings/profile\",headers=headers)\n    #将cookies->dict->json存放在txt|之后再json->dict直接使用\n    with open(\"cookies.txt\",'w') as f:\n        json.dump(session.cookies.get_dict(),f)\n    with open(\"login.html\",\"wb\") as f:\n        f.write(response.content)\n```\n第一次登录结束后，session.cookie会自动保持登录状态的cookie，下一次进行登录时，使用cookie即可，这里进行持久化，暂时写在txt文件中，下次使用时直接从文件获取。\n这里有个小插曲就是session.cookie的类型是RequestCookie不是dict或者str，这里使用get_dict()方法转化成dict，并用json的形式存在txt文件中，取出来的时候，json可以直接提取成dict，放入session.cookie可以直接使用。\n```\n#将cookies->dict->json存放在txt|之后再json->dict直接使用\n    with open(\"cookies.txt\",'w') as f:\n        json.dump(session.cookies.get_dict(),f)\n\n#从txt文件中获取cookies,json->dict存入session.cookies\n    with open(\"cookies.txt\",'r') as f:\n        cookies = json.load(f)\n    session.cookies.update(cookies)\n```\n这里也可以温习下，Python中Json的操作->[链接](http://www.jianshu.com/p/26cb66297a6a)\n获取cookie后，我尝试登录了(https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。\n## 3.总结\n写知乎登录，主要也是练练手，觉得挺有意思，后面可以尝试用phantomjs+selenium模拟下登录爬取，有了登录cookie之后，也可以爬一下知乎的内容，应该有很多有趣的内容，后续会继续更新的，谢谢关注~\ngithub上我也上传了代码，欢迎大家点评，学习。\n[源码地址](https://github.com/Fan4J/Spiders-of-frequently-used-website/tree/master/zhihuLogin)\n[重塑自我](https://fan4j.github.io/)","source":"_posts/python-知乎登录.md","raw":"---\ntitle: 用python模拟知乎登录\ndate: 2017-08-18 10:33:00\ntags: \n\t- Python\n\t- 知乎\n\t\n---\n>前言：最近看到公众号python之禅里面的历史文章，模拟登录知乎，又看到很多人在网上尝试写代码，自己也想试试，最新的验证码是选择倒立的汉字，本文采用手动输入验证码的形式完成验证，最后获取cookie，存入文件中，之后便可以无需登录直接访问了。\n>所用python的包：requests，BeautifulSoup，json\n\n首先之前使用python请求网页有层出不穷的包，但是用了requests之后才知道它有多方便，详情可以参考这篇文章，也是python之禅公众号的文章，这里帮忙推荐一波--->[链接](http://mp.weixin.qq.com/s/gO8E3lXZiL6_ql5rDuHwMQ)。\n下面一步步开始讲解如何模拟登录。\n## 1.观察请求参数（FireFox/Chrome）\n在向网站发送请求的时候，服务器会对访问用户进行标识，以cookie的形式存放在浏览器，该浏览器下次进行访问时，则可以跳过登陆直接浏览页面，这是我们模拟知乎登陆的主要目的，获取cookie后，使用cookie访问主页面，则可以跳过登陆。在火狐中，先清掉之前保存的cookie，以模拟浏览器首次访问。\n![清除火狐cookie](http://upload-images.jianshu.io/upload_images/5834071-9e6c660f8d81b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n清除cookie后，试着登陆知乎，发现有验证码，打开F12，一边发请求，一边观察网络中的变化。\n这里故意输错密码，看看发送了什么请求。\n\n![登陆请求头](http://upload-images.jianshu.io/upload_images/5834071-2679b4d38f31cd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n![登陆请求参数](http://upload-images.jianshu.io/upload_images/5834071-500e37e330a78361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n\n_xsrf的参数是用于防止xsrf攻击，如何防止xsrf攻击，可以参考[这篇文章](http://blog.csdn.net/newjueqi/article/details/7542409)，这是一种简单的恶意链接攻击，可以直接让你访问目标网站并且修改你的密码，所以一般在提交的表单中加个_xsrf参数，只有参数正确才可以进行提交。\n\n## 2.代码模拟请求\n可以看到知乎的主要请求参数，还有email,password,captcha,captcha_type。\n自己试验过，captcha_type可以不用填写，首先还是找到验证码的链接如下：\nhttps://www.zhihu.com/captcha.gif?r=1503020715890&type=login&lang=cn\n\n![获取验证码的链接](http://upload-images.jianshu.io/upload_images/5834071-8a5e858b5322688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n很明显，中间的数字是以毫秒为单位的时间戳，因此在代码中很容易模拟这个链接去发送请求获取验证码的图片。\n```\ndef get_captcha():\n    timestamp = str(time.time()*1000).split(\".\")[0]\n    url = \"https://www.zhihu.com/captcha.gif?r=%s&type=login&lang=cn\" % timestamp\n    print(url)\n    req = session.get(url,headers=headers)\n    with open(\"img1.png\",'wb') as f:\n        f.write(req.content)\n```\n我采用的方式是人工识别，所以把图片以二进制的形式写入文件，自己点开查看。\n得到的内容是一行汉字：\n![知乎验证码](http://upload-images.jianshu.io/upload_images/5834071-c31e380d68644a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400)\n点击倒立的汉字，获取响应的坐标，放在请求参数中，即可模拟鼠标点击的过程，可以自己点击几个点，大概找到1234567个汉字的坐标，然后根据汉字的个数，匹配响应的坐标点，填入参数中即可。\n```\ndef get_code():\n    get_captcha()\n    print(\"输入倒立汉字的位置，用逗号隔开\")\n    a = input(\"input:\")\n    indexs = a.split(\",\")\n    data=[[16.4,26.9],[33.4,26.9],[60.4,21.9],[84.4,24.9],[108.4,24.9],[130.4,24.9],[156.4,24.9]]\n    input_points = []\n    for idx in indexs:\n        input_points.append(data[int(idx)-1])\n    dict = {\n        \"img_size\": [200, 44],\n        \"input_points\": input_points\n    }\n    return dict\n```\n有了xsrf参数和验证码，输入自己的账号密码，即可模拟登录\n```\ndef login():\n    url = \"https://www.zhihu.com/login/email\"\n    data={\n        \"_xsrf\":get_xsrf(),\n        \"email\":'******@qq.com',\n        \"password\":'asfgasdfasf',\n        'captcha_type':get_code()\n    }\n    response = session.post(url, data=data,headers=headers)\n    login_code = response.json()\n    print(login_code['msg'])\n    response = session.get(\"https://www.zhihu.com/settings/profile\",headers=headers)\n    #将cookies->dict->json存放在txt|之后再json->dict直接使用\n    with open(\"cookies.txt\",'w') as f:\n        json.dump(session.cookies.get_dict(),f)\n    with open(\"login.html\",\"wb\") as f:\n        f.write(response.content)\n```\n第一次登录结束后，session.cookie会自动保持登录状态的cookie，下一次进行登录时，使用cookie即可，这里进行持久化，暂时写在txt文件中，下次使用时直接从文件获取。\n这里有个小插曲就是session.cookie的类型是RequestCookie不是dict或者str，这里使用get_dict()方法转化成dict，并用json的形式存在txt文件中，取出来的时候，json可以直接提取成dict，放入session.cookie可以直接使用。\n```\n#将cookies->dict->json存放在txt|之后再json->dict直接使用\n    with open(\"cookies.txt\",'w') as f:\n        json.dump(session.cookies.get_dict(),f)\n\n#从txt文件中获取cookies,json->dict存入session.cookies\n    with open(\"cookies.txt\",'r') as f:\n        cookies = json.load(f)\n    session.cookies.update(cookies)\n```\n这里也可以温习下，Python中Json的操作->[链接](http://www.jianshu.com/p/26cb66297a6a)\n获取cookie后，我尝试登录了(https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。\n## 3.总结\n写知乎登录，主要也是练练手，觉得挺有意思，后面可以尝试用phantomjs+selenium模拟下登录爬取，有了登录cookie之后，也可以爬一下知乎的内容，应该有很多有趣的内容，后续会继续更新的，谢谢关注~\ngithub上我也上传了代码，欢迎大家点评，学习。\n[源码地址](https://github.com/Fan4J/Spiders-of-frequently-used-website/tree/master/zhihuLogin)\n[重塑自我](https://fan4j.github.io/)","slug":"python-知乎登录","published":1,"updated":"2018-07-30T15:04:59.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy3u76w40007tgrlw9hv06w6","content":"<blockquote>\n<p>前言：最近看到公众号python之禅里面的历史文章，模拟登录知乎，又看到很多人在网上尝试写代码，自己也想试试，最新的验证码是选择倒立的汉字，本文采用手动输入验证码的形式完成验证，最后获取cookie，存入文件中，之后便可以无需登录直接访问了。<br>所用python的包：requests，BeautifulSoup，json</p>\n</blockquote>\n<p>首先之前使用python请求网页有层出不穷的包，但是用了requests之后才知道它有多方便，详情可以参考这篇文章，也是python之禅公众号的文章，这里帮忙推荐一波—&gt;<a href=\"http://mp.weixin.qq.com/s/gO8E3lXZiL6_ql5rDuHwMQ\" target=\"_blank\" rel=\"noopener\">链接</a>。<br>下面一步步开始讲解如何模拟登录。</p>\n<h2 id=\"1-观察请求参数（FireFox-Chrome）\"><a href=\"#1-观察请求参数（FireFox-Chrome）\" class=\"headerlink\" title=\"1.观察请求参数（FireFox/Chrome）\"></a>1.观察请求参数（FireFox/Chrome）</h2><p>在向网站发送请求的时候，服务器会对访问用户进行标识，以cookie的形式存放在浏览器，该浏览器下次进行访问时，则可以跳过登陆直接浏览页面，这是我们模拟知乎登陆的主要目的，获取cookie后，使用cookie访问主页面，则可以跳过登陆。在火狐中，先清掉之前保存的cookie，以模拟浏览器首次访问。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9e6c660f8d81b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"清除火狐cookie\"><br>清除cookie后，试着登陆知乎，发现有验证码，打开F12，一边发请求，一边观察网络中的变化。<br>这里故意输错密码，看看发送了什么请求。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-2679b4d38f31cd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"登陆请求头\"><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-500e37e330a78361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"登陆请求参数\"></p>\n<p>_xsrf的参数是用于防止xsrf攻击，如何防止xsrf攻击，可以参考<a href=\"http://blog.csdn.net/newjueqi/article/details/7542409\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，这是一种简单的恶意链接攻击，可以直接让你访问目标网站并且修改你的密码，所以一般在提交的表单中加个_xsrf参数，只有参数正确才可以进行提交。</p>\n<h2 id=\"2-代码模拟请求\"><a href=\"#2-代码模拟请求\" class=\"headerlink\" title=\"2.代码模拟请求\"></a>2.代码模拟请求</h2><p>可以看到知乎的主要请求参数，还有email,password,captcha,captcha_type。<br>自己试验过，captcha_type可以不用填写，首先还是找到验证码的链接如下：<br><a href=\"https://www.zhihu.com/captcha.gif?r=1503020715890&amp;type=login&amp;lang=cn\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/captcha.gif?r=1503020715890&amp;type=login&amp;lang=cn</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-8a5e858b5322688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"获取验证码的链接\"><br>很明显，中间的数字是以毫秒为单位的时间戳，因此在代码中很容易模拟这个链接去发送请求获取验证码的图片。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_captcha():</span><br><span class=\"line\">    timestamp = str(time.time()*1000).split(&quot;.&quot;)[0]</span><br><span class=\"line\">    url = &quot;https://www.zhihu.com/captcha.gif?r=%s&amp;type=login&amp;lang=cn&quot; % timestamp</span><br><span class=\"line\">    print(url)</span><br><span class=\"line\">    req = session.get(url,headers=headers)</span><br><span class=\"line\">    with open(&quot;img1.png&quot;,&apos;wb&apos;) as f:</span><br><span class=\"line\">        f.write(req.content)</span><br></pre></td></tr></table></figure></p>\n<p>我采用的方式是人工识别，所以把图片以二进制的形式写入文件，自己点开查看。<br>得到的内容是一行汉字：<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-c31e380d68644a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400\" alt=\"知乎验证码\"><br>点击倒立的汉字，获取响应的坐标，放在请求参数中，即可模拟鼠标点击的过程，可以自己点击几个点，大概找到1234567个汉字的坐标，然后根据汉字的个数，匹配响应的坐标点，填入参数中即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_code():</span><br><span class=\"line\">    get_captcha()</span><br><span class=\"line\">    print(&quot;输入倒立汉字的位置，用逗号隔开&quot;)</span><br><span class=\"line\">    a = input(&quot;input:&quot;)</span><br><span class=\"line\">    indexs = a.split(&quot;,&quot;)</span><br><span class=\"line\">    data=[[16.4,26.9],[33.4,26.9],[60.4,21.9],[84.4,24.9],[108.4,24.9],[130.4,24.9],[156.4,24.9]]</span><br><span class=\"line\">    input_points = []</span><br><span class=\"line\">    for idx in indexs:</span><br><span class=\"line\">        input_points.append(data[int(idx)-1])</span><br><span class=\"line\">    dict = &#123;</span><br><span class=\"line\">        &quot;img_size&quot;: [200, 44],</span><br><span class=\"line\">        &quot;input_points&quot;: input_points</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dict</span><br></pre></td></tr></table></figure></p>\n<p>有了xsrf参数和验证码，输入自己的账号密码，即可模拟登录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def login():</span><br><span class=\"line\">    url = &quot;https://www.zhihu.com/login/email&quot;</span><br><span class=\"line\">    data=&#123;</span><br><span class=\"line\">        &quot;_xsrf&quot;:get_xsrf(),</span><br><span class=\"line\">        &quot;email&quot;:&apos;******@qq.com&apos;,</span><br><span class=\"line\">        &quot;password&quot;:&apos;asfgasdfasf&apos;,</span><br><span class=\"line\">        &apos;captcha_type&apos;:get_code()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    response = session.post(url, data=data,headers=headers)</span><br><span class=\"line\">    login_code = response.json()</span><br><span class=\"line\">    print(login_code[&apos;msg&apos;])</span><br><span class=\"line\">    response = session.get(&quot;https://www.zhihu.com/settings/profile&quot;,headers=headers)</span><br><span class=\"line\">    #将cookies-&gt;dict-&gt;json存放在txt|之后再json-&gt;dict直接使用</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;w&apos;) as f:</span><br><span class=\"line\">        json.dump(session.cookies.get_dict(),f)</span><br><span class=\"line\">    with open(&quot;login.html&quot;,&quot;wb&quot;) as f:</span><br><span class=\"line\">        f.write(response.content)</span><br></pre></td></tr></table></figure></p>\n<p>第一次登录结束后，session.cookie会自动保持登录状态的cookie，下一次进行登录时，使用cookie即可，这里进行持久化，暂时写在txt文件中，下次使用时直接从文件获取。<br>这里有个小插曲就是session.cookie的类型是RequestCookie不是dict或者str，这里使用get_dict()方法转化成dict，并用json的形式存在txt文件中，取出来的时候，json可以直接提取成dict，放入session.cookie可以直接使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#将cookies-&gt;dict-&gt;json存放在txt|之后再json-&gt;dict直接使用</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;w&apos;) as f:</span><br><span class=\"line\">        json.dump(session.cookies.get_dict(),f)</span><br><span class=\"line\"></span><br><span class=\"line\">#从txt文件中获取cookies,json-&gt;dict存入session.cookies</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;r&apos;) as f:</span><br><span class=\"line\">        cookies = json.load(f)</span><br><span class=\"line\">    session.cookies.update(cookies)</span><br></pre></td></tr></table></figure></p>\n<p>这里也可以温习下，Python中Json的操作-&gt;<a href=\"http://www.jianshu.com/p/26cb66297a6a\" target=\"_blank\" rel=\"noopener\">链接</a><br>获取cookie后，我尝试登录了(<a href=\"https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。</a></p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>写知乎登录，主要也是练练手，觉得挺有意思，后面可以尝试用phantomjs+selenium模拟下登录爬取，有了登录cookie之后，也可以爬一下知乎的内容，应该有很多有趣的内容，后续会继续更新的，谢谢关注~<br>github上我也上传了代码，欢迎大家点评，学习。<br><a href=\"https://github.com/Fan4J/Spiders-of-frequently-used-website/tree/master/zhihuLogin\" target=\"_blank\" rel=\"noopener\">源码地址</a><br><a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">重塑自我</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>前言：最近看到公众号python之禅里面的历史文章，模拟登录知乎，又看到很多人在网上尝试写代码，自己也想试试，最新的验证码是选择倒立的汉字，本文采用手动输入验证码的形式完成验证，最后获取cookie，存入文件中，之后便可以无需登录直接访问了。<br>所用python的包：requests，BeautifulSoup，json</p>\n</blockquote>\n<p>首先之前使用python请求网页有层出不穷的包，但是用了requests之后才知道它有多方便，详情可以参考这篇文章，也是python之禅公众号的文章，这里帮忙推荐一波—&gt;<a href=\"http://mp.weixin.qq.com/s/gO8E3lXZiL6_ql5rDuHwMQ\" target=\"_blank\" rel=\"noopener\">链接</a>。<br>下面一步步开始讲解如何模拟登录。</p>\n<h2 id=\"1-观察请求参数（FireFox-Chrome）\"><a href=\"#1-观察请求参数（FireFox-Chrome）\" class=\"headerlink\" title=\"1.观察请求参数（FireFox/Chrome）\"></a>1.观察请求参数（FireFox/Chrome）</h2><p>在向网站发送请求的时候，服务器会对访问用户进行标识，以cookie的形式存放在浏览器，该浏览器下次进行访问时，则可以跳过登陆直接浏览页面，这是我们模拟知乎登陆的主要目的，获取cookie后，使用cookie访问主页面，则可以跳过登陆。在火狐中，先清掉之前保存的cookie，以模拟浏览器首次访问。<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-9e6c660f8d81b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"清除火狐cookie\"><br>清除cookie后，试着登陆知乎，发现有验证码，打开F12，一边发请求，一边观察网络中的变化。<br>这里故意输错密码，看看发送了什么请求。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-2679b4d38f31cd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"登陆请求头\"><br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-500e37e330a78361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"登陆请求参数\"></p>\n<p>_xsrf的参数是用于防止xsrf攻击，如何防止xsrf攻击，可以参考<a href=\"http://blog.csdn.net/newjueqi/article/details/7542409\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，这是一种简单的恶意链接攻击，可以直接让你访问目标网站并且修改你的密码，所以一般在提交的表单中加个_xsrf参数，只有参数正确才可以进行提交。</p>\n<h2 id=\"2-代码模拟请求\"><a href=\"#2-代码模拟请求\" class=\"headerlink\" title=\"2.代码模拟请求\"></a>2.代码模拟请求</h2><p>可以看到知乎的主要请求参数，还有email,password,captcha,captcha_type。<br>自己试验过，captcha_type可以不用填写，首先还是找到验证码的链接如下：<br><a href=\"https://www.zhihu.com/captcha.gif?r=1503020715890&amp;type=login&amp;lang=cn\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/captcha.gif?r=1503020715890&amp;type=login&amp;lang=cn</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-8a5e858b5322688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"获取验证码的链接\"><br>很明显，中间的数字是以毫秒为单位的时间戳，因此在代码中很容易模拟这个链接去发送请求获取验证码的图片。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_captcha():</span><br><span class=\"line\">    timestamp = str(time.time()*1000).split(&quot;.&quot;)[0]</span><br><span class=\"line\">    url = &quot;https://www.zhihu.com/captcha.gif?r=%s&amp;type=login&amp;lang=cn&quot; % timestamp</span><br><span class=\"line\">    print(url)</span><br><span class=\"line\">    req = session.get(url,headers=headers)</span><br><span class=\"line\">    with open(&quot;img1.png&quot;,&apos;wb&apos;) as f:</span><br><span class=\"line\">        f.write(req.content)</span><br></pre></td></tr></table></figure></p>\n<p>我采用的方式是人工识别，所以把图片以二进制的形式写入文件，自己点开查看。<br>得到的内容是一行汉字：<br><img src=\"http://upload-images.jianshu.io/upload_images/5834071-c31e380d68644a7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400\" alt=\"知乎验证码\"><br>点击倒立的汉字，获取响应的坐标，放在请求参数中，即可模拟鼠标点击的过程，可以自己点击几个点，大概找到1234567个汉字的坐标，然后根据汉字的个数，匹配响应的坐标点，填入参数中即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_code():</span><br><span class=\"line\">    get_captcha()</span><br><span class=\"line\">    print(&quot;输入倒立汉字的位置，用逗号隔开&quot;)</span><br><span class=\"line\">    a = input(&quot;input:&quot;)</span><br><span class=\"line\">    indexs = a.split(&quot;,&quot;)</span><br><span class=\"line\">    data=[[16.4,26.9],[33.4,26.9],[60.4,21.9],[84.4,24.9],[108.4,24.9],[130.4,24.9],[156.4,24.9]]</span><br><span class=\"line\">    input_points = []</span><br><span class=\"line\">    for idx in indexs:</span><br><span class=\"line\">        input_points.append(data[int(idx)-1])</span><br><span class=\"line\">    dict = &#123;</span><br><span class=\"line\">        &quot;img_size&quot;: [200, 44],</span><br><span class=\"line\">        &quot;input_points&quot;: input_points</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dict</span><br></pre></td></tr></table></figure></p>\n<p>有了xsrf参数和验证码，输入自己的账号密码，即可模拟登录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def login():</span><br><span class=\"line\">    url = &quot;https://www.zhihu.com/login/email&quot;</span><br><span class=\"line\">    data=&#123;</span><br><span class=\"line\">        &quot;_xsrf&quot;:get_xsrf(),</span><br><span class=\"line\">        &quot;email&quot;:&apos;******@qq.com&apos;,</span><br><span class=\"line\">        &quot;password&quot;:&apos;asfgasdfasf&apos;,</span><br><span class=\"line\">        &apos;captcha_type&apos;:get_code()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    response = session.post(url, data=data,headers=headers)</span><br><span class=\"line\">    login_code = response.json()</span><br><span class=\"line\">    print(login_code[&apos;msg&apos;])</span><br><span class=\"line\">    response = session.get(&quot;https://www.zhihu.com/settings/profile&quot;,headers=headers)</span><br><span class=\"line\">    #将cookies-&gt;dict-&gt;json存放在txt|之后再json-&gt;dict直接使用</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;w&apos;) as f:</span><br><span class=\"line\">        json.dump(session.cookies.get_dict(),f)</span><br><span class=\"line\">    with open(&quot;login.html&quot;,&quot;wb&quot;) as f:</span><br><span class=\"line\">        f.write(response.content)</span><br></pre></td></tr></table></figure></p>\n<p>第一次登录结束后，session.cookie会自动保持登录状态的cookie，下一次进行登录时，使用cookie即可，这里进行持久化，暂时写在txt文件中，下次使用时直接从文件获取。<br>这里有个小插曲就是session.cookie的类型是RequestCookie不是dict或者str，这里使用get_dict()方法转化成dict，并用json的形式存在txt文件中，取出来的时候，json可以直接提取成dict，放入session.cookie可以直接使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#将cookies-&gt;dict-&gt;json存放在txt|之后再json-&gt;dict直接使用</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;w&apos;) as f:</span><br><span class=\"line\">        json.dump(session.cookies.get_dict(),f)</span><br><span class=\"line\"></span><br><span class=\"line\">#从txt文件中获取cookies,json-&gt;dict存入session.cookies</span><br><span class=\"line\">    with open(&quot;cookies.txt&quot;,&apos;r&apos;) as f:</span><br><span class=\"line\">        cookies = json.load(f)</span><br><span class=\"line\">    session.cookies.update(cookies)</span><br></pre></td></tr></table></figure></p>\n<p>这里也可以温习下，Python中Json的操作-&gt;<a href=\"http://www.jianshu.com/p/26cb66297a6a\" target=\"_blank\" rel=\"noopener\">链接</a><br>获取cookie后，我尝试登录了(<a href=\"https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/settings/profile)这个地址，可以不需登录正常访问。</a></p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>写知乎登录，主要也是练练手，觉得挺有意思，后面可以尝试用phantomjs+selenium模拟下登录爬取，有了登录cookie之后，也可以爬一下知乎的内容，应该有很多有趣的内容，后续会继续更新的，谢谢关注~<br>github上我也上传了代码，欢迎大家点评，学习。<br><a href=\"https://github.com/Fan4J/Spiders-of-frequently-used-website/tree/master/zhihuLogin\" target=\"_blank\" rel=\"noopener\">源码地址</a><br><a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">重塑自我</a></p>\n"},{"title":"新的开始","date":"2017-07-24T06:13:09.000Z","comments":1,"_content":"\n```\n勤学，\n\n苦练，\n\n只想赶上，\n\n平行世界，\n\n更好的那个自己，\n\n以此自勉。\n\n```","source":"_posts/第一篇博客.md","raw":"---\ntitle: 新的开始\ndate: 2017-07-24 14:13:09\ntags: \"随笔\"\ncomments: true\n---\n\n```\n勤学，\n\n苦练，\n\n只想赶上，\n\n平行世界，\n\n更好的那个自己，\n\n以此自勉。\n\n```","slug":"第一篇博客","published":1,"updated":"2018-07-30T15:04:59.015Z","layout":"post","photos":[],"link":"","_id":"cjy3u76w50008tgrlcktssg5a","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">勤学，</span><br><span class=\"line\"></span><br><span class=\"line\">苦练，</span><br><span class=\"line\"></span><br><span class=\"line\">只想赶上，</span><br><span class=\"line\"></span><br><span class=\"line\">平行世界，</span><br><span class=\"line\"></span><br><span class=\"line\">更好的那个自己，</span><br><span class=\"line\"></span><br><span class=\"line\">以此自勉。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">勤学，</span><br><span class=\"line\"></span><br><span class=\"line\">苦练，</span><br><span class=\"line\"></span><br><span class=\"line\">只想赶上，</span><br><span class=\"line\"></span><br><span class=\"line\">平行世界，</span><br><span class=\"line\"></span><br><span class=\"line\">更好的那个自己，</span><br><span class=\"line\"></span><br><span class=\"line\">以此自勉。</span><br></pre></td></tr></table></figure>"},{"title":"ubuntu之初体验","date":"2018-05-29T06:13:09.000Z","comments":1,"_content":">进来为了研究hadoop,心血来潮的把自己家里pc装了ubuntu.刚开始不太会用,这里记录下一些经验\n\n## 1 软件安装顺序\n1.java jdk 环境变量\n2.python\n3.idea pycharm\n4.搜狗拼音\n5.sublimetext\n6.shutter 暂时不太会用\n\n## 2 安装软件\n通常的方式有yum apt-get 例如\n```\nyum install python3.4\nsudo apt-get python\n```\n如果是yum库和ubuntu软件库没有添加的软件可以下载源码安装\n```\ntar -xf archive.tar\n```\n解压后放在自己熟悉的目录我一般是\n```\nsudo mv ~/Downloads/archive /usr/local/share\n```\n一般我会做两步 1.通过加软链接,实现终端打开软件 2.创建桌面图标,桌面打开 eg\n```\nln -s /usr/local/share/sublime_text_3 /usr/bin/sublime\n```\n完成后在终端的任何地方输入sublime即可打开\n```\ncd  /usr/share/applications\nvi  sublime.desktop\n```\n进入编辑 替换Name为软件的名字 Icon为图标的图片地址 Exec 是执行脚本的位置\n```\n[Desktop Entry]\n\nType=Application\n\nName=SublimeText\n\nIcon=/usr/local/share/sublime_text_3/Icon/256x256/sublime-text.png\n\nExec=/usr/local/share/sublime_text_3/sublime_text\n\nTerminal=false\n\nCategories=Network;InstantMessaging\n```\n完成以后可以在应用程序中看到,点击收藏即可显示在左边侧边栏了\n\n![屏幕截图.png](https://upload-images.jianshu.io/upload_images/5834071-9f2cb874755d2871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3 切换繁体简体\nCtrl+Shift+F\n","source":"_posts/ubuntu之初体验.md","raw":"---\ntitle: ubuntu之初体验\ndate: 2018-05-29 14:13:09\ntags: Linux\ncomments: true\n---\n>进来为了研究hadoop,心血来潮的把自己家里pc装了ubuntu.刚开始不太会用,这里记录下一些经验\n\n## 1 软件安装顺序\n1.java jdk 环境变量\n2.python\n3.idea pycharm\n4.搜狗拼音\n5.sublimetext\n6.shutter 暂时不太会用\n\n## 2 安装软件\n通常的方式有yum apt-get 例如\n```\nyum install python3.4\nsudo apt-get python\n```\n如果是yum库和ubuntu软件库没有添加的软件可以下载源码安装\n```\ntar -xf archive.tar\n```\n解压后放在自己熟悉的目录我一般是\n```\nsudo mv ~/Downloads/archive /usr/local/share\n```\n一般我会做两步 1.通过加软链接,实现终端打开软件 2.创建桌面图标,桌面打开 eg\n```\nln -s /usr/local/share/sublime_text_3 /usr/bin/sublime\n```\n完成后在终端的任何地方输入sublime即可打开\n```\ncd  /usr/share/applications\nvi  sublime.desktop\n```\n进入编辑 替换Name为软件的名字 Icon为图标的图片地址 Exec 是执行脚本的位置\n```\n[Desktop Entry]\n\nType=Application\n\nName=SublimeText\n\nIcon=/usr/local/share/sublime_text_3/Icon/256x256/sublime-text.png\n\nExec=/usr/local/share/sublime_text_3/sublime_text\n\nTerminal=false\n\nCategories=Network;InstantMessaging\n```\n完成以后可以在应用程序中看到,点击收藏即可显示在左边侧边栏了\n\n![屏幕截图.png](https://upload-images.jianshu.io/upload_images/5834071-9f2cb874755d2871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3 切换繁体简体\nCtrl+Shift+F\n","slug":"ubuntu之初体验","published":1,"updated":"2018-07-30T15:04:59.014Z","layout":"post","photos":[],"link":"","_id":"cjy3u76w6000atgrl7mxhuthm","content":"<blockquote>\n<p>进来为了研究hadoop,心血来潮的把自己家里pc装了ubuntu.刚开始不太会用,这里记录下一些经验</p>\n</blockquote>\n<h2 id=\"1-软件安装顺序\"><a href=\"#1-软件安装顺序\" class=\"headerlink\" title=\"1 软件安装顺序\"></a>1 软件安装顺序</h2><p>1.java jdk 环境变量<br>2.python<br>3.idea pycharm<br>4.搜狗拼音<br>5.sublimetext<br>6.shutter 暂时不太会用</p>\n<h2 id=\"2-安装软件\"><a href=\"#2-安装软件\" class=\"headerlink\" title=\"2 安装软件\"></a>2 安装软件</h2><p>通常的方式有yum apt-get 例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python3.4</span><br><span class=\"line\">sudo apt-get python</span><br></pre></td></tr></table></figure></p>\n<p>如果是yum库和ubuntu软件库没有添加的软件可以下载源码安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf archive.tar</span><br></pre></td></tr></table></figure></p>\n<p>解压后放在自己熟悉的目录我一般是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mv ~/Downloads/archive /usr/local/share</span><br></pre></td></tr></table></figure></p>\n<p>一般我会做两步 1.通过加软链接,实现终端打开软件 2.创建桌面图标,桌面打开 eg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /usr/local/share/sublime_text_3 /usr/bin/sublime</span><br></pre></td></tr></table></figure></p>\n<p>完成后在终端的任何地方输入sublime即可打开<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd  /usr/share/applications</span><br><span class=\"line\">vi  sublime.desktop</span><br></pre></td></tr></table></figure></p>\n<p>进入编辑 替换Name为软件的名字 Icon为图标的图片地址 Exec 是执行脚本的位置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\"></span><br><span class=\"line\">Type=Application</span><br><span class=\"line\"></span><br><span class=\"line\">Name=SublimeText</span><br><span class=\"line\"></span><br><span class=\"line\">Icon=/usr/local/share/sublime_text_3/Icon/256x256/sublime-text.png</span><br><span class=\"line\"></span><br><span class=\"line\">Exec=/usr/local/share/sublime_text_3/sublime_text</span><br><span class=\"line\"></span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\"></span><br><span class=\"line\">Categories=Network;InstantMessaging</span><br></pre></td></tr></table></figure></p>\n<p>完成以后可以在应用程序中看到,点击收藏即可显示在左边侧边栏了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5834071-9f2cb874755d2871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图.png\"></p>\n<h2 id=\"3-切换繁体简体\"><a href=\"#3-切换繁体简体\" class=\"headerlink\" title=\"3 切换繁体简体\"></a>3 切换繁体简体</h2><p>Ctrl+Shift+F</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>进来为了研究hadoop,心血来潮的把自己家里pc装了ubuntu.刚开始不太会用,这里记录下一些经验</p>\n</blockquote>\n<h2 id=\"1-软件安装顺序\"><a href=\"#1-软件安装顺序\" class=\"headerlink\" title=\"1 软件安装顺序\"></a>1 软件安装顺序</h2><p>1.java jdk 环境变量<br>2.python<br>3.idea pycharm<br>4.搜狗拼音<br>5.sublimetext<br>6.shutter 暂时不太会用</p>\n<h2 id=\"2-安装软件\"><a href=\"#2-安装软件\" class=\"headerlink\" title=\"2 安装软件\"></a>2 安装软件</h2><p>通常的方式有yum apt-get 例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python3.4</span><br><span class=\"line\">sudo apt-get python</span><br></pre></td></tr></table></figure></p>\n<p>如果是yum库和ubuntu软件库没有添加的软件可以下载源码安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf archive.tar</span><br></pre></td></tr></table></figure></p>\n<p>解压后放在自己熟悉的目录我一般是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mv ~/Downloads/archive /usr/local/share</span><br></pre></td></tr></table></figure></p>\n<p>一般我会做两步 1.通过加软链接,实现终端打开软件 2.创建桌面图标,桌面打开 eg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /usr/local/share/sublime_text_3 /usr/bin/sublime</span><br></pre></td></tr></table></figure></p>\n<p>完成后在终端的任何地方输入sublime即可打开<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd  /usr/share/applications</span><br><span class=\"line\">vi  sublime.desktop</span><br></pre></td></tr></table></figure></p>\n<p>进入编辑 替换Name为软件的名字 Icon为图标的图片地址 Exec 是执行脚本的位置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\"></span><br><span class=\"line\">Type=Application</span><br><span class=\"line\"></span><br><span class=\"line\">Name=SublimeText</span><br><span class=\"line\"></span><br><span class=\"line\">Icon=/usr/local/share/sublime_text_3/Icon/256x256/sublime-text.png</span><br><span class=\"line\"></span><br><span class=\"line\">Exec=/usr/local/share/sublime_text_3/sublime_text</span><br><span class=\"line\"></span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\"></span><br><span class=\"line\">Categories=Network;InstantMessaging</span><br></pre></td></tr></table></figure></p>\n<p>完成以后可以在应用程序中看到,点击收藏即可显示在左边侧边栏了</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5834071-9f2cb874755d2871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图.png\"></p>\n<h2 id=\"3-切换繁体简体\"><a href=\"#3-切换繁体简体\" class=\"headerlink\" title=\"3 切换繁体简体\"></a>3 切换繁体简体</h2><p>Ctrl+Shift+F</p>\n"},{"title":"SpringBoot实现RESTAPI","date":"2017-10-25T09:28:09.000Z","comments":1,"_content":">如题，本文讲述如何使用Springboot实现restapi,这里感谢开源社区的作者@简单的土豆，和他的源码[https://github.com/Fan4J/spring-boot-api-project-seed.git](https://github.com/Fan4J/spring-boot-api-project-seed.git)\n\n## 1基本配置\n![项目结构.png](http://upload-images.jianshu.io/upload_images/5834071-d8ba22876750345e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n基本配置包括分环境的profile配置， log4j2配置，mybatis的配置，maven依赖的添加，统一结果封装，结果生成器等等。\n这里作者使用了mybatis通用mapper\n```\npublic interface Mapper<T>\n        extends\n        BaseMapper<T>,\n        ConditionMapper<T>,\n        IdsMapper<T>,\n        InsertListMapper<T> {\n}\n```\n通用service接口\n```\npublic interface Service<T> {\n    void save(T model);//持久化\n    void save(List<T> models);//批量持久化\n    void deleteById(Long id);//通过主鍵刪除\n    void deleteByIds(String ids);//批量刪除 eg：ids -> “1,2,3,4”\n    void update(T model);//更新\n    T findById(Long id);//通过ID查找\n    T findBy(String fieldName, Object value) throws TooManyResultsException; //通过Model中某个成员变量名称（非数据表中column的名称）查找,value需符合unique约束\n    List<T> findByIds(String ids);//通过多个ID查找//eg：ids -> “1,2,3,4”\n    List<T> findByCondition(Condition condition);//根据条件查找\n    List<T> findAll();//获取所有\n}\n```\n然后实现abstractService，用通用mapper实现了service,后面的service，只需继承abstractService即可\n```\npublic abstract class AbstractService<T> implements Service<T> {\n\n    @Autowired\n    protected Mapper<T> mapper;\n\n    private Class<T> modelClass;    // 当前泛型真实类型的Class\n\n    public AbstractService() {\n        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();\n        modelClass = (Class<T>) pt.getActualTypeArguments()[0];\n    }\n\n    public void save(T model) {\n        mapper.insertSelective(model);\n    }\n\n    public void save(List<T> models) {\n        mapper.insertList(models);\n    }\n\n    public void deleteById(Long id) {\n        mapper.deleteByPrimaryKey(id);\n    }\n\n    public void deleteByIds(String ids) {\n        mapper.deleteByIds(ids);\n    }\n\n    public void update(T model) {\n        mapper.updateByPrimaryKeySelective(model);\n    }\n\n    public T findById(Long id) {\n        return mapper.selectByPrimaryKey(id);\n    }\n\n    @Override\n    public T findBy(String fieldName, Object value) throws TooManyResultsException {\n        try {\n            T model = modelClass.newInstance();\n            Field field = modelClass.getDeclaredField(fieldName);\n            field.setAccessible(true);\n            field.set(model, value);\n            return mapper.selectOne(model);\n        } catch (ReflectiveOperationException e) {\n            throw new ServiceException(e.getMessage(), e);\n        }\n    }\n\n    public List<T> findByIds(String ids) {\n        return mapper.selectByIds(ids);\n    }\n\n    public List<T> findByCondition(Condition condition) {\n        return mapper.selectByCondition(condition);\n    }\n\n    public List<T> findAll() {\n        return mapper.selectAll();\n    }\n}\n\n```\n## 2.下面看看Controller\n先上代码\n```\n@RestController\npublic class FetchConfigController {\n\n    @Autowired\n    UserInfoService userInfoService;\n\n    @PostMapping(value = \"/add\", consumes = \"application/json\", produces = \"application/json\")\n    public Result add(@RequestBody UserInfo userInfo) {\n        userInfoService.save(userInfo);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/delete\")\n    public Result delete(@RequestParam Long id) {\n        userInfoService.deleteById(id);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/update\")\n    public Result update(@RequestBody UserInfo userInfo) {\n        userInfoService.update(userInfo);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/detail\")\n    public Result detail(@RequestParam Long id) {\n        UserInfo userInfo = userInfoService.findById(id);\n        return ResultCodeGenerator.genSuccessResult(userInfo);\n    }\n\n    @PostMapping(\"/list\")\n    public Result list(@RequestParam(defaultValue = \"0\") Integer page, @RequestParam(defaultValue = \"0\") Integer size) {\n        PageHelper.startPage(page, size);\n        List<UserInfo> list = userInfoService.findAll();\n        PageInfo pageInfo = new PageInfo(list);\n        return ResultCodeGenerator.genSuccessResult(pageInfo);\n    }\n\n}\n```\n1@RestController，可以看到它是@Controller/@ResponseBody的结合体，@ResponseBody这个注解在RESTAPI 中很有意义，它不是将返回资源定位到resouces下面的html/css/js生成视图，而是直接以写入输出流返回给客户端。\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default \"\";\n}\n```\n这里不得不提到HttpMessageConverter，这个转换器顾名思义，是将httprequest输入流读成对象，或者字符串，再返回的时候将对象转换成HttpResponse输出流\n```\npublic interface HttpMessageConverter<T> {\n    boolean canRead(Class<?> var1, MediaType var2);\n\n    boolean canWrite(Class<?> var1, MediaType var2);\n\n    List<MediaType> getSupportedMediaTypes();\n\n    T read(Class<? extends T> var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;\n\n    void write(T var1, MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;\n}\n```\n可以看到它是个泛型的接口，主要的两个方法是read/write canread/write,Spring已经实现了abstractHttpMessageConverter，自己可以继承这个abstract的class，拿来使用。converter用canread/write检查http流的类型，然后返回是true,就用read/write方法去读写。一般都是用别人写好的converter,例如阿里的fastjson的converter，可以用于处理application/json,例如MappingJackson2XmlHttpMessageConverter用于处理application/xml。这些内容可以配在configure文件中\n```\n@Configuration\npublic class WebMvcConfigurer extends WebMvcConfigurerAdapter {\n\n    private static Logger logger = LogManager.getLogger();\n\n    //当前激活的配置文件\n    @Value(\"${spring.profiles.active}\")\n    private String env;\n\n    //使用阿里 FastJson 作为JSON MessageConverter\n    //使用MappingJackson2XmlHttpMessageConverter进行xml的转换\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        FastJsonHttpMessageConverter4 converter = new FastJsonHttpMessageConverter4();\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue,//保留空的字段\n                SerializerFeature.WriteNullStringAsEmpty,//String null -> \"\"\n                SerializerFeature.WriteNullNumberAsZero);//Number null -> 0\n        converter.setFastJsonConfig(config);\n        converter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        MappingJackson2XmlHttpMessageConverter converter1 = new MappingJackson2XmlHttpMessageConverter();\n        converters.add(converter1);\n        converters.add(converter);\n    }\n```\n\n我这里添加了两个converter,分别用来处理json和xml.\n2.@PostMapping其实是@RequestMapping(method = {RequestMethod.POST})的缩写\n3.@RequestParam其实还可以加入default和require的设置\n4.@RequestBody直接把inputstream中的json通过converter读成对象进行处理，和@responsebody对应将对象写成json放入outputstream\n\n## 3.研究下Spring自带的RestTemplate\n通常我们进行http请求是用apache的httpclient，而且功能比较强大，这里spring也集成了自己的rest请求方法\n```\nprivate static ClientHttpRequestFactory getSimpleClientHttpRequestFactory() {\n        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();\n        factory.setReadTimeout(60000);//ms\n        factory.setConnectTimeout(30000);//ms\n        return factory;\n }\n```\nRestTemplate直接new就可以使用了，构造方法里可以注入一个factory用于统一设置一些参数\n```\nprivate static RestTemplate getRestTemplate(ClientHttpRequestFactory factory) {\n        RestTemplate restTemplate = new RestTemplate(factory);\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        StringHttpMessageConverter stringHttpMessageConverter\n                = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        stringHttpMessageConverter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        messageConverters.add(stringHttpMessageConverter);\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new FastJsonHttpMessageConverter4());\n        restTemplate.setMessageConverters(messageConverters);\n        return restTemplate;\n    }\n```\ntemplate里面统一可以注入converter,这里我加入了3个converter，这里注意StringmessageConverter里面默认的字符是ISO-8859-1，所以new一个新的converter并且设置编码防止出错，剩下的就是简单粗暴的直接使用咯\n```\n        RestTemplate restTemplate = getRestTemplate(getSimpleClientHttpRequestFactory());\n        String url = \"http://localhost:7777/dcs/list\";\n//        HttpHeaders headers = new HttpHeaders();\n//        headers.setContentType(MediaType.ALL.APPLICATION_JSON);\n//        UserInfo userInfo = new UserInfo().setUserId((long) 1231).\n//                setUserName(\"test\").setAge(13).setEmail(\"fafa@jancy.com\");\n//        HttpEntity request = new HttpEntity(userInfo, headers);\n//        Result result = restTemplate.postForObject(url, request, Result.class);\n//        System.out.println(JSON.toJSONString(result));\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        MultiValueMap<String, Integer> map = new LinkedMultiValueMap<>();\n        map.add(\"page\", 1);\n        map.add(\"size\", 5);\n        HttpEntity<MultiValueMap<String, Integer>> request = new HttpEntity<>(map, headers);\n        Result result = restTemplate.postForObject(url, request, Result.class);\n        System.out.println(JSON.toJSONString(result));\n```\n根据api的不同，既可以直接传入只要把HttpEntity包装好即可。\n除了写在main函数中，也可以用Spring的注解加载factory/restemplate\n```\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate restTemplate(ClientHttpRequestFactory factory){\n        RestTemplate restTemplate = new RestTemplate(factory);\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        StringHttpMessageConverter stringHttpMessageConverter\n            = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        stringHttpMessageConverter.setDefaultCharset(Charsets.UTF_8);\n        messageConverters.add(stringHttpMessageConverter);\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new FastJsonHttpMessageConverter());\n        restTemplate.setMessageConverters(messageConverters);\n        return restTemplate;\n    }\n\n    @Bean\n    public ClientHttpRequestFactory simpleClientHttpRequestFactory(){\n        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();\n        factory.setReadTimeout(60000);//ms\n        factory.setConnectTimeout(30000);//ms\n        return factory;\n    }\n}\n```\n在其他代码里只用@autowired即可使用\n\n## 4.总结\n以上就是如何用Springboot构建restApi，其实还可以和数据库做很多交互，还有签名认证，session管理等东西，都到后面完善吧。源码地址在最开始就贴了，是个开源的项目，HttpMessageConverter，如何得到json、xml的返回，都需要操作操作。继续努力吧\n[个人博客](https://fan4j.github.io/) 欢迎访问~","source":"_posts/SpringBoot实现REST.md","raw":"---\ntitle: SpringBoot实现RESTAPI\ndate: 2017-10-25 17:28:09\ntags: \n\t- Java\t\n\t- Spring\n\t- Rest\ncomments: true\n---\n>如题，本文讲述如何使用Springboot实现restapi,这里感谢开源社区的作者@简单的土豆，和他的源码[https://github.com/Fan4J/spring-boot-api-project-seed.git](https://github.com/Fan4J/spring-boot-api-project-seed.git)\n\n## 1基本配置\n![项目结构.png](http://upload-images.jianshu.io/upload_images/5834071-d8ba22876750345e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n基本配置包括分环境的profile配置， log4j2配置，mybatis的配置，maven依赖的添加，统一结果封装，结果生成器等等。\n这里作者使用了mybatis通用mapper\n```\npublic interface Mapper<T>\n        extends\n        BaseMapper<T>,\n        ConditionMapper<T>,\n        IdsMapper<T>,\n        InsertListMapper<T> {\n}\n```\n通用service接口\n```\npublic interface Service<T> {\n    void save(T model);//持久化\n    void save(List<T> models);//批量持久化\n    void deleteById(Long id);//通过主鍵刪除\n    void deleteByIds(String ids);//批量刪除 eg：ids -> “1,2,3,4”\n    void update(T model);//更新\n    T findById(Long id);//通过ID查找\n    T findBy(String fieldName, Object value) throws TooManyResultsException; //通过Model中某个成员变量名称（非数据表中column的名称）查找,value需符合unique约束\n    List<T> findByIds(String ids);//通过多个ID查找//eg：ids -> “1,2,3,4”\n    List<T> findByCondition(Condition condition);//根据条件查找\n    List<T> findAll();//获取所有\n}\n```\n然后实现abstractService，用通用mapper实现了service,后面的service，只需继承abstractService即可\n```\npublic abstract class AbstractService<T> implements Service<T> {\n\n    @Autowired\n    protected Mapper<T> mapper;\n\n    private Class<T> modelClass;    // 当前泛型真实类型的Class\n\n    public AbstractService() {\n        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();\n        modelClass = (Class<T>) pt.getActualTypeArguments()[0];\n    }\n\n    public void save(T model) {\n        mapper.insertSelective(model);\n    }\n\n    public void save(List<T> models) {\n        mapper.insertList(models);\n    }\n\n    public void deleteById(Long id) {\n        mapper.deleteByPrimaryKey(id);\n    }\n\n    public void deleteByIds(String ids) {\n        mapper.deleteByIds(ids);\n    }\n\n    public void update(T model) {\n        mapper.updateByPrimaryKeySelective(model);\n    }\n\n    public T findById(Long id) {\n        return mapper.selectByPrimaryKey(id);\n    }\n\n    @Override\n    public T findBy(String fieldName, Object value) throws TooManyResultsException {\n        try {\n            T model = modelClass.newInstance();\n            Field field = modelClass.getDeclaredField(fieldName);\n            field.setAccessible(true);\n            field.set(model, value);\n            return mapper.selectOne(model);\n        } catch (ReflectiveOperationException e) {\n            throw new ServiceException(e.getMessage(), e);\n        }\n    }\n\n    public List<T> findByIds(String ids) {\n        return mapper.selectByIds(ids);\n    }\n\n    public List<T> findByCondition(Condition condition) {\n        return mapper.selectByCondition(condition);\n    }\n\n    public List<T> findAll() {\n        return mapper.selectAll();\n    }\n}\n\n```\n## 2.下面看看Controller\n先上代码\n```\n@RestController\npublic class FetchConfigController {\n\n    @Autowired\n    UserInfoService userInfoService;\n\n    @PostMapping(value = \"/add\", consumes = \"application/json\", produces = \"application/json\")\n    public Result add(@RequestBody UserInfo userInfo) {\n        userInfoService.save(userInfo);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/delete\")\n    public Result delete(@RequestParam Long id) {\n        userInfoService.deleteById(id);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/update\")\n    public Result update(@RequestBody UserInfo userInfo) {\n        userInfoService.update(userInfo);\n        return ResultCodeGenerator.genSuccessResult();\n    }\n\n    @PostMapping(\"/detail\")\n    public Result detail(@RequestParam Long id) {\n        UserInfo userInfo = userInfoService.findById(id);\n        return ResultCodeGenerator.genSuccessResult(userInfo);\n    }\n\n    @PostMapping(\"/list\")\n    public Result list(@RequestParam(defaultValue = \"0\") Integer page, @RequestParam(defaultValue = \"0\") Integer size) {\n        PageHelper.startPage(page, size);\n        List<UserInfo> list = userInfoService.findAll();\n        PageInfo pageInfo = new PageInfo(list);\n        return ResultCodeGenerator.genSuccessResult(pageInfo);\n    }\n\n}\n```\n1@RestController，可以看到它是@Controller/@ResponseBody的结合体，@ResponseBody这个注解在RESTAPI 中很有意义，它不是将返回资源定位到resouces下面的html/css/js生成视图，而是直接以写入输出流返回给客户端。\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default \"\";\n}\n```\n这里不得不提到HttpMessageConverter，这个转换器顾名思义，是将httprequest输入流读成对象，或者字符串，再返回的时候将对象转换成HttpResponse输出流\n```\npublic interface HttpMessageConverter<T> {\n    boolean canRead(Class<?> var1, MediaType var2);\n\n    boolean canWrite(Class<?> var1, MediaType var2);\n\n    List<MediaType> getSupportedMediaTypes();\n\n    T read(Class<? extends T> var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;\n\n    void write(T var1, MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;\n}\n```\n可以看到它是个泛型的接口，主要的两个方法是read/write canread/write,Spring已经实现了abstractHttpMessageConverter，自己可以继承这个abstract的class，拿来使用。converter用canread/write检查http流的类型，然后返回是true,就用read/write方法去读写。一般都是用别人写好的converter,例如阿里的fastjson的converter，可以用于处理application/json,例如MappingJackson2XmlHttpMessageConverter用于处理application/xml。这些内容可以配在configure文件中\n```\n@Configuration\npublic class WebMvcConfigurer extends WebMvcConfigurerAdapter {\n\n    private static Logger logger = LogManager.getLogger();\n\n    //当前激活的配置文件\n    @Value(\"${spring.profiles.active}\")\n    private String env;\n\n    //使用阿里 FastJson 作为JSON MessageConverter\n    //使用MappingJackson2XmlHttpMessageConverter进行xml的转换\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        FastJsonHttpMessageConverter4 converter = new FastJsonHttpMessageConverter4();\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue,//保留空的字段\n                SerializerFeature.WriteNullStringAsEmpty,//String null -> \"\"\n                SerializerFeature.WriteNullNumberAsZero);//Number null -> 0\n        converter.setFastJsonConfig(config);\n        converter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        MappingJackson2XmlHttpMessageConverter converter1 = new MappingJackson2XmlHttpMessageConverter();\n        converters.add(converter1);\n        converters.add(converter);\n    }\n```\n\n我这里添加了两个converter,分别用来处理json和xml.\n2.@PostMapping其实是@RequestMapping(method = {RequestMethod.POST})的缩写\n3.@RequestParam其实还可以加入default和require的设置\n4.@RequestBody直接把inputstream中的json通过converter读成对象进行处理，和@responsebody对应将对象写成json放入outputstream\n\n## 3.研究下Spring自带的RestTemplate\n通常我们进行http请求是用apache的httpclient，而且功能比较强大，这里spring也集成了自己的rest请求方法\n```\nprivate static ClientHttpRequestFactory getSimpleClientHttpRequestFactory() {\n        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();\n        factory.setReadTimeout(60000);//ms\n        factory.setConnectTimeout(30000);//ms\n        return factory;\n }\n```\nRestTemplate直接new就可以使用了，构造方法里可以注入一个factory用于统一设置一些参数\n```\nprivate static RestTemplate getRestTemplate(ClientHttpRequestFactory factory) {\n        RestTemplate restTemplate = new RestTemplate(factory);\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        StringHttpMessageConverter stringHttpMessageConverter\n                = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        stringHttpMessageConverter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        messageConverters.add(stringHttpMessageConverter);\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new FastJsonHttpMessageConverter4());\n        restTemplate.setMessageConverters(messageConverters);\n        return restTemplate;\n    }\n```\ntemplate里面统一可以注入converter,这里我加入了3个converter，这里注意StringmessageConverter里面默认的字符是ISO-8859-1，所以new一个新的converter并且设置编码防止出错，剩下的就是简单粗暴的直接使用咯\n```\n        RestTemplate restTemplate = getRestTemplate(getSimpleClientHttpRequestFactory());\n        String url = \"http://localhost:7777/dcs/list\";\n//        HttpHeaders headers = new HttpHeaders();\n//        headers.setContentType(MediaType.ALL.APPLICATION_JSON);\n//        UserInfo userInfo = new UserInfo().setUserId((long) 1231).\n//                setUserName(\"test\").setAge(13).setEmail(\"fafa@jancy.com\");\n//        HttpEntity request = new HttpEntity(userInfo, headers);\n//        Result result = restTemplate.postForObject(url, request, Result.class);\n//        System.out.println(JSON.toJSONString(result));\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        MultiValueMap<String, Integer> map = new LinkedMultiValueMap<>();\n        map.add(\"page\", 1);\n        map.add(\"size\", 5);\n        HttpEntity<MultiValueMap<String, Integer>> request = new HttpEntity<>(map, headers);\n        Result result = restTemplate.postForObject(url, request, Result.class);\n        System.out.println(JSON.toJSONString(result));\n```\n根据api的不同，既可以直接传入只要把HttpEntity包装好即可。\n除了写在main函数中，也可以用Spring的注解加载factory/restemplate\n```\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate restTemplate(ClientHttpRequestFactory factory){\n        RestTemplate restTemplate = new RestTemplate(factory);\n        List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();\n        StringHttpMessageConverter stringHttpMessageConverter\n            = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        stringHttpMessageConverter.setDefaultCharset(Charsets.UTF_8);\n        messageConverters.add(stringHttpMessageConverter);\n        messageConverters.add(new FormHttpMessageConverter());\n        messageConverters.add(new FastJsonHttpMessageConverter());\n        restTemplate.setMessageConverters(messageConverters);\n        return restTemplate;\n    }\n\n    @Bean\n    public ClientHttpRequestFactory simpleClientHttpRequestFactory(){\n        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();\n        factory.setReadTimeout(60000);//ms\n        factory.setConnectTimeout(30000);//ms\n        return factory;\n    }\n}\n```\n在其他代码里只用@autowired即可使用\n\n## 4.总结\n以上就是如何用Springboot构建restApi，其实还可以和数据库做很多交互，还有签名认证，session管理等东西，都到后面完善吧。源码地址在最开始就贴了，是个开源的项目，HttpMessageConverter，如何得到json、xml的返回，都需要操作操作。继续努力吧\n[个人博客](https://fan4j.github.io/) 欢迎访问~","slug":"SpringBoot实现REST","published":1,"updated":"2018-07-30T15:04:59.014Z","layout":"post","photos":[],"link":"","_id":"cjy3u76wp000xtgrlk68794zs","content":"<blockquote>\n<p>如题，本文讲述如何使用Springboot实现restapi,这里感谢开源社区的作者@简单的土豆，和他的源码<a href=\"https://github.com/Fan4J/spring-boot-api-project-seed.git\" target=\"_blank\" rel=\"noopener\">https://github.com/Fan4J/spring-boot-api-project-seed.git</a></p>\n</blockquote>\n<h2 id=\"1基本配置\"><a href=\"#1基本配置\" class=\"headerlink\" title=\"1基本配置\"></a>1基本配置</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-d8ba22876750345e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目结构.png\"><br>基本配置包括分环境的profile配置， log4j2配置，mybatis的配置，maven依赖的添加，统一结果封装，结果生成器等等。<br>这里作者使用了mybatis通用mapper<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Mapper&lt;T&gt;</span><br><span class=\"line\">        extends</span><br><span class=\"line\">        BaseMapper&lt;T&gt;,</span><br><span class=\"line\">        ConditionMapper&lt;T&gt;,</span><br><span class=\"line\">        IdsMapper&lt;T&gt;,</span><br><span class=\"line\">        InsertListMapper&lt;T&gt; &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通用service接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Service&lt;T&gt; &#123;</span><br><span class=\"line\">    void save(T model);//持久化</span><br><span class=\"line\">    void save(List&lt;T&gt; models);//批量持久化</span><br><span class=\"line\">    void deleteById(Long id);//通过主鍵刪除</span><br><span class=\"line\">    void deleteByIds(String ids);//批量刪除 eg：ids -&gt; “1,2,3,4”</span><br><span class=\"line\">    void update(T model);//更新</span><br><span class=\"line\">    T findById(Long id);//通过ID查找</span><br><span class=\"line\">    T findBy(String fieldName, Object value) throws TooManyResultsException; //通过Model中某个成员变量名称（非数据表中column的名称）查找,value需符合unique约束</span><br><span class=\"line\">    List&lt;T&gt; findByIds(String ids);//通过多个ID查找//eg：ids -&gt; “1,2,3,4”</span><br><span class=\"line\">    List&lt;T&gt; findByCondition(Condition condition);//根据条件查找</span><br><span class=\"line\">    List&lt;T&gt; findAll();//获取所有</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后实现abstractService，用通用mapper实现了service,后面的service，只需继承abstractService即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractService&lt;T&gt; implements Service&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    protected Mapper&lt;T&gt; mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Class&lt;T&gt; modelClass;    // 当前泛型真实类型的Class</span><br><span class=\"line\"></span><br><span class=\"line\">    public AbstractService() &#123;</span><br><span class=\"line\">        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();</span><br><span class=\"line\">        modelClass = (Class&lt;T&gt;) pt.getActualTypeArguments()[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void save(T model) &#123;</span><br><span class=\"line\">        mapper.insertSelective(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void save(List&lt;T&gt; models) &#123;</span><br><span class=\"line\">        mapper.insertList(models);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void deleteById(Long id) &#123;</span><br><span class=\"line\">        mapper.deleteByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void deleteByIds(String ids) &#123;</span><br><span class=\"line\">        mapper.deleteByIds(ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void update(T model) &#123;</span><br><span class=\"line\">        mapper.updateByPrimaryKeySelective(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T findById(Long id) &#123;</span><br><span class=\"line\">        return mapper.selectByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public T findBy(String fieldName, Object value) throws TooManyResultsException &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            T model = modelClass.newInstance();</span><br><span class=\"line\">            Field field = modelClass.getDeclaredField(fieldName);</span><br><span class=\"line\">            field.setAccessible(true);</span><br><span class=\"line\">            field.set(model, value);</span><br><span class=\"line\">            return mapper.selectOne(model);</span><br><span class=\"line\">        &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class=\"line\">            throw new ServiceException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findByIds(String ids) &#123;</span><br><span class=\"line\">        return mapper.selectByIds(ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findByCondition(Condition condition) &#123;</span><br><span class=\"line\">        return mapper.selectByCondition(condition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findAll() &#123;</span><br><span class=\"line\">        return mapper.selectAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-下面看看Controller\"><a href=\"#2-下面看看Controller\" class=\"headerlink\" title=\"2.下面看看Controller\"></a>2.下面看看Controller</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class FetchConfigController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    UserInfoService userInfoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(value = &quot;/add&quot;, consumes = &quot;application/json&quot;, produces = &quot;application/json&quot;)</span><br><span class=\"line\">    public Result add(@RequestBody UserInfo userInfo) &#123;</span><br><span class=\"line\">        userInfoService.save(userInfo);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/delete&quot;)</span><br><span class=\"line\">    public Result delete(@RequestParam Long id) &#123;</span><br><span class=\"line\">        userInfoService.deleteById(id);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/update&quot;)</span><br><span class=\"line\">    public Result update(@RequestBody UserInfo userInfo) &#123;</span><br><span class=\"line\">        userInfoService.update(userInfo);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/detail&quot;)</span><br><span class=\"line\">    public Result detail(@RequestParam Long id) &#123;</span><br><span class=\"line\">        UserInfo userInfo = userInfoService.findById(id);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult(userInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/list&quot;)</span><br><span class=\"line\">    public Result list(@RequestParam(defaultValue = &quot;0&quot;) Integer page, @RequestParam(defaultValue = &quot;0&quot;) Integer size) &#123;</span><br><span class=\"line\">        PageHelper.startPage(page, size);</span><br><span class=\"line\">        List&lt;UserInfo&gt; list = userInfoService.findAll();</span><br><span class=\"line\">        PageInfo pageInfo = new PageInfo(list);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult(pageInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1@RestController，可以看到它是@Controller/@ResponseBody的结合体，@ResponseBody这个注解在RESTAPI 中很有意义，它不是将返回资源定位到resouces下面的html/css/js生成视图，而是直接以写入输出流返回给客户端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Controller</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public @interface RestController &#123;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里不得不提到HttpMessageConverter，这个转换器顾名思义，是将httprequest输入流读成对象，或者字符串，再返回的时候将对象转换成HttpResponse输出流<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface HttpMessageConverter&lt;T&gt; &#123;</span><br><span class=\"line\">    boolean canRead(Class&lt;?&gt; var1, MediaType var2);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean canWrite(Class&lt;?&gt; var1, MediaType var2);</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;MediaType&gt; getSupportedMediaTypes();</span><br><span class=\"line\"></span><br><span class=\"line\">    T read(Class&lt;? extends T&gt; var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;</span><br><span class=\"line\"></span><br><span class=\"line\">    void write(T var1, MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它是个泛型的接口，主要的两个方法是read/write canread/write,Spring已经实现了abstractHttpMessageConverter，自己可以继承这个abstract的class，拿来使用。converter用canread/write检查http流的类型，然后返回是true,就用read/write方法去读写。一般都是用别人写好的converter,例如阿里的fastjson的converter，可以用于处理application/json,例如MappingJackson2XmlHttpMessageConverter用于处理application/xml。这些内容可以配在configure文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class WebMvcConfigurer extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Logger logger = LogManager.getLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    //当前激活的配置文件</span><br><span class=\"line\">    @Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span><br><span class=\"line\">    private String env;</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用阿里 FastJson 作为JSON MessageConverter</span><br><span class=\"line\">    //使用MappingJackson2XmlHttpMessageConverter进行xml的转换</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class=\"line\">        FastJsonHttpMessageConverter4 converter = new FastJsonHttpMessageConverter4();</span><br><span class=\"line\">        FastJsonConfig config = new FastJsonConfig();</span><br><span class=\"line\">        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue,//保留空的字段</span><br><span class=\"line\">                SerializerFeature.WriteNullStringAsEmpty,//String null -&gt; &quot;&quot;</span><br><span class=\"line\">                SerializerFeature.WriteNullNumberAsZero);//Number null -&gt; 0</span><br><span class=\"line\">        converter.setFastJsonConfig(config);</span><br><span class=\"line\">        converter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class=\"line\">        MappingJackson2XmlHttpMessageConverter converter1 = new MappingJackson2XmlHttpMessageConverter();</span><br><span class=\"line\">        converters.add(converter1);</span><br><span class=\"line\">        converters.add(converter);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我这里添加了两个converter,分别用来处理json和xml.<br>2.@PostMapping其实是@RequestMapping(method = {RequestMethod.POST})的缩写<br>3.@RequestParam其实还可以加入default和require的设置<br>4.@RequestBody直接把inputstream中的json通过converter读成对象进行处理，和@responsebody对应将对象写成json放入outputstream</p>\n<h2 id=\"3-研究下Spring自带的RestTemplate\"><a href=\"#3-研究下Spring自带的RestTemplate\" class=\"headerlink\" title=\"3.研究下Spring自带的RestTemplate\"></a>3.研究下Spring自带的RestTemplate</h2><p>通常我们进行http请求是用apache的httpclient，而且功能比较强大，这里spring也集成了自己的rest请求方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static ClientHttpRequestFactory getSimpleClientHttpRequestFactory() &#123;</span><br><span class=\"line\">        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();</span><br><span class=\"line\">        factory.setReadTimeout(60000);//ms</span><br><span class=\"line\">        factory.setConnectTimeout(30000);//ms</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>RestTemplate直接new就可以使用了，构造方法里可以注入一个factory用于统一设置一些参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static RestTemplate getRestTemplate(ClientHttpRequestFactory factory) &#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate(factory);</span><br><span class=\"line\">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        StringHttpMessageConverter stringHttpMessageConverter</span><br><span class=\"line\">                = new StringHttpMessageConverter();</span><br><span class=\"line\">        stringHttpMessageConverter.setWriteAcceptCharset(false);</span><br><span class=\"line\">        stringHttpMessageConverter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class=\"line\">        messageConverters.add(stringHttpMessageConverter);</span><br><span class=\"line\">        messageConverters.add(new FormHttpMessageConverter());</span><br><span class=\"line\">        messageConverters.add(new FastJsonHttpMessageConverter4());</span><br><span class=\"line\">        restTemplate.setMessageConverters(messageConverters);</span><br><span class=\"line\">        return restTemplate;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>template里面统一可以注入converter,这里我加入了3个converter，这里注意StringmessageConverter里面默认的字符是ISO-8859-1，所以new一个新的converter并且设置编码防止出错，剩下的就是简单粗暴的直接使用咯<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        RestTemplate restTemplate = getRestTemplate(getSimpleClientHttpRequestFactory());</span><br><span class=\"line\">        String url = &quot;http://localhost:7777/dcs/list&quot;;</span><br><span class=\"line\">//        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">//        headers.setContentType(MediaType.ALL.APPLICATION_JSON);</span><br><span class=\"line\">//        UserInfo userInfo = new UserInfo().setUserId((long) 1231).</span><br><span class=\"line\">//                setUserName(&quot;test&quot;).setAge(13).setEmail(&quot;fafa@jancy.com&quot;);</span><br><span class=\"line\">//        HttpEntity request = new HttpEntity(userInfo, headers);</span><br><span class=\"line\">//        Result result = restTemplate.postForObject(url, request, Result.class);</span><br><span class=\"line\">//        System.out.println(JSON.toJSONString(result));</span><br><span class=\"line\">        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">        headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class=\"line\">        MultiValueMap&lt;String, Integer&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">        map.add(&quot;page&quot;, 1);</span><br><span class=\"line\">        map.add(&quot;size&quot;, 5);</span><br><span class=\"line\">        HttpEntity&lt;MultiValueMap&lt;String, Integer&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);</span><br><span class=\"line\">        Result result = restTemplate.postForObject(url, request, Result.class);</span><br><span class=\"line\">        System.out.println(JSON.toJSONString(result));</span><br></pre></td></tr></table></figure></p>\n<p>根据api的不同，既可以直接传入只要把HttpEntity包装好即可。<br>除了写在main函数中，也可以用Spring的注解加载factory/restemplate<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RestTemplateConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RestTemplate restTemplate(ClientHttpRequestFactory factory)&#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate(factory);</span><br><span class=\"line\">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        StringHttpMessageConverter stringHttpMessageConverter</span><br><span class=\"line\">            = new StringHttpMessageConverter();</span><br><span class=\"line\">        stringHttpMessageConverter.setWriteAcceptCharset(false);</span><br><span class=\"line\">        stringHttpMessageConverter.setDefaultCharset(Charsets.UTF_8);</span><br><span class=\"line\">        messageConverters.add(stringHttpMessageConverter);</span><br><span class=\"line\">        messageConverters.add(new FormHttpMessageConverter());</span><br><span class=\"line\">        messageConverters.add(new FastJsonHttpMessageConverter());</span><br><span class=\"line\">        restTemplate.setMessageConverters(messageConverters);</span><br><span class=\"line\">        return restTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123;</span><br><span class=\"line\">        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();</span><br><span class=\"line\">        factory.setReadTimeout(60000);//ms</span><br><span class=\"line\">        factory.setConnectTimeout(30000);//ms</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在其他代码里只用@autowired即可使用</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h2><p>以上就是如何用Springboot构建restApi，其实还可以和数据库做很多交互，还有签名认证，session管理等东西，都到后面完善吧。源码地址在最开始就贴了，是个开源的项目，HttpMessageConverter，如何得到json、xml的返回，都需要操作操作。继续努力吧<br><a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">个人博客</a> 欢迎访问~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>如题，本文讲述如何使用Springboot实现restapi,这里感谢开源社区的作者@简单的土豆，和他的源码<a href=\"https://github.com/Fan4J/spring-boot-api-project-seed.git\" target=\"_blank\" rel=\"noopener\">https://github.com/Fan4J/spring-boot-api-project-seed.git</a></p>\n</blockquote>\n<h2 id=\"1基本配置\"><a href=\"#1基本配置\" class=\"headerlink\" title=\"1基本配置\"></a>1基本配置</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/5834071-d8ba22876750345e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目结构.png\"><br>基本配置包括分环境的profile配置， log4j2配置，mybatis的配置，maven依赖的添加，统一结果封装，结果生成器等等。<br>这里作者使用了mybatis通用mapper<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Mapper&lt;T&gt;</span><br><span class=\"line\">        extends</span><br><span class=\"line\">        BaseMapper&lt;T&gt;,</span><br><span class=\"line\">        ConditionMapper&lt;T&gt;,</span><br><span class=\"line\">        IdsMapper&lt;T&gt;,</span><br><span class=\"line\">        InsertListMapper&lt;T&gt; &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通用service接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Service&lt;T&gt; &#123;</span><br><span class=\"line\">    void save(T model);//持久化</span><br><span class=\"line\">    void save(List&lt;T&gt; models);//批量持久化</span><br><span class=\"line\">    void deleteById(Long id);//通过主鍵刪除</span><br><span class=\"line\">    void deleteByIds(String ids);//批量刪除 eg：ids -&gt; “1,2,3,4”</span><br><span class=\"line\">    void update(T model);//更新</span><br><span class=\"line\">    T findById(Long id);//通过ID查找</span><br><span class=\"line\">    T findBy(String fieldName, Object value) throws TooManyResultsException; //通过Model中某个成员变量名称（非数据表中column的名称）查找,value需符合unique约束</span><br><span class=\"line\">    List&lt;T&gt; findByIds(String ids);//通过多个ID查找//eg：ids -&gt; “1,2,3,4”</span><br><span class=\"line\">    List&lt;T&gt; findByCondition(Condition condition);//根据条件查找</span><br><span class=\"line\">    List&lt;T&gt; findAll();//获取所有</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后实现abstractService，用通用mapper实现了service,后面的service，只需继承abstractService即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractService&lt;T&gt; implements Service&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    protected Mapper&lt;T&gt; mapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Class&lt;T&gt; modelClass;    // 当前泛型真实类型的Class</span><br><span class=\"line\"></span><br><span class=\"line\">    public AbstractService() &#123;</span><br><span class=\"line\">        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();</span><br><span class=\"line\">        modelClass = (Class&lt;T&gt;) pt.getActualTypeArguments()[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void save(T model) &#123;</span><br><span class=\"line\">        mapper.insertSelective(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void save(List&lt;T&gt; models) &#123;</span><br><span class=\"line\">        mapper.insertList(models);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void deleteById(Long id) &#123;</span><br><span class=\"line\">        mapper.deleteByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void deleteByIds(String ids) &#123;</span><br><span class=\"line\">        mapper.deleteByIds(ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void update(T model) &#123;</span><br><span class=\"line\">        mapper.updateByPrimaryKeySelective(model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T findById(Long id) &#123;</span><br><span class=\"line\">        return mapper.selectByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public T findBy(String fieldName, Object value) throws TooManyResultsException &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            T model = modelClass.newInstance();</span><br><span class=\"line\">            Field field = modelClass.getDeclaredField(fieldName);</span><br><span class=\"line\">            field.setAccessible(true);</span><br><span class=\"line\">            field.set(model, value);</span><br><span class=\"line\">            return mapper.selectOne(model);</span><br><span class=\"line\">        &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class=\"line\">            throw new ServiceException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findByIds(String ids) &#123;</span><br><span class=\"line\">        return mapper.selectByIds(ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findByCondition(Condition condition) &#123;</span><br><span class=\"line\">        return mapper.selectByCondition(condition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;T&gt; findAll() &#123;</span><br><span class=\"line\">        return mapper.selectAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-下面看看Controller\"><a href=\"#2-下面看看Controller\" class=\"headerlink\" title=\"2.下面看看Controller\"></a>2.下面看看Controller</h2><p>先上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">public class FetchConfigController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    UserInfoService userInfoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(value = &quot;/add&quot;, consumes = &quot;application/json&quot;, produces = &quot;application/json&quot;)</span><br><span class=\"line\">    public Result add(@RequestBody UserInfo userInfo) &#123;</span><br><span class=\"line\">        userInfoService.save(userInfo);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/delete&quot;)</span><br><span class=\"line\">    public Result delete(@RequestParam Long id) &#123;</span><br><span class=\"line\">        userInfoService.deleteById(id);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/update&quot;)</span><br><span class=\"line\">    public Result update(@RequestBody UserInfo userInfo) &#123;</span><br><span class=\"line\">        userInfoService.update(userInfo);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/detail&quot;)</span><br><span class=\"line\">    public Result detail(@RequestParam Long id) &#123;</span><br><span class=\"line\">        UserInfo userInfo = userInfoService.findById(id);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult(userInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/list&quot;)</span><br><span class=\"line\">    public Result list(@RequestParam(defaultValue = &quot;0&quot;) Integer page, @RequestParam(defaultValue = &quot;0&quot;) Integer size) &#123;</span><br><span class=\"line\">        PageHelper.startPage(page, size);</span><br><span class=\"line\">        List&lt;UserInfo&gt; list = userInfoService.findAll();</span><br><span class=\"line\">        PageInfo pageInfo = new PageInfo(list);</span><br><span class=\"line\">        return ResultCodeGenerator.genSuccessResult(pageInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1@RestController，可以看到它是@Controller/@ResponseBody的结合体，@ResponseBody这个注解在RESTAPI 中很有意义，它不是将返回资源定位到resouces下面的html/css/js生成视图，而是直接以写入输出流返回给客户端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">@Controller</span><br><span class=\"line\">@ResponseBody</span><br><span class=\"line\">public @interface RestController &#123;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里不得不提到HttpMessageConverter，这个转换器顾名思义，是将httprequest输入流读成对象，或者字符串，再返回的时候将对象转换成HttpResponse输出流<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface HttpMessageConverter&lt;T&gt; &#123;</span><br><span class=\"line\">    boolean canRead(Class&lt;?&gt; var1, MediaType var2);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean canWrite(Class&lt;?&gt; var1, MediaType var2);</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;MediaType&gt; getSupportedMediaTypes();</span><br><span class=\"line\"></span><br><span class=\"line\">    T read(Class&lt;? extends T&gt; var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;</span><br><span class=\"line\"></span><br><span class=\"line\">    void write(T var1, MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它是个泛型的接口，主要的两个方法是read/write canread/write,Spring已经实现了abstractHttpMessageConverter，自己可以继承这个abstract的class，拿来使用。converter用canread/write检查http流的类型，然后返回是true,就用read/write方法去读写。一般都是用别人写好的converter,例如阿里的fastjson的converter，可以用于处理application/json,例如MappingJackson2XmlHttpMessageConverter用于处理application/xml。这些内容可以配在configure文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class WebMvcConfigurer extends WebMvcConfigurerAdapter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Logger logger = LogManager.getLogger();</span><br><span class=\"line\"></span><br><span class=\"line\">    //当前激活的配置文件</span><br><span class=\"line\">    @Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span><br><span class=\"line\">    private String env;</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用阿里 FastJson 作为JSON MessageConverter</span><br><span class=\"line\">    //使用MappingJackson2XmlHttpMessageConverter进行xml的转换</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class=\"line\">        FastJsonHttpMessageConverter4 converter = new FastJsonHttpMessageConverter4();</span><br><span class=\"line\">        FastJsonConfig config = new FastJsonConfig();</span><br><span class=\"line\">        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue,//保留空的字段</span><br><span class=\"line\">                SerializerFeature.WriteNullStringAsEmpty,//String null -&gt; &quot;&quot;</span><br><span class=\"line\">                SerializerFeature.WriteNullNumberAsZero);//Number null -&gt; 0</span><br><span class=\"line\">        converter.setFastJsonConfig(config);</span><br><span class=\"line\">        converter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class=\"line\">        MappingJackson2XmlHttpMessageConverter converter1 = new MappingJackson2XmlHttpMessageConverter();</span><br><span class=\"line\">        converters.add(converter1);</span><br><span class=\"line\">        converters.add(converter);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我这里添加了两个converter,分别用来处理json和xml.<br>2.@PostMapping其实是@RequestMapping(method = {RequestMethod.POST})的缩写<br>3.@RequestParam其实还可以加入default和require的设置<br>4.@RequestBody直接把inputstream中的json通过converter读成对象进行处理，和@responsebody对应将对象写成json放入outputstream</p>\n<h2 id=\"3-研究下Spring自带的RestTemplate\"><a href=\"#3-研究下Spring自带的RestTemplate\" class=\"headerlink\" title=\"3.研究下Spring自带的RestTemplate\"></a>3.研究下Spring自带的RestTemplate</h2><p>通常我们进行http请求是用apache的httpclient，而且功能比较强大，这里spring也集成了自己的rest请求方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static ClientHttpRequestFactory getSimpleClientHttpRequestFactory() &#123;</span><br><span class=\"line\">        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();</span><br><span class=\"line\">        factory.setReadTimeout(60000);//ms</span><br><span class=\"line\">        factory.setConnectTimeout(30000);//ms</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>RestTemplate直接new就可以使用了，构造方法里可以注入一个factory用于统一设置一些参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static RestTemplate getRestTemplate(ClientHttpRequestFactory factory) &#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate(factory);</span><br><span class=\"line\">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        StringHttpMessageConverter stringHttpMessageConverter</span><br><span class=\"line\">                = new StringHttpMessageConverter();</span><br><span class=\"line\">        stringHttpMessageConverter.setWriteAcceptCharset(false);</span><br><span class=\"line\">        stringHttpMessageConverter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));</span><br><span class=\"line\">        messageConverters.add(stringHttpMessageConverter);</span><br><span class=\"line\">        messageConverters.add(new FormHttpMessageConverter());</span><br><span class=\"line\">        messageConverters.add(new FastJsonHttpMessageConverter4());</span><br><span class=\"line\">        restTemplate.setMessageConverters(messageConverters);</span><br><span class=\"line\">        return restTemplate;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>template里面统一可以注入converter,这里我加入了3个converter，这里注意StringmessageConverter里面默认的字符是ISO-8859-1，所以new一个新的converter并且设置编码防止出错，剩下的就是简单粗暴的直接使用咯<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        RestTemplate restTemplate = getRestTemplate(getSimpleClientHttpRequestFactory());</span><br><span class=\"line\">        String url = &quot;http://localhost:7777/dcs/list&quot;;</span><br><span class=\"line\">//        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">//        headers.setContentType(MediaType.ALL.APPLICATION_JSON);</span><br><span class=\"line\">//        UserInfo userInfo = new UserInfo().setUserId((long) 1231).</span><br><span class=\"line\">//                setUserName(&quot;test&quot;).setAge(13).setEmail(&quot;fafa@jancy.com&quot;);</span><br><span class=\"line\">//        HttpEntity request = new HttpEntity(userInfo, headers);</span><br><span class=\"line\">//        Result result = restTemplate.postForObject(url, request, Result.class);</span><br><span class=\"line\">//        System.out.println(JSON.toJSONString(result));</span><br><span class=\"line\">        HttpHeaders headers = new HttpHeaders();</span><br><span class=\"line\">        headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class=\"line\">        MultiValueMap&lt;String, Integer&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">        map.add(&quot;page&quot;, 1);</span><br><span class=\"line\">        map.add(&quot;size&quot;, 5);</span><br><span class=\"line\">        HttpEntity&lt;MultiValueMap&lt;String, Integer&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);</span><br><span class=\"line\">        Result result = restTemplate.postForObject(url, request, Result.class);</span><br><span class=\"line\">        System.out.println(JSON.toJSONString(result));</span><br></pre></td></tr></table></figure></p>\n<p>根据api的不同，既可以直接传入只要把HttpEntity包装好即可。<br>除了写在main函数中，也可以用Spring的注解加载factory/restemplate<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RestTemplateConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RestTemplate restTemplate(ClientHttpRequestFactory factory)&#123;</span><br><span class=\"line\">        RestTemplate restTemplate = new RestTemplate(factory);</span><br><span class=\"line\">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        StringHttpMessageConverter stringHttpMessageConverter</span><br><span class=\"line\">            = new StringHttpMessageConverter();</span><br><span class=\"line\">        stringHttpMessageConverter.setWriteAcceptCharset(false);</span><br><span class=\"line\">        stringHttpMessageConverter.setDefaultCharset(Charsets.UTF_8);</span><br><span class=\"line\">        messageConverters.add(stringHttpMessageConverter);</span><br><span class=\"line\">        messageConverters.add(new FormHttpMessageConverter());</span><br><span class=\"line\">        messageConverters.add(new FastJsonHttpMessageConverter());</span><br><span class=\"line\">        restTemplate.setMessageConverters(messageConverters);</span><br><span class=\"line\">        return restTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123;</span><br><span class=\"line\">        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();</span><br><span class=\"line\">        factory.setReadTimeout(60000);//ms</span><br><span class=\"line\">        factory.setConnectTimeout(30000);//ms</span><br><span class=\"line\">        return factory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在其他代码里只用@autowired即可使用</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h2><p>以上就是如何用Springboot构建restApi，其实还可以和数据库做很多交互，还有签名认证，session管理等东西，都到后面完善吧。源码地址在最开始就贴了，是个开源的项目，HttpMessageConverter，如何得到json、xml的返回，都需要操作操作。继续努力吧<br><a href=\"https://fan4j.github.io/\" target=\"_blank\" rel=\"noopener\">个人博客</a> 欢迎访问~</p>\n"},{"title":"Java杂记之static&threadlocal","date":"2018-07-30T14:11:00.000Z","comments":1,"_content":">闲来无事，写篇文章，如果有幸被看到了，希望你能当做下酒菜。\n>本文思路不是特别严谨，主要是每个人对于Java知识点的理解都是有偏颇不断修正的，所以不太理解的就会绕些弯子，如果你看的费劲，敬请谅解。\n\n## 1 Integer,String\n先说一些和本文无关的事情，简称前菜，对于经验比较丰富的java程序员来说这些都是毛毛雨。\n```\n@Test\npublic void testInteger(){\n    Integer a = new Integer(123);\n    Integer b = new Integer(123);\n    //false\n    Assert.assertTrue(a==b);\n}\n```\n这个testcase的结果是false，那么这个呢\n```\n@Test\npublic void testInteger(){\n    Integer a = 123;\n    Integer b = 123;\n    //true\n    Assert.assertTrue(a==b);\n}\n```\n早就听说Integer内部有cache,-128到127的int值都会放在cache里面。所以a==b可以理解，因为值相等，都是同一个cache的引用，所以上述结果为true。这样描述可以大体让人接受，可是仔细想想，上面代码和我说的有半毛线关系吗？于是我赶紧去翻了下Integer的源码，现在截取两段\n```\n/**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * sun.misc.VM class.\n     */\n\n    private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high >= 127;\n        }\n\n        private IntegerCache() {}\n    }\n```\n这是一个静态内部类，带着一个静态代码块，大致意思是从vmproperty中读一下high的值，默认是127，不默认的情况是high,然后一个cache数据就这样生成了，\n那么这个和上面的==又有啥关系呢？这时候会想哪里用到这个cache,往下正好有个方法用到了，看下valueOf方法\n```\n/**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n```\n很明确，如果进入了这个方法，先看看有没有cache，都得话就取cache,没有再new一个新的Integer.\n那么和之前的==又有啥关系呢。。。这句话问的有点多，不卖关子了，其实Integer a = 123;这句话有个装箱的过程，这个过程jvm会调用Integer.valueOf，前面的内容一下子串联起来了，是不是豁然开朗了。。啥？没感觉，确实对与大佬来说这点还是有些基础了。怎么知道jvm调用了哪个方法呢，反编译，看字节码，反正我是看不懂，但是可以友情提示下对于Integer,自动拆箱调用了Integer.intValue,自动装箱调用了Integer.ValueOf.\n\nString其实和说起来和Integer有那么点不同那么看看这个case\n```\n@Test\npublic void testString(){\n    String a = \"abc\";\n    String b = \"abc\";\n    //true\n    Assert.assertTrue(a==b);\n }\n```\n这个是true的原因，一句话概括->字符串常量池。jdk1.7之前，常量池是在方法区中的，jdk1.7以后移到了堆中，简答来说，如果常量池没有的字符串，会现在常量池里面创建一份，然后将其引用返回给String对象，以后遇到则返回该常量池的引用，所以a b 是同一个常量池对象的引用。\n```\n/**\n     * Returns a canonical representation for the string object.\n     * <p>\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * <p>\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * <p>\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() == t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * <p>\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section 3.10.5 of the\n     * <cite>The Java&trade; Language Specification</cite>.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n```\nintern是个native方法，使用起来也是比较方便的\n```\ns1 = new String(\"bbb\").intern();\ns2 = \"bbb\";\n```\n另外简单说一下String的设计思想。下面这段话是网上摘抄的\n```\nJava中的String被设计成不可变的，出于以下几点考虑：\n\n1. 字符串常量池的需要。字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。正因为String的不可变性，常量池很容易被管理和优化。\n\n2. 安全性考虑。正因为使用字符串的场景如此之多，所以设计成不可变可以有效的防止字符串被有意或者无意的篡改。从java源码中String的设计中我们不难发现，该类被final修饰，同时所有的属性都被final修饰，在源码中也未暴露任何成员变量的修改方法。（当然如果我们想，通过反射或者Unsafe直接操作内存的手段也可以实现对所谓不可变String的修改）。\n\n3. 作为HashMap、HashTable等hash型数据key的必要。因为不可变的设计，jvm底层很容易在缓存String对象的时候缓存其hashcode，这样在执行效率上会大大提升。\n```\n## 2 static关键字\nstatic 用了很多次了，静态嘛顾名思义，放在变量前面就是静态变量，放在代码块前面，就是静态代码块，静态的意思就是固定的，在类加载的一开始就准备好了，类加载之初，初始化static parameters,static block.，静态变量放在哪里，方法区。代码中不管实例化了多少对象，这些变量都是共用的。那么他们线程安全吗，显然是不，让我们用代码来说明这一点\n```\npublic class NormalCount implements Runnable {\n\n    @Getter\n    private static int count = 0;\n\n    @Override\n    public void run() {\n        Double d = Math.random() * 1000;\n        try {\n            Thread.sleep(d.longValue());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        count++;\n        System.out.println(Thread.currentThread().getName() + \": \" + count);\n    }\n\n}\n```\ntestCase如下,这种写法是先创建一个类然后并发的调用count++\n```\n@Test\npublic void testNormalnew() throws InterruptedException {\n    ExecutorService es = Executors.newFixedThreadPool(100);\n    for (int i = 0; i < 100; i++) {\n        es.execute(new NormalCount());\n    }\n    es.shutdown();\n    while (!es.isTerminated()) {\n        Thread.sleep(3000);\n    }\n    Assert.assertEquals(100,NormalCount.getCount());\n}\n```\n这里又想插句题外话了，不好的testcase真的会给你带来误解，如果testCase写的不行，最后可能告诉你错误的结论，最后给理解带来偏差，可以看到在NormalCount这个类里面count++前面我用了一个随机数去让线程睡眠，为什么要这样，如果没有这一步，testcase很可能不会报错，注意看我是创建了一个拥有100个线程的线程池，如果说for循环中的顺序去执行，每个count++的速度和时间都差不多，那么每个线程都是顺序执行的，实际上没有并发的场景。而误以为这是并发但是实际上是线程安全的，这就会带给你错误的结论。\n那么问题来了，听说volatile可以解决变量多线程之间的可见性，那意思就是刚刚的变量前面加个volatile这个testCase就ok了吗,试试后发现不行，不管是static的volatile我们创建多个类去并发访问，还是not static的volatile我们用多个线程去访问一个类，都是没有通过testCase。这是为啥呢，其实还是对volatile有误解。\nvolatile可以让变量在多线程之间可见，可以防止jvm优化的指令重排，这段我简单说说，就是volatile变量每次使用前都会刷新(CAS机制)，但是因为count++这个操作是非原子性的，所以拿到变量的时候还是最新的，但是可能操作过程中已经是过期的数据了，最后会让数据不一致。所以用volatile最好是原子性的操作比如对boolean的判断，没有其他操作，它是完全ok的\n上述代码如果想线程安全应该如何修改？有以下方法：\n1 ++方法用synchronized加锁,效率会比较低\n2 int 变量换成atomicInteger,这个类是线程安全的\n好了关于static 就说这么多.\n\n## 3 ThreadLocal分析\nThreadlocal是用来干嘛的，没有用过的人会对她敬而远之，只有用过的人才知道没有那么高冷。threadlocal简单来说，是用来存放线程独有的变量，线程之间是不共用的(?如果引用了static变量那就....)。你可能会问了，那方法里面局部变量不也行吗，确实局部变量是线程独享的，但是我们想要在线程中多个参数里方便的传递一个变量，局部变量就做不到了。Threadlocal就是这么来的\n```\n\nThis class provides thread-local variables.  These variables differ from\ntheir normal counterparts in that each thread that accesses one (via its\n{@code get} or {@code set} method) has its own, independently initialized\ncopy of the variable.  {@code ThreadLocal} instances are typically private\nstatic fields in classes that wish to associate state with a thread (e.g.,\na user ID or Transaction ID).\n\n<p>For example, the class below generates unique identifiers local to each\nthread.\nA thread's id is assigned the first time it invokes {@code ThreadId.get()}\nand remains unchanged on subsequent calls.\n<pre>\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ThreadId {\n// Atomic integer containing the next thread ID to be assigned\nprivate static final AtomicInteger nextId = new AtomicInteger(0);\n\n// Thread local variable containing each thread's ID\nprivate static final ThreadLocal<Integer> threadId =\n  new ThreadLocal<Integer>() {\n      @Override \n      protected Integer initialValue() {\n          return nextId.getAndIncrement();\n  \t}\n};\n\n// Returns the current thread's unique ID, assigning it if necessary\npublic static int get() {\n  return threadId.get();\n}\n}\n</pre>\n<p>Each thread holds an implicit reference to its copy of a thread-local\nvariable as long as the thread is alive and the {@code ThreadLocal}\ninstance is accessible; after a thread goes away, all of its copies of\nthread-local instances are subject to garbage collection (unless other\nreferences to these copies exist).\n```\n来看看Java之父Josh Bloch怎么说，其实说的还是挺清楚的，threadlocal是一个线程独有的变量，通常声明为private static 是为了保证这个变量和线程具有同样的生命周期，因为内部使用了弱引用，所以如果没有别的变量引用threadlocal会被gc清理。至于线程安不安全，不能保证哦...注释里面的这个例子其实很经典了，为每个线程创建一个threadId,这个id用atomicInteger生成，保证并发情况下的唯一性。看下Threadlocal的源码分析很多了这里就不贴了，简单来说，每个Thread里面都有一个变量叫做threadlocalMap这个map的实现是一个继承了弱引用的entry，map里面的key是threadlocal对象，value是对象的值。Threadlocal的get方法就是通过Thread获得threadlocalmap,然后以threadlocal对象本身为键去求的value.看下我的例子\n```\npublic class ThreadCount implements Runnable {\n\n    private static ThreadLocal<Integer> localcount = ThreadLocal.withInitial(()->0);\n\n    public int getLocalCount() {\n        localcount.set(localcount.get()+1);\n        return localcount.get();\n    }\n\n    @Override\n    public void run() {\n        for(int i =0;i<3;i++){\n            Double d = Math.random() * 1000;\n            try {\n                Thread.sleep(d.longValue());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\": \"+getLocalCount());\n        }\n    }\n}\n```\nTestCase如下\n```\n@Test\npublic void testThreadLocals() throws InterruptedException {\n    ThreadCount count = new ThreadCount();\n    ExecutorService es = Executors.newFixedThreadPool(100);\n    for(int i=0;i<100;i++){\n        es.execute(count);\n    }\n    es.shutdown();\n    while(!es.isTerminated()){\n        Thread.sleep(3000);\n    }\n}\n```\n从打印的结果看，每个线程都打印了123,\n```\npool-2-thread-81: 1\npool-2-thread-42: 1\npool-2-thread-6: 1\npool-2-thread-14: 2\npool-2-thread-80: 1\npool-2-thread-73: 2\npool-2-thread-25: 2\npool-2-thread-93: 1\npool-2-thread-15: 1\npool-2-thread-55: 1\n```\n这里我把线程池的默认线程个数改为10，结果如何呢？\n```\npool-2-thread-5: 9\npool-2-thread-10: 9\npool-2-thread-1: 9\npool-2-thread-5: 10\npool-2-thread-7: 7\npool-2-thread-8: 11\npool-2-thread-9: 10\npool-2-thread-6: 8\n```\n居然有的线程的值到了9，10 这怎么可能，其实这个是对线程池不够了解，线程池会对已有的线程进行复用，所以如果一个线程用完以后是count的值3，但是被别的线程复用以后就会大于3了，这其实是threadlocal使用中需要注意的，如果用到了线程池，那用完threadlocal记得还原。\n除了线程池的这个坑，threadlocal是不是可以说是线程安全的呢？其实讲道理这个问题是概念的混淆，threadlocal只是一个在threadlocalmap里面存放了key,value,如果这个value是个线程不安全的值，比如说是个static变量，所有线程都可以修改，那threadlocal就是不安全的。\n\n## 4 总结\njvm内存模型，加载机制，各种关键字，final,static,synchronized,volatile这些都是java工程师的必备武器，还是好好修炼吧 \n\n","source":"_posts/Java关键字之static.md","raw":"---\ntitle: Java杂记之static&threadlocal \ndate: 2018-07-30 22:11:00\ntags: Java\ncomments: true\n---\n>闲来无事，写篇文章，如果有幸被看到了，希望你能当做下酒菜。\n>本文思路不是特别严谨，主要是每个人对于Java知识点的理解都是有偏颇不断修正的，所以不太理解的就会绕些弯子，如果你看的费劲，敬请谅解。\n\n## 1 Integer,String\n先说一些和本文无关的事情，简称前菜，对于经验比较丰富的java程序员来说这些都是毛毛雨。\n```\n@Test\npublic void testInteger(){\n    Integer a = new Integer(123);\n    Integer b = new Integer(123);\n    //false\n    Assert.assertTrue(a==b);\n}\n```\n这个testcase的结果是false，那么这个呢\n```\n@Test\npublic void testInteger(){\n    Integer a = 123;\n    Integer b = 123;\n    //true\n    Assert.assertTrue(a==b);\n}\n```\n早就听说Integer内部有cache,-128到127的int值都会放在cache里面。所以a==b可以理解，因为值相等，都是同一个cache的引用，所以上述结果为true。这样描述可以大体让人接受，可是仔细想想，上面代码和我说的有半毛线关系吗？于是我赶紧去翻了下Integer的源码，现在截取两段\n```\n/**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * sun.misc.VM class.\n     */\n\n    private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high >= 127;\n        }\n\n        private IntegerCache() {}\n    }\n```\n这是一个静态内部类，带着一个静态代码块，大致意思是从vmproperty中读一下high的值，默认是127，不默认的情况是high,然后一个cache数据就这样生成了，\n那么这个和上面的==又有啥关系呢？这时候会想哪里用到这个cache,往下正好有个方法用到了，看下valueOf方法\n```\n/**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n```\n很明确，如果进入了这个方法，先看看有没有cache，都得话就取cache,没有再new一个新的Integer.\n那么和之前的==又有啥关系呢。。。这句话问的有点多，不卖关子了，其实Integer a = 123;这句话有个装箱的过程，这个过程jvm会调用Integer.valueOf，前面的内容一下子串联起来了，是不是豁然开朗了。。啥？没感觉，确实对与大佬来说这点还是有些基础了。怎么知道jvm调用了哪个方法呢，反编译，看字节码，反正我是看不懂，但是可以友情提示下对于Integer,自动拆箱调用了Integer.intValue,自动装箱调用了Integer.ValueOf.\n\nString其实和说起来和Integer有那么点不同那么看看这个case\n```\n@Test\npublic void testString(){\n    String a = \"abc\";\n    String b = \"abc\";\n    //true\n    Assert.assertTrue(a==b);\n }\n```\n这个是true的原因，一句话概括->字符串常量池。jdk1.7之前，常量池是在方法区中的，jdk1.7以后移到了堆中，简答来说，如果常量池没有的字符串，会现在常量池里面创建一份，然后将其引用返回给String对象，以后遇到则返回该常量池的引用，所以a b 是同一个常量池对象的引用。\n```\n/**\n     * Returns a canonical representation for the string object.\n     * <p>\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * <p>\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * <p>\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() == t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * <p>\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section 3.10.5 of the\n     * <cite>The Java&trade; Language Specification</cite>.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n```\nintern是个native方法，使用起来也是比较方便的\n```\ns1 = new String(\"bbb\").intern();\ns2 = \"bbb\";\n```\n另外简单说一下String的设计思想。下面这段话是网上摘抄的\n```\nJava中的String被设计成不可变的，出于以下几点考虑：\n\n1. 字符串常量池的需要。字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。正因为String的不可变性，常量池很容易被管理和优化。\n\n2. 安全性考虑。正因为使用字符串的场景如此之多，所以设计成不可变可以有效的防止字符串被有意或者无意的篡改。从java源码中String的设计中我们不难发现，该类被final修饰，同时所有的属性都被final修饰，在源码中也未暴露任何成员变量的修改方法。（当然如果我们想，通过反射或者Unsafe直接操作内存的手段也可以实现对所谓不可变String的修改）。\n\n3. 作为HashMap、HashTable等hash型数据key的必要。因为不可变的设计，jvm底层很容易在缓存String对象的时候缓存其hashcode，这样在执行效率上会大大提升。\n```\n## 2 static关键字\nstatic 用了很多次了，静态嘛顾名思义，放在变量前面就是静态变量，放在代码块前面，就是静态代码块，静态的意思就是固定的，在类加载的一开始就准备好了，类加载之初，初始化static parameters,static block.，静态变量放在哪里，方法区。代码中不管实例化了多少对象，这些变量都是共用的。那么他们线程安全吗，显然是不，让我们用代码来说明这一点\n```\npublic class NormalCount implements Runnable {\n\n    @Getter\n    private static int count = 0;\n\n    @Override\n    public void run() {\n        Double d = Math.random() * 1000;\n        try {\n            Thread.sleep(d.longValue());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        count++;\n        System.out.println(Thread.currentThread().getName() + \": \" + count);\n    }\n\n}\n```\ntestCase如下,这种写法是先创建一个类然后并发的调用count++\n```\n@Test\npublic void testNormalnew() throws InterruptedException {\n    ExecutorService es = Executors.newFixedThreadPool(100);\n    for (int i = 0; i < 100; i++) {\n        es.execute(new NormalCount());\n    }\n    es.shutdown();\n    while (!es.isTerminated()) {\n        Thread.sleep(3000);\n    }\n    Assert.assertEquals(100,NormalCount.getCount());\n}\n```\n这里又想插句题外话了，不好的testcase真的会给你带来误解，如果testCase写的不行，最后可能告诉你错误的结论，最后给理解带来偏差，可以看到在NormalCount这个类里面count++前面我用了一个随机数去让线程睡眠，为什么要这样，如果没有这一步，testcase很可能不会报错，注意看我是创建了一个拥有100个线程的线程池，如果说for循环中的顺序去执行，每个count++的速度和时间都差不多，那么每个线程都是顺序执行的，实际上没有并发的场景。而误以为这是并发但是实际上是线程安全的，这就会带给你错误的结论。\n那么问题来了，听说volatile可以解决变量多线程之间的可见性，那意思就是刚刚的变量前面加个volatile这个testCase就ok了吗,试试后发现不行，不管是static的volatile我们创建多个类去并发访问，还是not static的volatile我们用多个线程去访问一个类，都是没有通过testCase。这是为啥呢，其实还是对volatile有误解。\nvolatile可以让变量在多线程之间可见，可以防止jvm优化的指令重排，这段我简单说说，就是volatile变量每次使用前都会刷新(CAS机制)，但是因为count++这个操作是非原子性的，所以拿到变量的时候还是最新的，但是可能操作过程中已经是过期的数据了，最后会让数据不一致。所以用volatile最好是原子性的操作比如对boolean的判断，没有其他操作，它是完全ok的\n上述代码如果想线程安全应该如何修改？有以下方法：\n1 ++方法用synchronized加锁,效率会比较低\n2 int 变量换成atomicInteger,这个类是线程安全的\n好了关于static 就说这么多.\n\n## 3 ThreadLocal分析\nThreadlocal是用来干嘛的，没有用过的人会对她敬而远之，只有用过的人才知道没有那么高冷。threadlocal简单来说，是用来存放线程独有的变量，线程之间是不共用的(?如果引用了static变量那就....)。你可能会问了，那方法里面局部变量不也行吗，确实局部变量是线程独享的，但是我们想要在线程中多个参数里方便的传递一个变量，局部变量就做不到了。Threadlocal就是这么来的\n```\n\nThis class provides thread-local variables.  These variables differ from\ntheir normal counterparts in that each thread that accesses one (via its\n{@code get} or {@code set} method) has its own, independently initialized\ncopy of the variable.  {@code ThreadLocal} instances are typically private\nstatic fields in classes that wish to associate state with a thread (e.g.,\na user ID or Transaction ID).\n\n<p>For example, the class below generates unique identifiers local to each\nthread.\nA thread's id is assigned the first time it invokes {@code ThreadId.get()}\nand remains unchanged on subsequent calls.\n<pre>\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ThreadId {\n// Atomic integer containing the next thread ID to be assigned\nprivate static final AtomicInteger nextId = new AtomicInteger(0);\n\n// Thread local variable containing each thread's ID\nprivate static final ThreadLocal<Integer> threadId =\n  new ThreadLocal<Integer>() {\n      @Override \n      protected Integer initialValue() {\n          return nextId.getAndIncrement();\n  \t}\n};\n\n// Returns the current thread's unique ID, assigning it if necessary\npublic static int get() {\n  return threadId.get();\n}\n}\n</pre>\n<p>Each thread holds an implicit reference to its copy of a thread-local\nvariable as long as the thread is alive and the {@code ThreadLocal}\ninstance is accessible; after a thread goes away, all of its copies of\nthread-local instances are subject to garbage collection (unless other\nreferences to these copies exist).\n```\n来看看Java之父Josh Bloch怎么说，其实说的还是挺清楚的，threadlocal是一个线程独有的变量，通常声明为private static 是为了保证这个变量和线程具有同样的生命周期，因为内部使用了弱引用，所以如果没有别的变量引用threadlocal会被gc清理。至于线程安不安全，不能保证哦...注释里面的这个例子其实很经典了，为每个线程创建一个threadId,这个id用atomicInteger生成，保证并发情况下的唯一性。看下Threadlocal的源码分析很多了这里就不贴了，简单来说，每个Thread里面都有一个变量叫做threadlocalMap这个map的实现是一个继承了弱引用的entry，map里面的key是threadlocal对象，value是对象的值。Threadlocal的get方法就是通过Thread获得threadlocalmap,然后以threadlocal对象本身为键去求的value.看下我的例子\n```\npublic class ThreadCount implements Runnable {\n\n    private static ThreadLocal<Integer> localcount = ThreadLocal.withInitial(()->0);\n\n    public int getLocalCount() {\n        localcount.set(localcount.get()+1);\n        return localcount.get();\n    }\n\n    @Override\n    public void run() {\n        for(int i =0;i<3;i++){\n            Double d = Math.random() * 1000;\n            try {\n                Thread.sleep(d.longValue());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\": \"+getLocalCount());\n        }\n    }\n}\n```\nTestCase如下\n```\n@Test\npublic void testThreadLocals() throws InterruptedException {\n    ThreadCount count = new ThreadCount();\n    ExecutorService es = Executors.newFixedThreadPool(100);\n    for(int i=0;i<100;i++){\n        es.execute(count);\n    }\n    es.shutdown();\n    while(!es.isTerminated()){\n        Thread.sleep(3000);\n    }\n}\n```\n从打印的结果看，每个线程都打印了123,\n```\npool-2-thread-81: 1\npool-2-thread-42: 1\npool-2-thread-6: 1\npool-2-thread-14: 2\npool-2-thread-80: 1\npool-2-thread-73: 2\npool-2-thread-25: 2\npool-2-thread-93: 1\npool-2-thread-15: 1\npool-2-thread-55: 1\n```\n这里我把线程池的默认线程个数改为10，结果如何呢？\n```\npool-2-thread-5: 9\npool-2-thread-10: 9\npool-2-thread-1: 9\npool-2-thread-5: 10\npool-2-thread-7: 7\npool-2-thread-8: 11\npool-2-thread-9: 10\npool-2-thread-6: 8\n```\n居然有的线程的值到了9，10 这怎么可能，其实这个是对线程池不够了解，线程池会对已有的线程进行复用，所以如果一个线程用完以后是count的值3，但是被别的线程复用以后就会大于3了，这其实是threadlocal使用中需要注意的，如果用到了线程池，那用完threadlocal记得还原。\n除了线程池的这个坑，threadlocal是不是可以说是线程安全的呢？其实讲道理这个问题是概念的混淆，threadlocal只是一个在threadlocalmap里面存放了key,value,如果这个value是个线程不安全的值，比如说是个static变量，所有线程都可以修改，那threadlocal就是不安全的。\n\n## 4 总结\njvm内存模型，加载机制，各种关键字，final,static,synchronized,volatile这些都是java工程师的必备武器，还是好好修炼吧 \n\n","slug":"Java关键字之static","published":1,"updated":"2018-07-30T15:20:17.449Z","layout":"post","photos":[],"link":"","_id":"cjy3u76ws000ytgrlkk7kfrr3","content":"<blockquote>\n<p>闲来无事，写篇文章，如果有幸被看到了，希望你能当做下酒菜。<br>本文思路不是特别严谨，主要是每个人对于Java知识点的理解都是有偏颇不断修正的，所以不太理解的就会绕些弯子，如果你看的费劲，敬请谅解。</p>\n</blockquote>\n<h2 id=\"1-Integer-String\"><a href=\"#1-Integer-String\" class=\"headerlink\" title=\"1 Integer,String\"></a>1 Integer,String</h2><p>先说一些和本文无关的事情，简称前菜，对于经验比较丰富的java程序员来说这些都是毛毛雨。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testInteger()&#123;</span><br><span class=\"line\">    Integer a = new Integer(123);</span><br><span class=\"line\">    Integer b = new Integer(123);</span><br><span class=\"line\">    //false</span><br><span class=\"line\">    Assert.assertTrue(a==b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个testcase的结果是false，那么这个呢<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testInteger()&#123;</span><br><span class=\"line\">    Integer a = 123;</span><br><span class=\"line\">    Integer b = 123;</span><br><span class=\"line\">    //true</span><br><span class=\"line\">    Assert.assertTrue(a==b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>早就听说Integer内部有cache,-128到127的int值都会放在cache里面。所以a==b可以理解，因为值相等，都是同一个cache的引用，所以上述结果为true。这样描述可以大体让人接受，可是仔细想想，上面代码和我说的有半毛线关系吗？于是我赶紧去翻了下Integer的源码，现在截取两段<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Cache to support the object identity semantics of autoboxing for values between</span><br><span class=\"line\">     * -128 and 127 (inclusive) as required by JLS.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * The cache is initialized on first usage.  The size of the cache</span><br><span class=\"line\">     * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class=\"line\">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class=\"line\">     * may be set and saved in the private system properties in the</span><br><span class=\"line\">     * sun.misc.VM class.</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class IntegerCache &#123;</span><br><span class=\"line\">        static final int low = -128;</span><br><span class=\"line\">        static final int high;</span><br><span class=\"line\">        static final Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">        static &#123;</span><br><span class=\"line\">            // high value may be configured by property</span><br><span class=\"line\">            int h = 127;</span><br><span class=\"line\">            String integerCacheHighPropValue =</span><br><span class=\"line\">                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class=\"line\">            if (integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                    i = Math.max(i, 127);</span><br><span class=\"line\">                    // Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class=\"line\">                &#125; catch( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                    // If the property cannot be parsed into an int, ignore it.</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">            cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">            int j = low;</span><br><span class=\"line\">            for(int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">                cache[k] = new Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">            // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class=\"line\">            assert IntegerCache.high &gt;= 127;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private IntegerCache() &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个静态内部类，带着一个静态代码块，大致意思是从vmproperty中读一下high的值，默认是127，不默认的情况是high,然后一个cache数据就这样生成了，<br>那么这个和上面的==又有啥关系呢？这时候会想哪里用到这个cache,往下正好有个方法用到了，看下valueOf方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Returns an &#123;@code Integer&#125; instance representing the specified</span><br><span class=\"line\">     * &#123;@code int&#125; value.  If a new &#123;@code Integer&#125; instance is not</span><br><span class=\"line\">     * required, this method should generally be used in preference to</span><br><span class=\"line\">     * the constructor &#123;@link #Integer(int)&#125;, as this method is likely</span><br><span class=\"line\">     * to yield significantly better space and time performance by</span><br><span class=\"line\">     * caching frequently requested values.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * This method will always cache values in the range -128 to 127,</span><br><span class=\"line\">     * inclusive, and may cache other values outside of this range.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param  i an &#123;@code int&#125; value.</span><br><span class=\"line\">     * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;.</span><br><span class=\"line\">     * @since  1.5</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">        return new Integer(i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>很明确，如果进入了这个方法，先看看有没有cache，都得话就取cache,没有再new一个新的Integer.<br>那么和之前的==又有啥关系呢。。。这句话问的有点多，不卖关子了，其实Integer a = 123;这句话有个装箱的过程，这个过程jvm会调用Integer.valueOf，前面的内容一下子串联起来了，是不是豁然开朗了。。啥？没感觉，确实对与大佬来说这点还是有些基础了。怎么知道jvm调用了哪个方法呢，反编译，看字节码，反正我是看不懂，但是可以友情提示下对于Integer,自动拆箱调用了Integer.intValue,自动装箱调用了Integer.ValueOf.</p>\n<p>String其实和说起来和Integer有那么点不同那么看看这个case<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testString()&#123;</span><br><span class=\"line\">    String a = &quot;abc&quot;;</span><br><span class=\"line\">    String b = &quot;abc&quot;;</span><br><span class=\"line\">    //true</span><br><span class=\"line\">    Assert.assertTrue(a==b);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个是true的原因，一句话概括-&gt;字符串常量池。jdk1.7之前，常量池是在方法区中的，jdk1.7以后移到了堆中，简答来说，如果常量池没有的字符串，会现在常量池里面创建一份，然后将其引用返回给String对象，以后遇到则返回该常量池的引用，所以a b 是同一个常量池对象的引用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Returns a canonical representation for the string object.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * A pool of strings, initially empty, is maintained privately by the</span><br><span class=\"line\">     * class &#123;@code String&#125;.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * When the intern method is invoked, if the pool already contains a</span><br><span class=\"line\">     * string equal to this &#123;@code String&#125; object as determined by</span><br><span class=\"line\">     * the &#123;@link #equals(Object)&#125; method, then the string from the pool is</span><br><span class=\"line\">     * returned. Otherwise, this &#123;@code String&#125; object is added to the</span><br><span class=\"line\">     * pool and a reference to this &#123;@code String&#125; object is returned.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;,</span><br><span class=\"line\">     * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125;</span><br><span class=\"line\">     * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * All literal strings and string-valued constant expressions are</span><br><span class=\"line\">     * interned. String literals are defined in section 3.10.5 of the</span><br><span class=\"line\">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return  a string that has the same contents as this string, but is</span><br><span class=\"line\">     *          guaranteed to be from a pool of unique strings.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public native String intern();</span><br></pre></td></tr></table></figure></p>\n<p>intern是个native方法，使用起来也是比较方便的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s1 = new String(&quot;bbb&quot;).intern();</span><br><span class=\"line\">s2 = &quot;bbb&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>另外简单说一下String的设计思想。下面这段话是网上摘抄的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java中的String被设计成不可变的，出于以下几点考虑：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 字符串常量池的需要。字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。正因为String的不可变性，常量池很容易被管理和优化。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 安全性考虑。正因为使用字符串的场景如此之多，所以设计成不可变可以有效的防止字符串被有意或者无意的篡改。从java源码中String的设计中我们不难发现，该类被final修饰，同时所有的属性都被final修饰，在源码中也未暴露任何成员变量的修改方法。（当然如果我们想，通过反射或者Unsafe直接操作内存的手段也可以实现对所谓不可变String的修改）。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 作为HashMap、HashTable等hash型数据key的必要。因为不可变的设计，jvm底层很容易在缓存String对象的时候缓存其hashcode，这样在执行效率上会大大提升。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-static关键字\"><a href=\"#2-static关键字\" class=\"headerlink\" title=\"2 static关键字\"></a>2 static关键字</h2><p>static 用了很多次了，静态嘛顾名思义，放在变量前面就是静态变量，放在代码块前面，就是静态代码块，静态的意思就是固定的，在类加载的一开始就准备好了，类加载之初，初始化static parameters,static block.，静态变量放在哪里，方法区。代码中不管实例化了多少对象，这些变量都是共用的。那么他们线程安全吗，显然是不，让我们用代码来说明这一点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NormalCount implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Getter</span><br><span class=\"line\">    private static int count = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        Double d = Math.random() * 1000;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(d.longValue());</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>testCase如下,这种写法是先创建一个类然后并发的调用count++<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testNormalnew() throws InterruptedException &#123;</span><br><span class=\"line\">    ExecutorService es = Executors.newFixedThreadPool(100);</span><br><span class=\"line\">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">        es.execute(new NormalCount());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    es.shutdown();</span><br><span class=\"line\">    while (!es.isTerminated()) &#123;</span><br><span class=\"line\">        Thread.sleep(3000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Assert.assertEquals(100,NormalCount.getCount());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里又想插句题外话了，不好的testcase真的会给你带来误解，如果testCase写的不行，最后可能告诉你错误的结论，最后给理解带来偏差，可以看到在NormalCount这个类里面count++前面我用了一个随机数去让线程睡眠，为什么要这样，如果没有这一步，testcase很可能不会报错，注意看我是创建了一个拥有100个线程的线程池，如果说for循环中的顺序去执行，每个count++的速度和时间都差不多，那么每个线程都是顺序执行的，实际上没有并发的场景。而误以为这是并发但是实际上是线程安全的，这就会带给你错误的结论。<br>那么问题来了，听说volatile可以解决变量多线程之间的可见性，那意思就是刚刚的变量前面加个volatile这个testCase就ok了吗,试试后发现不行，不管是static的volatile我们创建多个类去并发访问，还是not static的volatile我们用多个线程去访问一个类，都是没有通过testCase。这是为啥呢，其实还是对volatile有误解。<br>volatile可以让变量在多线程之间可见，可以防止jvm优化的指令重排，这段我简单说说，就是volatile变量每次使用前都会刷新(CAS机制)，但是因为count++这个操作是非原子性的，所以拿到变量的时候还是最新的，但是可能操作过程中已经是过期的数据了，最后会让数据不一致。所以用volatile最好是原子性的操作比如对boolean的判断，没有其他操作，它是完全ok的<br>上述代码如果想线程安全应该如何修改？有以下方法：<br>1 ++方法用synchronized加锁,效率会比较低<br>2 int 变量换成atomicInteger,这个类是线程安全的<br>好了关于static 就说这么多.</p>\n<h2 id=\"3-ThreadLocal分析\"><a href=\"#3-ThreadLocal分析\" class=\"headerlink\" title=\"3 ThreadLocal分析\"></a>3 ThreadLocal分析</h2><p>Threadlocal是用来干嘛的，没有用过的人会对她敬而远之，只有用过的人才知道没有那么高冷。threadlocal简单来说，是用来存放线程独有的变量，线程之间是不共用的(?如果引用了static变量那就….)。你可能会问了，那方法里面局部变量不也行吗，确实局部变量是线程独享的，但是我们想要在线程中多个参数里方便的传递一个变量，局部变量就做不到了。Threadlocal就是这么来的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">This class provides thread-local variables.  These variables differ from</span><br><span class=\"line\">their normal counterparts in that each thread that accesses one (via its</span><br><span class=\"line\">&#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized</span><br><span class=\"line\">copy of the variable.  &#123;@code ThreadLocal&#125; instances are typically private</span><br><span class=\"line\">static fields in classes that wish to associate state with a thread (e.g.,</span><br><span class=\"line\">a user ID or Transaction ID).</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;For example, the class below generates unique identifiers local to each</span><br><span class=\"line\">thread.</span><br><span class=\"line\">A thread&apos;s id is assigned the first time it invokes &#123;@code ThreadId.get()&#125;</span><br><span class=\"line\">and remains unchanged on subsequent calls.</span><br><span class=\"line\">&lt;pre&gt;</span><br><span class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\">public class ThreadId &#123;</span><br><span class=\"line\">// Atomic integer containing the next thread ID to be assigned</span><br><span class=\"line\">private static final AtomicInteger nextId = new AtomicInteger(0);</span><br><span class=\"line\"></span><br><span class=\"line\">// Thread local variable containing each thread&apos;s ID</span><br><span class=\"line\">private static final ThreadLocal&lt;Integer&gt; threadId =</span><br><span class=\"line\">  new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class=\"line\">      @Override </span><br><span class=\"line\">      protected Integer initialValue() &#123;</span><br><span class=\"line\">          return nextId.getAndIncrement();</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns the current thread&apos;s unique ID, assigning it if necessary</span><br><span class=\"line\">public static int get() &#123;</span><br><span class=\"line\">  return threadId.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/pre&gt;</span><br><span class=\"line\">&lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local</span><br><span class=\"line\">variable as long as the thread is alive and the &#123;@code ThreadLocal&#125;</span><br><span class=\"line\">instance is accessible; after a thread goes away, all of its copies of</span><br><span class=\"line\">thread-local instances are subject to garbage collection (unless other</span><br><span class=\"line\">references to these copies exist).</span><br></pre></td></tr></table></figure></p>\n<p>来看看Java之父Josh Bloch怎么说，其实说的还是挺清楚的，threadlocal是一个线程独有的变量，通常声明为private static 是为了保证这个变量和线程具有同样的生命周期，因为内部使用了弱引用，所以如果没有别的变量引用threadlocal会被gc清理。至于线程安不安全，不能保证哦…注释里面的这个例子其实很经典了，为每个线程创建一个threadId,这个id用atomicInteger生成，保证并发情况下的唯一性。看下Threadlocal的源码分析很多了这里就不贴了，简单来说，每个Thread里面都有一个变量叫做threadlocalMap这个map的实现是一个继承了弱引用的entry，map里面的key是threadlocal对象，value是对象的值。Threadlocal的get方法就是通过Thread获得threadlocalmap,然后以threadlocal对象本身为键去求的value.看下我的例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadCount implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ThreadLocal&lt;Integer&gt; localcount = ThreadLocal.withInitial(()-&gt;0);</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getLocalCount() &#123;</span><br><span class=\"line\">        localcount.set(localcount.get()+1);</span><br><span class=\"line\">        return localcount.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        for(int i =0;i&lt;3;i++)&#123;</span><br><span class=\"line\">            Double d = Math.random() * 1000;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(d.longValue());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;: &quot;+getLocalCount());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>TestCase如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testThreadLocals() throws InterruptedException &#123;</span><br><span class=\"line\">    ThreadCount count = new ThreadCount();</span><br><span class=\"line\">    ExecutorService es = Executors.newFixedThreadPool(100);</span><br><span class=\"line\">    for(int i=0;i&lt;100;i++)&#123;</span><br><span class=\"line\">        es.execute(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    es.shutdown();</span><br><span class=\"line\">    while(!es.isTerminated())&#123;</span><br><span class=\"line\">        Thread.sleep(3000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从打印的结果看，每个线程都打印了123,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-2-thread-81: 1</span><br><span class=\"line\">pool-2-thread-42: 1</span><br><span class=\"line\">pool-2-thread-6: 1</span><br><span class=\"line\">pool-2-thread-14: 2</span><br><span class=\"line\">pool-2-thread-80: 1</span><br><span class=\"line\">pool-2-thread-73: 2</span><br><span class=\"line\">pool-2-thread-25: 2</span><br><span class=\"line\">pool-2-thread-93: 1</span><br><span class=\"line\">pool-2-thread-15: 1</span><br><span class=\"line\">pool-2-thread-55: 1</span><br></pre></td></tr></table></figure></p>\n<p>这里我把线程池的默认线程个数改为10，结果如何呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-2-thread-5: 9</span><br><span class=\"line\">pool-2-thread-10: 9</span><br><span class=\"line\">pool-2-thread-1: 9</span><br><span class=\"line\">pool-2-thread-5: 10</span><br><span class=\"line\">pool-2-thread-7: 7</span><br><span class=\"line\">pool-2-thread-8: 11</span><br><span class=\"line\">pool-2-thread-9: 10</span><br><span class=\"line\">pool-2-thread-6: 8</span><br></pre></td></tr></table></figure></p>\n<p>居然有的线程的值到了9，10 这怎么可能，其实这个是对线程池不够了解，线程池会对已有的线程进行复用，所以如果一个线程用完以后是count的值3，但是被别的线程复用以后就会大于3了，这其实是threadlocal使用中需要注意的，如果用到了线程池，那用完threadlocal记得还原。<br>除了线程池的这个坑，threadlocal是不是可以说是线程安全的呢？其实讲道理这个问题是概念的混淆，threadlocal只是一个在threadlocalmap里面存放了key,value,如果这个value是个线程不安全的值，比如说是个static变量，所有线程都可以修改，那threadlocal就是不安全的。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><p>jvm内存模型，加载机制，各种关键字，final,static,synchronized,volatile这些都是java工程师的必备武器，还是好好修炼吧 </p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>闲来无事，写篇文章，如果有幸被看到了，希望你能当做下酒菜。<br>本文思路不是特别严谨，主要是每个人对于Java知识点的理解都是有偏颇不断修正的，所以不太理解的就会绕些弯子，如果你看的费劲，敬请谅解。</p>\n</blockquote>\n<h2 id=\"1-Integer-String\"><a href=\"#1-Integer-String\" class=\"headerlink\" title=\"1 Integer,String\"></a>1 Integer,String</h2><p>先说一些和本文无关的事情，简称前菜，对于经验比较丰富的java程序员来说这些都是毛毛雨。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testInteger()&#123;</span><br><span class=\"line\">    Integer a = new Integer(123);</span><br><span class=\"line\">    Integer b = new Integer(123);</span><br><span class=\"line\">    //false</span><br><span class=\"line\">    Assert.assertTrue(a==b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个testcase的结果是false，那么这个呢<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testInteger()&#123;</span><br><span class=\"line\">    Integer a = 123;</span><br><span class=\"line\">    Integer b = 123;</span><br><span class=\"line\">    //true</span><br><span class=\"line\">    Assert.assertTrue(a==b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>早就听说Integer内部有cache,-128到127的int值都会放在cache里面。所以a==b可以理解，因为值相等，都是同一个cache的引用，所以上述结果为true。这样描述可以大体让人接受，可是仔细想想，上面代码和我说的有半毛线关系吗？于是我赶紧去翻了下Integer的源码，现在截取两段<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Cache to support the object identity semantics of autoboxing for values between</span><br><span class=\"line\">     * -128 and 127 (inclusive) as required by JLS.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * The cache is initialized on first usage.  The size of the cache</span><br><span class=\"line\">     * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class=\"line\">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class=\"line\">     * may be set and saved in the private system properties in the</span><br><span class=\"line\">     * sun.misc.VM class.</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class IntegerCache &#123;</span><br><span class=\"line\">        static final int low = -128;</span><br><span class=\"line\">        static final int high;</span><br><span class=\"line\">        static final Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">        static &#123;</span><br><span class=\"line\">            // high value may be configured by property</span><br><span class=\"line\">            int h = 127;</span><br><span class=\"line\">            String integerCacheHighPropValue =</span><br><span class=\"line\">                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class=\"line\">            if (integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                    i = Math.max(i, 127);</span><br><span class=\"line\">                    // Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class=\"line\">                &#125; catch( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                    // If the property cannot be parsed into an int, ignore it.</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">            cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">            int j = low;</span><br><span class=\"line\">            for(int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">                cache[k] = new Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">            // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class=\"line\">            assert IntegerCache.high &gt;= 127;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private IntegerCache() &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个静态内部类，带着一个静态代码块，大致意思是从vmproperty中读一下high的值，默认是127，不默认的情况是high,然后一个cache数据就这样生成了，<br>那么这个和上面的==又有啥关系呢？这时候会想哪里用到这个cache,往下正好有个方法用到了，看下valueOf方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Returns an &#123;@code Integer&#125; instance representing the specified</span><br><span class=\"line\">     * &#123;@code int&#125; value.  If a new &#123;@code Integer&#125; instance is not</span><br><span class=\"line\">     * required, this method should generally be used in preference to</span><br><span class=\"line\">     * the constructor &#123;@link #Integer(int)&#125;, as this method is likely</span><br><span class=\"line\">     * to yield significantly better space and time performance by</span><br><span class=\"line\">     * caching frequently requested values.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * This method will always cache values in the range -128 to 127,</span><br><span class=\"line\">     * inclusive, and may cache other values outside of this range.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param  i an &#123;@code int&#125; value.</span><br><span class=\"line\">     * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;.</span><br><span class=\"line\">     * @since  1.5</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">        return new Integer(i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>很明确，如果进入了这个方法，先看看有没有cache，都得话就取cache,没有再new一个新的Integer.<br>那么和之前的==又有啥关系呢。。。这句话问的有点多，不卖关子了，其实Integer a = 123;这句话有个装箱的过程，这个过程jvm会调用Integer.valueOf，前面的内容一下子串联起来了，是不是豁然开朗了。。啥？没感觉，确实对与大佬来说这点还是有些基础了。怎么知道jvm调用了哪个方法呢，反编译，看字节码，反正我是看不懂，但是可以友情提示下对于Integer,自动拆箱调用了Integer.intValue,自动装箱调用了Integer.ValueOf.</p>\n<p>String其实和说起来和Integer有那么点不同那么看看这个case<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testString()&#123;</span><br><span class=\"line\">    String a = &quot;abc&quot;;</span><br><span class=\"line\">    String b = &quot;abc&quot;;</span><br><span class=\"line\">    //true</span><br><span class=\"line\">    Assert.assertTrue(a==b);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个是true的原因，一句话概括-&gt;字符串常量池。jdk1.7之前，常量池是在方法区中的，jdk1.7以后移到了堆中，简答来说，如果常量池没有的字符串，会现在常量池里面创建一份，然后将其引用返回给String对象，以后遇到则返回该常量池的引用，所以a b 是同一个常量池对象的引用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * Returns a canonical representation for the string object.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * A pool of strings, initially empty, is maintained privately by the</span><br><span class=\"line\">     * class &#123;@code String&#125;.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * When the intern method is invoked, if the pool already contains a</span><br><span class=\"line\">     * string equal to this &#123;@code String&#125; object as determined by</span><br><span class=\"line\">     * the &#123;@link #equals(Object)&#125; method, then the string from the pool is</span><br><span class=\"line\">     * returned. Otherwise, this &#123;@code String&#125; object is added to the</span><br><span class=\"line\">     * pool and a reference to this &#123;@code String&#125; object is returned.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;,</span><br><span class=\"line\">     * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125;</span><br><span class=\"line\">     * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * All literal strings and string-valued constant expressions are</span><br><span class=\"line\">     * interned. String literals are defined in section 3.10.5 of the</span><br><span class=\"line\">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return  a string that has the same contents as this string, but is</span><br><span class=\"line\">     *          guaranteed to be from a pool of unique strings.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public native String intern();</span><br></pre></td></tr></table></figure></p>\n<p>intern是个native方法，使用起来也是比较方便的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s1 = new String(&quot;bbb&quot;).intern();</span><br><span class=\"line\">s2 = &quot;bbb&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>另外简单说一下String的设计思想。下面这段话是网上摘抄的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java中的String被设计成不可变的，出于以下几点考虑：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 字符串常量池的需要。字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。正因为String的不可变性，常量池很容易被管理和优化。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 安全性考虑。正因为使用字符串的场景如此之多，所以设计成不可变可以有效的防止字符串被有意或者无意的篡改。从java源码中String的设计中我们不难发现，该类被final修饰，同时所有的属性都被final修饰，在源码中也未暴露任何成员变量的修改方法。（当然如果我们想，通过反射或者Unsafe直接操作内存的手段也可以实现对所谓不可变String的修改）。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 作为HashMap、HashTable等hash型数据key的必要。因为不可变的设计，jvm底层很容易在缓存String对象的时候缓存其hashcode，这样在执行效率上会大大提升。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-static关键字\"><a href=\"#2-static关键字\" class=\"headerlink\" title=\"2 static关键字\"></a>2 static关键字</h2><p>static 用了很多次了，静态嘛顾名思义，放在变量前面就是静态变量，放在代码块前面，就是静态代码块，静态的意思就是固定的，在类加载的一开始就准备好了，类加载之初，初始化static parameters,static block.，静态变量放在哪里，方法区。代码中不管实例化了多少对象，这些变量都是共用的。那么他们线程安全吗，显然是不，让我们用代码来说明这一点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NormalCount implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Getter</span><br><span class=\"line\">    private static int count = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        Double d = Math.random() * 1000;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(d.longValue());</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>testCase如下,这种写法是先创建一个类然后并发的调用count++<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testNormalnew() throws InterruptedException &#123;</span><br><span class=\"line\">    ExecutorService es = Executors.newFixedThreadPool(100);</span><br><span class=\"line\">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">        es.execute(new NormalCount());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    es.shutdown();</span><br><span class=\"line\">    while (!es.isTerminated()) &#123;</span><br><span class=\"line\">        Thread.sleep(3000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Assert.assertEquals(100,NormalCount.getCount());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里又想插句题外话了，不好的testcase真的会给你带来误解，如果testCase写的不行，最后可能告诉你错误的结论，最后给理解带来偏差，可以看到在NormalCount这个类里面count++前面我用了一个随机数去让线程睡眠，为什么要这样，如果没有这一步，testcase很可能不会报错，注意看我是创建了一个拥有100个线程的线程池，如果说for循环中的顺序去执行，每个count++的速度和时间都差不多，那么每个线程都是顺序执行的，实际上没有并发的场景。而误以为这是并发但是实际上是线程安全的，这就会带给你错误的结论。<br>那么问题来了，听说volatile可以解决变量多线程之间的可见性，那意思就是刚刚的变量前面加个volatile这个testCase就ok了吗,试试后发现不行，不管是static的volatile我们创建多个类去并发访问，还是not static的volatile我们用多个线程去访问一个类，都是没有通过testCase。这是为啥呢，其实还是对volatile有误解。<br>volatile可以让变量在多线程之间可见，可以防止jvm优化的指令重排，这段我简单说说，就是volatile变量每次使用前都会刷新(CAS机制)，但是因为count++这个操作是非原子性的，所以拿到变量的时候还是最新的，但是可能操作过程中已经是过期的数据了，最后会让数据不一致。所以用volatile最好是原子性的操作比如对boolean的判断，没有其他操作，它是完全ok的<br>上述代码如果想线程安全应该如何修改？有以下方法：<br>1 ++方法用synchronized加锁,效率会比较低<br>2 int 变量换成atomicInteger,这个类是线程安全的<br>好了关于static 就说这么多.</p>\n<h2 id=\"3-ThreadLocal分析\"><a href=\"#3-ThreadLocal分析\" class=\"headerlink\" title=\"3 ThreadLocal分析\"></a>3 ThreadLocal分析</h2><p>Threadlocal是用来干嘛的，没有用过的人会对她敬而远之，只有用过的人才知道没有那么高冷。threadlocal简单来说，是用来存放线程独有的变量，线程之间是不共用的(?如果引用了static变量那就….)。你可能会问了，那方法里面局部变量不也行吗，确实局部变量是线程独享的，但是我们想要在线程中多个参数里方便的传递一个变量，局部变量就做不到了。Threadlocal就是这么来的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">This class provides thread-local variables.  These variables differ from</span><br><span class=\"line\">their normal counterparts in that each thread that accesses one (via its</span><br><span class=\"line\">&#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized</span><br><span class=\"line\">copy of the variable.  &#123;@code ThreadLocal&#125; instances are typically private</span><br><span class=\"line\">static fields in classes that wish to associate state with a thread (e.g.,</span><br><span class=\"line\">a user ID or Transaction ID).</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;For example, the class below generates unique identifiers local to each</span><br><span class=\"line\">thread.</span><br><span class=\"line\">A thread&apos;s id is assigned the first time it invokes &#123;@code ThreadId.get()&#125;</span><br><span class=\"line\">and remains unchanged on subsequent calls.</span><br><span class=\"line\">&lt;pre&gt;</span><br><span class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\">public class ThreadId &#123;</span><br><span class=\"line\">// Atomic integer containing the next thread ID to be assigned</span><br><span class=\"line\">private static final AtomicInteger nextId = new AtomicInteger(0);</span><br><span class=\"line\"></span><br><span class=\"line\">// Thread local variable containing each thread&apos;s ID</span><br><span class=\"line\">private static final ThreadLocal&lt;Integer&gt; threadId =</span><br><span class=\"line\">  new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class=\"line\">      @Override </span><br><span class=\"line\">      protected Integer initialValue() &#123;</span><br><span class=\"line\">          return nextId.getAndIncrement();</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns the current thread&apos;s unique ID, assigning it if necessary</span><br><span class=\"line\">public static int get() &#123;</span><br><span class=\"line\">  return threadId.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/pre&gt;</span><br><span class=\"line\">&lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local</span><br><span class=\"line\">variable as long as the thread is alive and the &#123;@code ThreadLocal&#125;</span><br><span class=\"line\">instance is accessible; after a thread goes away, all of its copies of</span><br><span class=\"line\">thread-local instances are subject to garbage collection (unless other</span><br><span class=\"line\">references to these copies exist).</span><br></pre></td></tr></table></figure></p>\n<p>来看看Java之父Josh Bloch怎么说，其实说的还是挺清楚的，threadlocal是一个线程独有的变量，通常声明为private static 是为了保证这个变量和线程具有同样的生命周期，因为内部使用了弱引用，所以如果没有别的变量引用threadlocal会被gc清理。至于线程安不安全，不能保证哦…注释里面的这个例子其实很经典了，为每个线程创建一个threadId,这个id用atomicInteger生成，保证并发情况下的唯一性。看下Threadlocal的源码分析很多了这里就不贴了，简单来说，每个Thread里面都有一个变量叫做threadlocalMap这个map的实现是一个继承了弱引用的entry，map里面的key是threadlocal对象，value是对象的值。Threadlocal的get方法就是通过Thread获得threadlocalmap,然后以threadlocal对象本身为键去求的value.看下我的例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadCount implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ThreadLocal&lt;Integer&gt; localcount = ThreadLocal.withInitial(()-&gt;0);</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getLocalCount() &#123;</span><br><span class=\"line\">        localcount.set(localcount.get()+1);</span><br><span class=\"line\">        return localcount.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        for(int i =0;i&lt;3;i++)&#123;</span><br><span class=\"line\">            Double d = Math.random() * 1000;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(d.longValue());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;: &quot;+getLocalCount());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>TestCase如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testThreadLocals() throws InterruptedException &#123;</span><br><span class=\"line\">    ThreadCount count = new ThreadCount();</span><br><span class=\"line\">    ExecutorService es = Executors.newFixedThreadPool(100);</span><br><span class=\"line\">    for(int i=0;i&lt;100;i++)&#123;</span><br><span class=\"line\">        es.execute(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    es.shutdown();</span><br><span class=\"line\">    while(!es.isTerminated())&#123;</span><br><span class=\"line\">        Thread.sleep(3000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从打印的结果看，每个线程都打印了123,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-2-thread-81: 1</span><br><span class=\"line\">pool-2-thread-42: 1</span><br><span class=\"line\">pool-2-thread-6: 1</span><br><span class=\"line\">pool-2-thread-14: 2</span><br><span class=\"line\">pool-2-thread-80: 1</span><br><span class=\"line\">pool-2-thread-73: 2</span><br><span class=\"line\">pool-2-thread-25: 2</span><br><span class=\"line\">pool-2-thread-93: 1</span><br><span class=\"line\">pool-2-thread-15: 1</span><br><span class=\"line\">pool-2-thread-55: 1</span><br></pre></td></tr></table></figure></p>\n<p>这里我把线程池的默认线程个数改为10，结果如何呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-2-thread-5: 9</span><br><span class=\"line\">pool-2-thread-10: 9</span><br><span class=\"line\">pool-2-thread-1: 9</span><br><span class=\"line\">pool-2-thread-5: 10</span><br><span class=\"line\">pool-2-thread-7: 7</span><br><span class=\"line\">pool-2-thread-8: 11</span><br><span class=\"line\">pool-2-thread-9: 10</span><br><span class=\"line\">pool-2-thread-6: 8</span><br></pre></td></tr></table></figure></p>\n<p>居然有的线程的值到了9，10 这怎么可能，其实这个是对线程池不够了解，线程池会对已有的线程进行复用，所以如果一个线程用完以后是count的值3，但是被别的线程复用以后就会大于3了，这其实是threadlocal使用中需要注意的，如果用到了线程池，那用完threadlocal记得还原。<br>除了线程池的这个坑，threadlocal是不是可以说是线程安全的呢？其实讲道理这个问题是概念的混淆，threadlocal只是一个在threadlocalmap里面存放了key,value,如果这个value是个线程不安全的值，比如说是个static变量，所有线程都可以修改，那threadlocal就是不安全的。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h2><p>jvm内存模型，加载机制，各种关键字，final,static,synchronized,volatile这些都是java工程师的必备武器，还是好好修炼吧 </p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjy3u76vr0000tgrl07o7u1ro","tag_id":"cjy3u76vz0002tgrlapcdidve","_id":"cjy3u76w7000btgrlp5jmptk2"},{"post_id":"cjy3u76vr0000tgrl07o7u1ro","tag_id":"cjy3u76w30006tgrld710d7vw","_id":"cjy3u76w7000ctgrlvedbwayx"},{"post_id":"cjy3u76vx0001tgrlgr1fq6h9","tag_id":"cjy3u76w60009tgrltieb5g50","_id":"cjy3u76w9000etgrl3p9bendf"},{"post_id":"cjy3u76w00003tgrlu54sqjsc","tag_id":"cjy3u76w60009tgrltieb5g50","_id":"cjy3u76wa000itgrl8qkft075"},{"post_id":"cjy3u76w00003tgrlu54sqjsc","tag_id":"cjy3u76w9000ftgrl0ayshh5c","_id":"cjy3u76wb000jtgrlf26w6cdb"},{"post_id":"cjy3u76w00003tgrlu54sqjsc","tag_id":"cjy3u76wa000gtgrl1aphilx4","_id":"cjy3u76wb000ltgrl3xcxvfmw"},{"post_id":"cjy3u76w10004tgrl2n8kky80","tag_id":"cjy3u76vz0002tgrlapcdidve","_id":"cjy3u76wb000mtgrlosvsvc31"},{"post_id":"cjy3u76w10004tgrl2n8kky80","tag_id":"cjy3u76w30006tgrld710d7vw","_id":"cjy3u76wb000otgrlp0h0e1ob"},{"post_id":"cjy3u76w20005tgrlt0462zwn","tag_id":"cjy3u76wb000ktgrlxtd100oa","_id":"cjy3u76wc000ptgrliusd6rvi"},{"post_id":"cjy3u76w40007tgrlw9hv06w6","tag_id":"cjy3u76wb000ktgrlxtd100oa","_id":"cjy3u76wc000stgrlgnvlm14t"},{"post_id":"cjy3u76w40007tgrlw9hv06w6","tag_id":"cjy3u76wc000qtgrl6zgle1f2","_id":"cjy3u76wc000ttgrlona92yn5"},{"post_id":"cjy3u76w50008tgrlcktssg5a","tag_id":"cjy3u76wc000rtgrlgf0ymf0v","_id":"cjy3u76wd000vtgrlaji236ln"},{"post_id":"cjy3u76w6000atgrl7mxhuthm","tag_id":"cjy3u76w9000ftgrl0ayshh5c","_id":"cjy3u76wd000wtgrlnq9mqy5f"},{"post_id":"cjy3u76ws000ytgrlkk7kfrr3","tag_id":"cjy3u76w60009tgrltieb5g50","_id":"cjy3u76wv0010tgrl755d0vsz"},{"post_id":"cjy3u76wp000xtgrlk68794zs","tag_id":"cjy3u76w60009tgrltieb5g50","_id":"cjy3u76wx0012tgrlb0ofcjtv"},{"post_id":"cjy3u76wp000xtgrlk68794zs","tag_id":"cjy3u76wu000ztgrljgjgva5i","_id":"cjy3u76wy0013tgrl58omebpv"},{"post_id":"cjy3u76wp000xtgrlk68794zs","tag_id":"cjy3u76ww0011tgrl8fkohxew","_id":"cjy3u76wy0014tgrl7aurvppk"}],"Tag":[{"name":"技术","_id":"cjy3u76vz0002tgrlapcdidve"},{"name":"博客","_id":"cjy3u76w30006tgrld710d7vw"},{"name":"Java","_id":"cjy3u76w60009tgrltieb5g50"},{"name":"Linux","_id":"cjy3u76w9000ftgrl0ayshh5c"},{"name":"JVM","_id":"cjy3u76wa000gtgrl1aphilx4"},{"name":"Python","_id":"cjy3u76wb000ktgrlxtd100oa"},{"name":"知乎","_id":"cjy3u76wc000qtgrl6zgle1f2"},{"name":"随笔","_id":"cjy3u76wc000rtgrlgf0ymf0v"},{"name":"Spring","_id":"cjy3u76wu000ztgrljgjgva5i"},{"name":"Rest","_id":"cjy3u76ww0011tgrl8fkohxew"}]}}